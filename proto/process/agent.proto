syntax = "proto3";

option go_package = "github.com/DataDog/agent-payload/process";

package datadog.process_agent;

import "github.com/DataDog/agent-payload/proto/metrics/agent_payload.proto";

//
// Message Types
//

message ResCollector {
	// Header must exist at position 1 for compatibility
	// with older version of the Agent. We should be able
	// to drop this at some point.
	message Header {
		int32 type = 4;
	}
	Header header = 1;
	string message = 2;
	CollectorStatus status = 3;
}

message CollectorProc {
	string  hostName = 2;
	string networkId = 11;
	repeated Process processes = 3;
	Host host = 4;
	SystemInfo info = 5;
	int32 groupId = 6;
	int32 groupSize = 7;

	// Optional metadata fields
	datadog.agentpayload.KubeMetadataPayload kubernetes = 8; // DEPRECATED - left in place to support previous versions
	datadog.agentpayload.ECSMetadataPayload ecs = 9; // DEPRECATED - left in place to support previous versions

	repeated Container containers = 10;
}

message CollectorConnections {
	reserved 1, 4;

	string hostName = 2;
	string networkId = 12;
	int32 hostId = 9; // Post-resolution field.
	repeated Connection connections = 3;

	// Message batching metadata
	int32 groupId = 5;
	int32 groupSize = 6;

	// Mapping of hostId to Host. Each `connection` has a hostId field which can be mapped here.
	// This should also include an entry for the host on which these connections were gathered.
	map<int32, Host> resolvedHosts = 7; // Post-resolution field

	// Mapping of containerId to container data. Each `connection` has a containerId field which can be mapped here.
	map<string, ContainerMetadata> resolvedContainers = 8; // Post-resolution field

	// Mapping of processes running in each container
	map<int32, string> containerForPid = 10;

	// Mapping of IP address to DNS entries
	map<string, DNSEntry> dns = 13;

	bytes encodedTags = 11;
}

message CollectorRealTime {
	string hostName = 2;
	repeated ProcessStat stats = 3;
	// Post-resolved fields
	int32 hostId = 4;
	int32 orgId = 5;
	int32 groupId = 6;
	int32 groupSize = 7;
	int32 numCpus = 8;
	int64 totalMemory = 9;

	repeated ContainerStat containerStats = 10;
}

message CollectorContainer {
	string hostName = 1;
	string networkId = 11;
	SystemInfo info = 2;
	repeated Container containers = 3;
	int32 groupId = 4;
	int32 groupSize = 5;

	// Optional metadata fields
	datadog.agentpayload.KubeMetadataPayload kubernetes = 6; // DEPRECATED - left in place to support previous versions
	datadog.agentpayload.ECSMetadataPayload ecs = 7; // DEPRECATED - left in place to support previous versions

	// Post-resolved fields
	Host host = 8;
}

message CollectorContainerRealTime {
	string hostName = 1;
	repeated ContainerStat stats = 2;

	// Used for normalization at host-level.
	int32 numCpus = 3;
	int64 totalMemory = 4;

	// Post-resolved fields
	int32 hostId = 5;

	int32 groupId = 6;
	int32 groupSize = 7;
}

message CollectorReqStatus {
	string hostName = 2;
}

//
// Models
//

message CollectorStatus {
	int32 activeClients = 1;
	int32 interval = 2;
}

message Process {
	reserved 6;

	uint32 key = 1;
	int32 pid = 2;
	Host host = 3;
	Command command = 4;
	ProcessUser user = 5;
	MemoryStat memory = 7;
	CPUStat cpu = 8;
	int64 createTime = 9;
	Container container = 10; // DEPRECATED - left in place to support previous versions
	int32 openFdCount = 11;
	ProcessState state = 12;
	IOStat ioStat = 13;
	string containerId = 14;
	uint32 containerKey = 15;
	uint64 voluntaryCtxSwitches = 16;
	uint64 involuntaryCtxSwitches = 17;
	bytes byteKey = 18;
	bytes containerByteKey = 19;
}

message Command {
	repeated string args = 1;
	string cwd = 3;
	string root = 4;
	bool onDisk = 5;
	int32 ppid = 6;
	int32 pgroup = 7;
	string exe = 8;
}

message ProcessUser {
	string name = 1;
	int32 uid = 2;
	int32 gid = 3;
	int32 euid = 4;
	int32 egid = 5;
	int32 suid = 6;
	int32 sgid = 7;
}

// status section in https://docs.docker.com/engine/api/v1.29/#tag/Container
enum ContainerState {
	unknown = 0;
	created = 1;
	restarting = 2;
	running = 3;
	paused = 4;
	exited = 5;
	dead = 6;
}

// https://blog.couchbase.com/docker-health-check-keeping-containers-healthy/
// health can be: starting, healthy, unhealthy
enum ContainerHealth {
	unknownHealth = 0;
	starting = 1;
	healthy = 2;
	unhealthy = 3;
}

// ContainerAddr records the IPs, Ports and Protocols for each container
message ContainerAddr {
	string ip = 1;
	int32 port = 2;
	ConnectionType protocol = 3;
}

message Container {
	reserved 7;

	string type = 1;
	string id = 2;
	string name = 3; // DEPRECATED - left in place to support previous versions
	string image = 4; // DEPRECATED - left in place to support previous versions
	float  cpuLimit = 5;
	uint64 memoryLimit = 6;
	ContainerState state = 8;
	ContainerHealth health = 9;
	int64 created = 10;
	float rbps = 11;
	float wbps = 12;
	uint32 key = 13; // Unique key for a container resolved on backend.
	float netRcvdPs = 14;
	float netSentPs = 15;
	float netRcvdBps = 16;
	float netSentBps = 17;
	float userPct = 18;
	float systemPct = 19;
	float totalPct = 20;
	uint64 memRss = 21;
	uint64 memCache = 22;
	Host host = 23; // Used post-resolution
	int64 started = 24;
	bytes byteKey = 25;
	repeated string tags = 26;
	repeated ContainerAddr addresses = 27;
	uint64 threadCount = 28;
	uint64 threadLimit = 29;
}

// Process state codes in http://wiki.preshweb.co.uk/doku.php?id=linux:psflags
enum ProcessState {
	U = 0; // unknown state
	D = 1;
	R = 2;
	S = 3;
	T = 4;
	W = 5;
	X = 6;
	Z = 7;
}

// ProcessStat is used for real-time process messages. It should only contain
// data that can change for a running process (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small.
message ProcessStat {
	int32 pid = 1;
	// In milliseconds
	int64 createTime = 2;
	MemoryStat memory = 3;
	CPUStat cpu = 4;
	int32 nice = 5;
	int32 threads = 7;
	int32 openFdCount = 8;
	uint32 key = 9;
	// we need container id because we need to do the scoring by container
	string containerId = 10;
	ContainerState containerState = 11; // DEPRECATED
	ProcessState processState = 12;
	IOStat ioStat = 19;

	// DEPRECATED: All container-level stats (except ID) have moved into ContainerStat.
	// These will be removed in the future.
	// These stats are from the container level but are stored per-process
	// because we don't send a container primitive yet.
	ContainerHealth containerHealth = 15;
	float containerRbps = 16;
	float containerWbps = 17;
	uint32 containerKey = 18;
	float containerNetRcvdPs = 20;
	float containerNetSentPs = 21;
	float containerNetRcvdBps = 22;
	float containerNetSentBps = 23;

	uint64 voluntaryCtxSwitches = 24;
	uint64 involuntaryCtxSwitches = 25;
	bytes byteKey = 26;
	bytes containerByteKey = 27;
}

// ContainerStat is used for real-time container messages. It should only contain
// data that can change for a running container (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small (basically no strings except ID)
message ContainerStat {
	string id = 1;
	float userPct = 2;
	float systemPct = 3;
	float totalPct = 4;
	float cpuLimit = 5;
	uint64 memRss = 6;
	uint64 memCache = 7;
	uint64 memLimit = 8;
	float rbps = 9;
	float wbps = 10;
	float netRcvdPs = 11;
	float netSentPs = 12;
	float netRcvdBps = 13;
	float netSentBps = 14;
	ContainerState state = 15;
	ContainerHealth health = 16;
	// Post-resolved fields
	uint32 key = 17;
	int64 started = 18;
	bytes byteKey = 19;
	uint64 threadCount = 20;
	uint64 threadLimit = 21;
}

// ContainerMetadata only holds enough information to identify a container in connection data
message ContainerMetadata {
	string id = 1;
	uint32 key = 2;
	bytes byteKey = 3;
	repeated string tags = 4;
	int32 tagIndex = 5;
	int64 tagsModified = 6;
}

message SystemInfo {
	reserved 4;

	string uuid = 1;
	OSInfo os = 2;
	repeated CPUInfo cpus = 3;
	int64 totalMemory = 5;
}

message OSInfo {
	string name = 1;
	string platform = 2;
	string family = 3;
	string version = 4;
	string kernelVersion = 5;
}

message IOStat {
	float readRate = 1;
	float writeRate = 2;
	float readBytesRate = 3;
	float writeBytesRate = 4;
}

enum ConnectionType {
	tcp = 0;
	udp = 1;
}

enum ConnectionFamily {
	v4 = 0;
	v6 = 1;
}

enum ConnectionDirection {
	unspecified = 0;
	incoming = 1;
	outgoing = 2;
	local = 3;
	none = 4;
}

message Connection {
	reserved 2, 3, 4, 7, 8, 9, 13, 14, 15;

	int32 pid = 1;
	Addr laddr = 5; // Local address
	Addr raddr = 6; // Remote address
	ConnectionFamily family = 10;
	ConnectionType type = 11;
	int64 pidCreateTime = 12;

	// Relative counters since last check
	uint64 lastBytesSent = 16;
	uint64 lastBytesReceived = 17;
	uint32 lastRetransmits = 18;
	ConnectionDirection direction = 19;

	// Network namespace
	uint32 netNS = 20;

	// the conntrack entry associated with the connection. May be null on systems which don't support querying conntrack.
	IPTranslation ipTranslation = 21;

	// TCP-specific metrics
	uint32 rtt = 22;
	uint32 rttVar = 23;
}

message Connections {
  repeated Connection conns = 1;
  map<string, DNSEntry> dns  = 2;
}

message Addr {
	reserved 1, 4;

	string ip = 2;
	int32  port = 3;
	string containerId = 5; // post-resolution field
	int32  hostId = 6;      // post-resolution field
}

message IPTranslation {
	string replSrcIP  = 1;
	string replDstIP  = 2;
	int32 replSrcPort = 3;
	int32 replDstPort = 4;
}

message MemoryStat {
	uint64 rss = 1;
	uint64 vms = 2;
	uint64 swap = 3;
	uint64 shared = 4;
	uint64 text = 5;
	uint64 lib = 6;
	uint64 data = 7;
	uint64 dirty = 8;
}

message CPUStat {
	string lastCpu = 1;
	float totalPct = 2;
	float userPct = 3;
	float systemPct = 4;
	int32 numThreads = 5;
	repeated SingleCPUStat cpus = 6;
	int32 nice = 7;
	int64 userTime = 8;
	int64 systemTime = 9;
}

message SingleCPUStat {
	string name = 1;
	float  totalPct = 2;
}

message CPUInfo {
	int32 number = 1;
	string vendor = 2;
	string family = 3;
	string model = 4;
	string physicalId = 5;
	string coreId = 6;
	int32 cores = 7;
	int64 mhz = 8;
	int32 cacheSize = 9;
}

// Host is used in backend post-resolution

message Host {
	reserved 4, 5;

	int32 id = 1;
	int32 orgId = 2;
	string name = 3;
	repeated string allTags = 6;
	int32 numCpus = 7;
	int64 totalMemory = 8;
	int32 tagIndex = 9;
	int64 tagsModified = 10;
}

message DNSEntry {
  repeated string names = 1;
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto
message Pod {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  ObjectMeta metadata = 1;

  // Most recently observed status of the pod.
  // This data may not be up to date.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  PodStatus status = 2;

  string yaml = 3;

  repeated string tags = 4;
}

message ObjectMeta {
	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	string name = 1;

	// GenerateName is an prefix, used by the server, to generate a unique
	// name ONLY IF the Name field has not been provided.
	// If this field is used, the name returned to the client will be different
	// than the name passed. This value will also be combined with a unique suffix.
	// The provided value has the same validation rules as the Name field,
	// and may be truncated by the length of the suffix required to make the value
	// unique on the server.
	//
	// If this field is specified and the generated name exists, the server will
	// NOT return a 409 - instead, it will either return 201 Created or 500 with Reason
	// ServerTimeout indicating a unique name could not be found in the time allotted, and the client
	// should retry (optionally after the time indicated in the Retry-After header).
	//
	// Applied only if Name is not specified.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
	string generateName = 2;

	// Namespace defines the space within each name must be unique. An empty namespace is
	// equivalent to the "default" namespace, but "default" is the canonical representation.
	// Not all objects are required to be scoped to a namespace - the value of this field for
	// those objects will be empty.
	//
	// Must be a DNS_LABEL.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/namespaces
	string namespace = 3;

	// SelfLink is a URL representing this object.
	// Populated by the system.
	// Read-only.
	//
	// DEPRECATED
	// Kubernetes will stop propagating this field in 1.20 release and the field is planned
	// to be removed in 1.21 release.
	string selfLink = 4;

	// UID is the unique in time and space value for this object. It is typically generated by
	// the server on successful creation of a resource and is not allowed to change on PUT
	// operations.
	//
	// Populated by the system.
	// Read-only.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	string uid = 5;

	// An opaque value that represents the internal version of this object that can
	// be used by clients to determine when objects have changed. May be used for optimistic
	// concurrency, change detection, and the watch operation on a resource or set of resources.
	// Clients must treat these values as opaque and passed unmodified back to the server.
	// They may only be valid for a particular resource or set of resources.
	//
	// Populated by the system.
	// Read-only.
	// Value must be treated as opaque by clients and .
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
	string resourceVersion = 6;

	// A sequence number representing a specific generation of the desired state.
	// Populated by the system. Read-only.
	int64 generation = 7;

	// CreationTimestamp is a timestamp representing the server time when this object was
	// created. It is not guaranteed to be set in happens-before order across separate operations.
	// Clients may not set this value. It is represented in RFC3339 form and is in UTC.
	//
	// Populated by the system.
	// Read-only.
	// Null for lists.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Time creationTimestamp = 8;

	// DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This
	// field is set by the server when a graceful deletion is requested by the user, and is not
	// directly settable by a client. The resource is expected to be deleted (no longer visible
	// from resource lists, and not reachable by name) after the time in this field, once the
	// finalizers list is empty. As long as the finalizers list contains items, deletion is blocked.
	// Once the deletionTimestamp is set, this value may not be unset or be set further into the
	// future, although it may be shortened or the resource may be deleted prior to this time.
	// For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react
	// by sending a graceful termination signal to the containers in the pod. After that 30 seconds,
	// the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup,
	// remove the pod from the API. In the presence of network partitions, this object may still
	// exist after this timestamp, until an administrator or automated process can determine the
	// resource is fully terminated.
	// If not set, graceful deletion of the object has not been requested.
	//
	// Populated by the system when a graceful deletion is requested.
	// Read-only.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Time deletionTimestamp = 9;

	// Number of seconds allowed for this object to gracefully terminate before
	// it will be removed from the system. Only set when deletionTimestamp is also set.
	// May only be shortened.
	// Read-only.
	int64 deletionGracePeriodSeconds = 10;

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: http://kubernetes.io/docs/user-guide/labels
	map<string, string> labels = 11;

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	map<string, string> annotations = 12;

	// List of objects depended by this object. If ALL objects in the list have
	// been deleted, this object will be garbage collected. If this object is managed by a controller,
	// then an entry in this list will point to this controller, with the controller field set to true.
	// There cannot be more than one managing controller.
	// +patchMergeKey=uid
	// +patchStrategy=merge
	repeated OwnerReference ownerReferences = 13;

	// Must be empty before the object is deleted from the registry. Each entry
	// is an identifier for the responsible component that will remove the entry
	// from the list. If the deletionTimestamp of the object is non-nil, entries
	// in this list can only be removed.
	// Finalizers may be processed and removed in any order.  Order is NOT enforced
	// because it introduces significant risk of stuck finalizers.
	// finalizers is a shared field, any actor with permission can reorder it.
	// If the finalizer list is processed in order, then this can lead to a situation
	// in which the component responsible for the first finalizer in the list is
	// waiting for a signal (field value, external system, or other) produced by a
	// component responsible for a finalizer later in the list, resulting in a deadlock.
	// Without enforced ordering finalizers are free to order amongst themselves and
	// are not vulnerable to ordering changes in the list.
	// +patchStrategy=merge
	repeated string finalizers = 14;

	// The name of the cluster which the object belongs to.
	// This is used to distinguish resources with same name and namespace in different clusters.
	// This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
	string clusterName = 15;
}

// OwnerReference contains enough information to let you identify an owning
// object. An owning object must be in the same namespace as the dependent, or
// be cluster-scoped, so there is no namespace field.
message OwnerReference {
	// API version of the referent.
	string apiVersion = 5;

	// Kind of the referent.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	string kind = 1;

	// Name of the referent.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	string name = 3;

	// UID of the referent.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	string uid = 4;

	// If true, this reference points to the managing controller.
	bool controller = 6;

	// If true, AND if the owner has the "foregroundDeletion" finalizer, then
	// the owner cannot be deleted from the key-value store until this
	// reference is removed.
	// Defaults to false.
	// To set this field, a user needs "delete" permission of the owner,
	// otherwise 422 (Unprocessable Entity) will be returned.
	bool blockOwnerDeletion = 7;
}

// Time is a wrapper around time.Time which supports correct
// marshaling to YAML and JSON.  Wrappers are provided for many
// of the factory methods that the time package offers.
//
// +protobuf.options.marshal=false
// +protobuf.as=Timestamp
// +protobuf.options.(gogoproto.goproto_stringer)=false
message Time {
	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	int64 seconds = 1;

	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive. This field may be limited in precision depending on context.
	int32 nanos = 2;
}

  message PodStatus {
	// The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
	// The conditions array, the reason and message fields, and the individual container status
	// arrays contain more detail about the pod's status.
	// There are five possible phase values:
	//
	// Pending: The pod has been accepted by the Kubernetes system, but one or more of the
	// container images has not been created. This includes time before being scheduled as
	// well as time spent downloading images over the network, which could take a while.
	// Running: The pod has been bound to a node, and all of the containers have been created.
	// At least one container is still running, or is in the process of starting or restarting.
	// Succeeded: All containers in the pod have terminated in success, and will not be restarted.
	// Failed: All containers in the pod have terminated, and at least one container has
	// terminated in failure. The container either exited with non-zero status or was terminated
	// by the system.
	// Unknown: For some reason the state of the pod could not be obtained, typically due to an
	// error in communicating with the host of the pod.
	//
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
	string phase = 1;

	// Current service state of pod.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	// +patchMergeKey=type
	// +patchStrategy=merge
	repeated PodCondition conditions = 2;

	// A human readable message indicating details about why the pod is in this condition.
	string message = 3;

	// A brief CamelCase message indicating details about why the pod is in this state.
	// e.g. 'Evicted'
	string reason = 4;

	// nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
	// scheduled right away as preemption victims receive their graceful termination periods.
	// This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
	// to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
	// give the resources on this node to a higher priority pod that is created after preemption.
	// As a result, this field may be different than PodSpec.nodeName when the pod is
	// scheduled.
	string nominatedNodeName = 11;

	// IP address of the host to which the pod is assigned. Empty if not yet scheduled.
	string hostIP = 5;

	// IP address allocated to the pod. Routable at least within the cluster.
	// Empty if not yet allocated.
	string podIP = 6;

	// podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
	// match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
	// is empty if no IPs have been allocated yet.
	// +patchStrategy=merge
	// +patchMergeKey=ip
	repeated PodIP podIPs = 12;

	// RFC 3339 date and time at which the object was acknowledged by the Kubelet.
	// This is before the Kubelet pulled the container image(s) for the pod.
	Time startTime = 7;

	// The list has one entry per init container in the manifest. The most recent successful
	// init container will have ready = true, the most recently started container will have
	// startTime set.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	repeated ContainerStatus initContainerStatuses = 10;

	// The list has one entry per container in the manifest. Each entry is currently the output
	// of `docker inspect`.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
	repeated ContainerStatus containerStatuses = 8;

	// The Quality of Service (QOS) classification assigned to the pod based on resource requirements
	// See PodQOSClass type for available QOS classes
	// More info: https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md
	string qosClass = 9;

	// Status for any ephemeral containers that have run in this pod.
	// This field is alpha-level and is only populated by servers that enable the EphemeralContainers feature.
	repeated ContainerStatus ephemeralContainerStatuses = 13;
}

message ContainerStatus {
	// This must be a DNS_LABEL. Each container in a pod must have a unique name.
	// Cannot be updated.
	string name = 1;

	// Details about the container's current condition.
	ContainerState state = 2;

	// Details about the container's last termination condition.
	ContainerState lastState = 3;

	// Specifies whether the container has passed its readiness probe.
	bool ready = 4;

	// The number of times the container has been restarted, currently based on
	// the number of dead containers that have not yet been removed.
	// Note that this is calculated from dead containers. But those containers are subject to
	// garbage collection. This value will get capped at 5 by GC.
	int32 restartCount = 5;

	// The image the container is running.
	// More info: https://kubernetes.io/docs/concepts/containers/images
	// TODO(dchen1107): Which image the container is running with?
	string image = 6;

	// ImageID of the container's image.
	string imageID = 7;

	// Container's ID in the format 'docker://<container_id>'.
	string containerID = 8;

	// Specifies whether the container has passed its startup probe.
	// Initialized as false, becomes true after startupProbe is considered successful.
	// Resets to false when the container is restarted, or if kubelet loses state temporarily.
	// Is always true when no startupProbe is defined.
	bool started = 9;
  }

  // ContainerState holds a possible state of container.
// Only one of its members may be specified.
// If none of them is specified, the default one is ContainerStateWaiting.
message ContainerState {
	// Details about a waiting container
	ContainerStateWaiting waiting = 1;

	// Details about a running container
	ContainerStateRunning running = 2;

	// Details about a terminated container
	ContainerStateTerminated terminated = 3;
}

message ContainerStateRunning {
	// Time at which the container was last (re-)started
	Time startedAt = 1;
}

message ContainerStateTerminated {
	// Exit status from the last termination of the container
	int32 exitCode = 1;

	// Signal from the last termination of the container
	int32 signal = 2;

	// (brief) reason from the last termination of the container
	string reason = 3;

	// Message regarding the last termination of the container
	string message = 4;

	// Time at which previous execution of the container started
	Time startedAt = 5;

	// Time at which the container last terminated
	Time finishedAt = 6;

	// Container's ID in the format 'docker://<container_id>'
	string containerID = 7;
}

message ContainerStateWaiting {
	// (brief) reason the container is not yet running.
	string reason = 1;

	// Message regarding why the container is not yet running.
	string message = 2;
}

message PodIP {
	// ip is an IP address (IPv4 or IPv6) assigned to the pod
	string ip = 1;
}

message PodCondition {
	// Type is the type of the condition.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	string type = 1;

	// Status is the status of the condition.
	// Can be True, False, Unknown.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
	string status = 2;

	// Last time we probed the condition.
	Time lastProbeTime = 3;

	// Last time the condition transitioned from one status to another.
	Time lastTransitionTime = 4;

	// Unique, one-word, CamelCase reason for the condition's last transition.
	string reason = 5;

	// Human-readable message indicating details about last transition.
	string message = 6;
}
