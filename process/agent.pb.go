// Code generated by protoc-gen-gogo.
// source: proto/process/agent.proto
// DO NOT EDIT!

/*
Package process is a generated protocol buffer package.

It is generated from these files:

	proto/process/agent.proto
	proto/process/connections.proto
	proto/process/events.proto

It has these top-level messages:

	ResCollector
	CollectorProc
	CollectorProcDiscovery
	CollectorRealTime
	CollectorContainer
	CollectorContainerRealTime
	CollectorReqStatus
	CollectorPod
	CollectorReplicaSet
	CollectorDeployment
	CollectorService
	CollectorNode
	CollectorCluster
	CollectorManifest
	CollectorManifestCRD
	CollectorManifestCR
	CollectorNamespace
	CollectorJob
	CollectorCronJob
	CollectorDaemonSet
	CollectorStatefulSet
	CollectorPersistentVolume
	CollectorPersistentVolumeClaim
	CollectorRole
	CollectorRoleBinding
	CollectorClusterRole
	CollectorClusterRoleBinding
	CollectorServiceAccount
	CollectorIngress
	CollectorVerticalPodAutoscaler
	CollectorHorizontalPodAutoscaler
	CollectorStatus
	Process
	ProcessDiscovery
	Command
	ProcessUser
	ProcessNetworks
	ContainerAddr
	Container
	ProcessStat
	ProcStatsWithPerm
	ProcStatsWithPermByPID
	ContainerStat
	SystemInfo
	OSInfo
	IOStat
	MemoryStat
	CPUStat
	SingleCPUStat
	CPUInfo
	Host
	Cluster
	Metadata
	OwnerReference
	ObjectReference
	ServicePort
	ServiceSessionAffinityConfig
	Node
	NodeStatus
	NodeCondition
	ContainerImage
	Taint
	ServiceSpec
	ServiceStatus
	Service
	DeploymentCondition
	Deployment
	ReplicaSetCondition
	ReplicaSet
	LabelSelectorRequirement
	Pod
	PodCondition
	ContainerStatus
	Manifest
	NamespaceCondition
	Namespace
	ResourceRequirements
	ResourceMetrics
	JobSpec
	JobStatus
	JobCondition
	Job
	CronJobSpec
	CronJobStatus
	CronJob
	DaemonSetSpec
	DaemonSetStatus
	DaemonSetCondition
	DaemonSet
	StatefulSetSpec
	StatefulSetStatus
	StatefulSetCondition
	StatefulSet
	PersistentVolume
	PersistentVolumeSpec
	PersistentVolumeSource
	GCEPersistentDiskVolumeSource
	AWSElasticBlockStoreVolumeSource
	AzureFilePersistentVolumeSource
	AzureDiskVolumeSource
	CSIVolumeSource
	SecretReference
	PersistentVolumeStatus
	NodeSelectorTerm
	PersistentVolumeClaim
	PersistentVolumeClaimStatus
	PersistentVolumeClaimSpec
	TypedLocalObjectReference
	PersistentVolumeClaimCondition
	PolicyRule
	Subject
	Role
	RoleBinding
	ClusterRole
	ClusterRoleBinding
	ServiceAccount
	IngressServiceBackend
	IngressBackend
	IngressTLS
	HTTPIngressPath
	IngressRule
	IngressSpec
	PortStatus
	LoadBalancerIngress
	IngressStatus
	Ingress
	KafkaRequestHeader
	KafkaAggregation
	DataStreamsAggregations
	HTTPAggregations
	HTTP2Aggregations
	HTTPStats
	DNSDatabaseEntry
	ResourceList
	VerticalPodAutoscaler
	VerticalPodAutoscalerCondition
	VerticalPodAutoscalerSpec
	VerticalPodAutoscalerTarget
	ContainerResourcePolicy
	VerticalPodAutoscalerStatus
	ContainerRecommendation
	VPACondition
	HorizontalPodAutoscaler
	HorizontalPodAutoscalerSpec
	HorizontalPodAutoscalerTarget
	HorizontalPodAutoscalerMetricSpec
	ObjectMetricSource
	MetricTarget
	MetricIdentifier
	PodsMetricSource
	ResourceMetricSource
	ContainerResourceMetricSource
	ExternalMetricSource
	HorizontalPodAutoscalerBehavior
	HPAScalingRules
	HPAScalingPolicy
	HorizontalPodAutoscalerStatus
	HorizontalPodAutoscalerCondition
	HorizontalPodAutoscalerMetricStatus
	ObjectMetricStatus
	PodsMetricStatus
	ResourceMetricStatus
	ContainerResourceMetricStatus
	ExternalMetricStatus
	CollectorConnections
	Connections
	Connection
	ResourceMetadata
	ConnectionsTelemetry
	CollectorConnectionsTelemetry
	RuntimeCompilationTelemetry
	AgentConfiguration
	Route
	Subnet
	RouteMetadata
	IPTranslation
	Addr
	ProtocolStack
	DNSEntry
	DNSStats
	DNSStatsByQueryType
	CollectorProcEvent
	ProcessEvent
	ProcessExec
	ProcessExit
*/
package process

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ContainerHostType is a enum that represents the type of host detected for container collection.
// Sometimes containers are running on host-less environment, we'll need additional information to identify them
// This will help with the host resolution when we resolve container payloads
type ContainerHostType int32

const (
	ContainerHostType_notSpecified ContainerHostType = 0
	ContainerHostType_fargateECS   ContainerHostType = 1
	ContainerHostType_fargateEKS   ContainerHostType = 2
)

var ContainerHostType_name = map[int32]string{
	0: "notSpecified",
	1: "fargateECS",
	2: "fargateEKS",
}
var ContainerHostType_value = map[string]int32{
	"notSpecified": 0,
	"fargateECS":   1,
	"fargateEKS":   2,
}

func (x ContainerHostType) String() string {
	return proto.EnumName(ContainerHostType_name, int32(x))
}
func (ContainerHostType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{0} }

// status section in https://docs.docker.com/engine/api/v1.29/#tag/Container
type ContainerState int32

const (
	ContainerState_unknown    ContainerState = 0
	ContainerState_created    ContainerState = 1
	ContainerState_restarting ContainerState = 2
	ContainerState_running    ContainerState = 3
	ContainerState_paused     ContainerState = 4
	ContainerState_exited     ContainerState = 5
	ContainerState_dead       ContainerState = 6
)

var ContainerState_name = map[int32]string{
	0: "unknown",
	1: "created",
	2: "restarting",
	3: "running",
	4: "paused",
	5: "exited",
	6: "dead",
}
var ContainerState_value = map[string]int32{
	"unknown":    0,
	"created":    1,
	"restarting": 2,
	"running":    3,
	"paused":     4,
	"exited":     5,
	"dead":       6,
}

func (x ContainerState) String() string {
	return proto.EnumName(ContainerState_name, int32(x))
}
func (ContainerState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{1} }

// https://blog.couchbase.com/docker-health-check-keeping-containers-healthy/
// health can be: starting, healthy, unhealthy
type ContainerHealth int32

const (
	ContainerHealth_unknownHealth ContainerHealth = 0
	ContainerHealth_starting      ContainerHealth = 1
	ContainerHealth_healthy       ContainerHealth = 2
	ContainerHealth_unhealthy     ContainerHealth = 3
)

var ContainerHealth_name = map[int32]string{
	0: "unknownHealth",
	1: "starting",
	2: "healthy",
	3: "unhealthy",
}
var ContainerHealth_value = map[string]int32{
	"unknownHealth": 0,
	"starting":      1,
	"healthy":       2,
	"unhealthy":     3,
}

func (x ContainerHealth) String() string {
	return proto.EnumName(ContainerHealth_name, int32(x))
}
func (ContainerHealth) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{2} }

// Process state codes in http://wiki.preshweb.co.uk/doku.php?id=linux:psflags
type ProcessState int32

const (
	ProcessState_U ProcessState = 0
	ProcessState_D ProcessState = 1
	ProcessState_R ProcessState = 2
	ProcessState_S ProcessState = 3
	ProcessState_T ProcessState = 4
	ProcessState_W ProcessState = 5
	ProcessState_X ProcessState = 6
	ProcessState_Z ProcessState = 7
)

var ProcessState_name = map[int32]string{
	0: "U",
	1: "D",
	2: "R",
	3: "S",
	4: "T",
	5: "W",
	6: "X",
	7: "Z",
}
var ProcessState_value = map[string]int32{
	"U": 0,
	"D": 1,
	"R": 2,
	"S": 3,
	"T": 4,
	"W": 5,
	"X": 6,
	"Z": 7,
}

func (x ProcessState) String() string {
	return proto.EnumName(ProcessState_name, int32(x))
}
func (ProcessState) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{3} }

type ConnectionType int32

const (
	ConnectionType_tcp ConnectionType = 0
	ConnectionType_udp ConnectionType = 1
)

var ConnectionType_name = map[int32]string{
	0: "tcp",
	1: "udp",
}
var ConnectionType_value = map[string]int32{
	"tcp": 0,
	"udp": 1,
}

func (x ConnectionType) String() string {
	return proto.EnumName(ConnectionType_name, int32(x))
}
func (ConnectionType) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{4} }

type K8SResource int32

const (
	K8SResource_K8SRESOURCE_UNSPECIFIED K8SResource = 0
	K8SResource_POD                     K8SResource = 1
	K8SResource_REPLICASET              K8SResource = 2
	K8SResource_SERVICE                 K8SResource = 3
	K8SResource_NODE                    K8SResource = 4
	K8SResource_CLUSTER                 K8SResource = 5
	K8SResource_JOB                     K8SResource = 6
	K8SResource_CRONJOB                 K8SResource = 7
	K8SResource_DAEMONSET               K8SResource = 8
	K8SResource_STATEFULSET             K8SResource = 9
	K8SResource_PERSISTENTVOLUME        K8SResource = 10
	K8SResource_PERSISTENTVOLUMECLAIM   K8SResource = 11
	K8SResource_ROLE                    K8SResource = 12
	K8SResource_ROLEBINDING             K8SResource = 13
	K8SResource_CLUSTERROLE             K8SResource = 14
	K8SResource_CLUSTERROLEBINDING      K8SResource = 15
	K8SResource_SERVICEACCOUNT          K8SResource = 16
	K8SResource_INGRESS                 K8SResource = 17
	K8SResource_DEPLOYMENT              K8SResource = 18
	K8SResource_NAMESPACE               K8SResource = 19
	K8SResource_CRD                     K8SResource = 20
	K8SResource_CR                      K8SResource = 21
	K8SResource_VERTICALPODAUTOSCALER   K8SResource = 22
	K8SResource_HORIZONTALPODAUTOSCALER K8SResource = 23
)

var K8SResource_name = map[int32]string{
	0:  "K8SRESOURCE_UNSPECIFIED",
	1:  "POD",
	2:  "REPLICASET",
	3:  "SERVICE",
	4:  "NODE",
	5:  "CLUSTER",
	6:  "JOB",
	7:  "CRONJOB",
	8:  "DAEMONSET",
	9:  "STATEFULSET",
	10: "PERSISTENTVOLUME",
	11: "PERSISTENTVOLUMECLAIM",
	12: "ROLE",
	13: "ROLEBINDING",
	14: "CLUSTERROLE",
	15: "CLUSTERROLEBINDING",
	16: "SERVICEACCOUNT",
	17: "INGRESS",
	18: "DEPLOYMENT",
	19: "NAMESPACE",
	20: "CRD",
	21: "CR",
	22: "VERTICALPODAUTOSCALER",
	23: "HORIZONTALPODAUTOSCALER",
}
var K8SResource_value = map[string]int32{
	"K8SRESOURCE_UNSPECIFIED": 0,
	"POD":                     1,
	"REPLICASET":              2,
	"SERVICE":                 3,
	"NODE":                    4,
	"CLUSTER":                 5,
	"JOB":                     6,
	"CRONJOB":                 7,
	"DAEMONSET":               8,
	"STATEFULSET":             9,
	"PERSISTENTVOLUME":        10,
	"PERSISTENTVOLUMECLAIM":   11,
	"ROLE":                    12,
	"ROLEBINDING":             13,
	"CLUSTERROLE":             14,
	"CLUSTERROLEBINDING":      15,
	"SERVICEACCOUNT":          16,
	"INGRESS":                 17,
	"DEPLOYMENT":              18,
	"NAMESPACE":               19,
	"CRD":                     20,
	"CR":                      21,
	"VERTICALPODAUTOSCALER":   22,
	"HORIZONTALPODAUTOSCALER": 23,
}

func (x K8SResource) String() string {
	return proto.EnumName(K8SResource_name, int32(x))
}
func (K8SResource) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{5} }

type ResourceRequirementsType int32

const (
	ResourceRequirementsType_unknownType        ResourceRequirementsType = 0
	ResourceRequirementsType_container          ResourceRequirementsType = 1
	ResourceRequirementsType_initContainer      ResourceRequirementsType = 2
	ResourceRequirementsType_ephemeralContainer ResourceRequirementsType = 3
)

var ResourceRequirementsType_name = map[int32]string{
	0: "unknownType",
	1: "container",
	2: "initContainer",
	3: "ephemeralContainer",
}
var ResourceRequirementsType_value = map[string]int32{
	"unknownType":        0,
	"container":          1,
	"initContainer":      2,
	"ephemeralContainer": 3,
}

func (x ResourceRequirementsType) String() string {
	return proto.EnumName(ResourceRequirementsType_name, int32(x))
}
func (ResourceRequirementsType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{6}
}

type HTTPResponseStatus int32

const (
	HTTPResponseStatus_Info      HTTPResponseStatus = 0
	HTTPResponseStatus_Success   HTTPResponseStatus = 1
	HTTPResponseStatus_Redirect  HTTPResponseStatus = 2
	HTTPResponseStatus_ClientErr HTTPResponseStatus = 3
	HTTPResponseStatus_ServerErr HTTPResponseStatus = 4
)

var HTTPResponseStatus_name = map[int32]string{
	0: "Info",
	1: "Success",
	2: "Redirect",
	3: "ClientErr",
	4: "ServerErr",
}
var HTTPResponseStatus_value = map[string]int32{
	"Info":      0,
	"Success":   1,
	"Redirect":  2,
	"ClientErr": 3,
	"ServerErr": 4,
}

func (x HTTPResponseStatus) String() string {
	return proto.EnumName(HTTPResponseStatus_name, int32(x))
}
func (HTTPResponseStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{7} }

type HTTPMethod int32

const (
	HTTPMethod_Unknown HTTPMethod = 0
	HTTPMethod_Get     HTTPMethod = 1
	HTTPMethod_Post    HTTPMethod = 2
	HTTPMethod_Put     HTTPMethod = 3
	HTTPMethod_Delete  HTTPMethod = 4
	HTTPMethod_Head    HTTPMethod = 5
	HTTPMethod_Options HTTPMethod = 6
	HTTPMethod_Patch   HTTPMethod = 7
)

var HTTPMethod_name = map[int32]string{
	0: "Unknown",
	1: "Get",
	2: "Post",
	3: "Put",
	4: "Delete",
	5: "Head",
	6: "Options",
	7: "Patch",
}
var HTTPMethod_value = map[string]int32{
	"Unknown": 0,
	"Get":     1,
	"Post":    2,
	"Put":     3,
	"Delete":  4,
	"Head":    5,
	"Options": 6,
	"Patch":   7,
}

func (x HTTPMethod) String() string {
	return proto.EnumName(HTTPMethod_name, int32(x))
}
func (HTTPMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptorAgent, []int{8} }

type ResCollector struct {
	Header  *ResCollector_Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Message string               `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Status  *CollectorStatus     `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *ResCollector) Reset()                    { *m = ResCollector{} }
func (m *ResCollector) String() string            { return proto.CompactTextString(m) }
func (*ResCollector) ProtoMessage()               {}
func (*ResCollector) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{0} }

func (m *ResCollector) GetHeader() *ResCollector_Header {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *ResCollector) GetStatus() *CollectorStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// Header must exist at position 1 for compatibility
// with older version of the Agent. We should be able
// to drop this at some point.
type ResCollector_Header struct {
	Type int32 `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *ResCollector_Header) Reset()                    { *m = ResCollector_Header{} }
func (m *ResCollector_Header) String() string            { return proto.CompactTextString(m) }
func (*ResCollector_Header) ProtoMessage()               {}
func (*ResCollector_Header) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{0, 0} }

type CollectorProc struct {
	HostName          string            `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	NetworkId         string            `protobuf:"bytes,11,opt,name=networkId,proto3" json:"networkId,omitempty"`
	Processes         []*Process        `protobuf:"bytes,3,rep,name=processes" json:"processes,omitempty"`
	Host              *Host             `protobuf:"bytes,4,opt,name=host" json:"host,omitempty"`
	Info              *SystemInfo       `protobuf:"bytes,5,opt,name=info" json:"info,omitempty"`
	GroupId           int32             `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize         int32             `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Containers        []*Container      `protobuf:"bytes,10,rep,name=containers" json:"containers,omitempty"`
	ContainerHostType ContainerHostType `protobuf:"varint,12,opt,name=containerHostType,proto3,enum=datadog.process_agent.ContainerHostType" json:"containerHostType,omitempty"`
	// Types that are valid to be assigned to Hints:
	//	*CollectorProc_HintMask
	Hints isCollectorProc_Hints `protobuf_oneof:"hints"`
}

func (m *CollectorProc) Reset()                    { *m = CollectorProc{} }
func (m *CollectorProc) String() string            { return proto.CompactTextString(m) }
func (*CollectorProc) ProtoMessage()               {}
func (*CollectorProc) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{1} }

type isCollectorProc_Hints interface {
	isCollectorProc_Hints()
	MarshalTo([]byte) (int, error)
	Size() int
}

type CollectorProc_HintMask struct {
	HintMask int32 `protobuf:"varint,14,opt,name=hintMask,proto3,oneof"`
}

func (*CollectorProc_HintMask) isCollectorProc_Hints() {}

func (m *CollectorProc) GetHints() isCollectorProc_Hints {
	if m != nil {
		return m.Hints
	}
	return nil
}

func (m *CollectorProc) GetProcesses() []*Process {
	if m != nil {
		return m.Processes
	}
	return nil
}

func (m *CollectorProc) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *CollectorProc) GetInfo() *SystemInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CollectorProc) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *CollectorProc) GetHintMask() int32 {
	if x, ok := m.GetHints().(*CollectorProc_HintMask); ok {
		return x.HintMask
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*CollectorProc) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _CollectorProc_OneofMarshaler, _CollectorProc_OneofUnmarshaler, _CollectorProc_OneofSizer, []interface{}{
		(*CollectorProc_HintMask)(nil),
	}
}

func _CollectorProc_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*CollectorProc)
	// hints
	switch x := m.Hints.(type) {
	case *CollectorProc_HintMask:
		_ = b.EncodeVarint(14<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.HintMask))
	case nil:
	default:
		return fmt.Errorf("CollectorProc.Hints has unexpected type %T", x)
	}
	return nil
}

func _CollectorProc_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*CollectorProc)
	switch tag {
	case 14: // hints.hintMask
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Hints = &CollectorProc_HintMask{int32(x)}
		return true, err
	default:
		return false, nil
	}
}

func _CollectorProc_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*CollectorProc)
	// hints
	switch x := m.Hints.(type) {
	case *CollectorProc_HintMask:
		n += proto.SizeVarint(14<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.HintMask))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CollectorProcDiscovery struct {
	HostName           string              `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
	GroupId            int32               `protobuf:"varint,2,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize          int32               `protobuf:"varint,3,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	ProcessDiscoveries []*ProcessDiscovery `protobuf:"bytes,4,rep,name=processDiscoveries" json:"processDiscoveries,omitempty"`
	Host               *Host               `protobuf:"bytes,5,opt,name=host" json:"host,omitempty"`
}

func (m *CollectorProcDiscovery) Reset()                    { *m = CollectorProcDiscovery{} }
func (m *CollectorProcDiscovery) String() string            { return proto.CompactTextString(m) }
func (*CollectorProcDiscovery) ProtoMessage()               {}
func (*CollectorProcDiscovery) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{2} }

func (m *CollectorProcDiscovery) GetProcessDiscoveries() []*ProcessDiscovery {
	if m != nil {
		return m.ProcessDiscoveries
	}
	return nil
}

func (m *CollectorProcDiscovery) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

type CollectorRealTime struct {
	HostName string         `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Stats    []*ProcessStat `protobuf:"bytes,3,rep,name=stats" json:"stats,omitempty"`
	// Post-resolved fields
	HostId            int64             `protobuf:"varint,4,opt,name=hostId,proto3" json:"hostId,omitempty"`
	OrgId             int32             `protobuf:"varint,5,opt,name=orgId,proto3" json:"orgId,omitempty"`
	GroupId           int32             `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize         int32             `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	NumCpus           int32             `protobuf:"varint,8,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory       int64             `protobuf:"varint,9,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
	ContainerStats    []*ContainerStat  `protobuf:"bytes,10,rep,name=containerStats" json:"containerStats,omitempty"`
	ContainerHostType ContainerHostType `protobuf:"varint,11,opt,name=containerHostType,proto3,enum=datadog.process_agent.ContainerHostType" json:"containerHostType,omitempty"`
}

func (m *CollectorRealTime) Reset()                    { *m = CollectorRealTime{} }
func (m *CollectorRealTime) String() string            { return proto.CompactTextString(m) }
func (*CollectorRealTime) ProtoMessage()               {}
func (*CollectorRealTime) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{3} }

func (m *CollectorRealTime) GetStats() []*ProcessStat {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *CollectorRealTime) GetContainerStats() []*ContainerStat {
	if m != nil {
		return m.ContainerStats
	}
	return nil
}

type CollectorContainer struct {
	HostName   string       `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
	NetworkId  string       `protobuf:"bytes,11,opt,name=networkId,proto3" json:"networkId,omitempty"`
	Info       *SystemInfo  `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	Containers []*Container `protobuf:"bytes,3,rep,name=containers" json:"containers,omitempty"`
	GroupId    int32        `protobuf:"varint,4,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize  int32        `protobuf:"varint,5,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	// Post-resolved fields
	Host              *Host             `protobuf:"bytes,8,opt,name=host" json:"host,omitempty"`
	ContainerHostType ContainerHostType `protobuf:"varint,9,opt,name=containerHostType,proto3,enum=datadog.process_agent.ContainerHostType" json:"containerHostType,omitempty"`
}

func (m *CollectorContainer) Reset()                    { *m = CollectorContainer{} }
func (m *CollectorContainer) String() string            { return proto.CompactTextString(m) }
func (*CollectorContainer) ProtoMessage()               {}
func (*CollectorContainer) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{4} }

func (m *CollectorContainer) GetInfo() *SystemInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CollectorContainer) GetContainers() []*Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *CollectorContainer) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

type CollectorContainerRealTime struct {
	HostName string           `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
	Stats    []*ContainerStat `protobuf:"bytes,2,rep,name=stats" json:"stats,omitempty"`
	// Used for normalization at host-level.
	NumCpus     int32 `protobuf:"varint,3,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory int64 `protobuf:"varint,4,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
	// Post-resolved fields
	HostId            int64             `protobuf:"varint,5,opt,name=hostId,proto3" json:"hostId,omitempty"`
	GroupId           int32             `protobuf:"varint,6,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize         int32             `protobuf:"varint,7,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	ContainerHostType ContainerHostType `protobuf:"varint,8,opt,name=containerHostType,proto3,enum=datadog.process_agent.ContainerHostType" json:"containerHostType,omitempty"`
}

func (m *CollectorContainerRealTime) Reset()                    { *m = CollectorContainerRealTime{} }
func (m *CollectorContainerRealTime) String() string            { return proto.CompactTextString(m) }
func (*CollectorContainerRealTime) ProtoMessage()               {}
func (*CollectorContainerRealTime) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{5} }

func (m *CollectorContainerRealTime) GetStats() []*ContainerStat {
	if m != nil {
		return m.Stats
	}
	return nil
}

type CollectorReqStatus struct {
	HostName string `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
}

func (m *CollectorReqStatus) Reset()                    { *m = CollectorReqStatus{} }
func (m *CollectorReqStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorReqStatus) ProtoMessage()               {}
func (*CollectorReqStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{6} }

type CollectorPod struct {
	HostName    string   `protobuf:"bytes,1,opt,name=hostName,proto3" json:"hostName,omitempty"`
	ClusterName string   `protobuf:"bytes,2,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string   `protobuf:"bytes,3,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32    `protobuf:"varint,4,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32    `protobuf:"varint,5,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Pods        []*Pod   `protobuf:"bytes,6,rep,name=pods" json:"pods,omitempty"`
	Host        *Host    `protobuf:"bytes,7,opt,name=host" json:"host,omitempty"`
	Tags        []string `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorPod) Reset()                    { *m = CollectorPod{} }
func (m *CollectorPod) String() string            { return proto.CompactTextString(m) }
func (*CollectorPod) ProtoMessage()               {}
func (*CollectorPod) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{7} }

func (m *CollectorPod) GetPods() []*Pod {
	if m != nil {
		return m.Pods
	}
	return nil
}

func (m *CollectorPod) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

type CollectorReplicaSet struct {
	ClusterName string        `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string        `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32         `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32         `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	ReplicaSets []*ReplicaSet `protobuf:"bytes,5,rep,name=replicaSets" json:"replicaSets,omitempty"`
	Tags        []string      `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorReplicaSet) Reset()                    { *m = CollectorReplicaSet{} }
func (m *CollectorReplicaSet) String() string            { return proto.CompactTextString(m) }
func (*CollectorReplicaSet) ProtoMessage()               {}
func (*CollectorReplicaSet) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{8} }

func (m *CollectorReplicaSet) GetReplicaSets() []*ReplicaSet {
	if m != nil {
		return m.ReplicaSets
	}
	return nil
}

type CollectorDeployment struct {
	ClusterName string        `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string        `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32         `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32         `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Deployments []*Deployment `protobuf:"bytes,5,rep,name=deployments" json:"deployments,omitempty"`
	Tags        []string      `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorDeployment) Reset()                    { *m = CollectorDeployment{} }
func (m *CollectorDeployment) String() string            { return proto.CompactTextString(m) }
func (*CollectorDeployment) ProtoMessage()               {}
func (*CollectorDeployment) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{9} }

func (m *CollectorDeployment) GetDeployments() []*Deployment {
	if m != nil {
		return m.Deployments
	}
	return nil
}

type CollectorService struct {
	ClusterName string     `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string     `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32      `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32      `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Services    []*Service `protobuf:"bytes,5,rep,name=services" json:"services,omitempty"`
	Tags        []string   `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorService) Reset()                    { *m = CollectorService{} }
func (m *CollectorService) String() string            { return proto.CompactTextString(m) }
func (*CollectorService) ProtoMessage()               {}
func (*CollectorService) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{10} }

func (m *CollectorService) GetServices() []*Service {
	if m != nil {
		return m.Services
	}
	return nil
}

type CollectorNode struct {
	ClusterName      string           `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId        string           `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId          int32            `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize        int32            `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Nodes            []*Node          `protobuf:"bytes,5,rep,name=nodes" json:"nodes,omitempty"`
	Tags             []string         `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
	HostAliasMapping map[string]*Host `protobuf:"bytes,7,rep,name=hostAliasMapping" json:"hostAliasMapping,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CollectorNode) Reset()                    { *m = CollectorNode{} }
func (m *CollectorNode) String() string            { return proto.CompactTextString(m) }
func (*CollectorNode) ProtoMessage()               {}
func (*CollectorNode) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{11} }

func (m *CollectorNode) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CollectorNode) GetHostAliasMapping() map[string]*Host {
	if m != nil {
		return m.HostAliasMapping
	}
	return nil
}

type CollectorCluster struct {
	ClusterName string   `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string   `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32    `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Cluster     *Cluster `protobuf:"bytes,5,opt,name=cluster" json:"cluster,omitempty"`
	Tags        []string `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorCluster) Reset()                    { *m = CollectorCluster{} }
func (m *CollectorCluster) String() string            { return proto.CompactTextString(m) }
func (*CollectorCluster) ProtoMessage()               {}
func (*CollectorCluster) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{12} }

func (m *CollectorCluster) GetCluster() *Cluster {
	if m != nil {
		return m.Cluster
	}
	return nil
}

// CollectorManifest is the dedicated payload/pipeline for the yaml collection
type CollectorManifest struct {
	ClusterName string      `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string      `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32       `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32       `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Manifests   []*Manifest `protobuf:"bytes,5,rep,name=manifests" json:"manifests,omitempty"`
}

func (m *CollectorManifest) Reset()                    { *m = CollectorManifest{} }
func (m *CollectorManifest) String() string            { return proto.CompactTextString(m) }
func (*CollectorManifest) ProtoMessage()               {}
func (*CollectorManifest) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{13} }

func (m *CollectorManifest) GetManifests() []*Manifest {
	if m != nil {
		return m.Manifests
	}
	return nil
}

type CollectorManifestCRD struct {
	Manifest *CollectorManifest `protobuf:"bytes,1,opt,name=manifest" json:"manifest,omitempty"`
}

func (m *CollectorManifestCRD) Reset()                    { *m = CollectorManifestCRD{} }
func (m *CollectorManifestCRD) String() string            { return proto.CompactTextString(m) }
func (*CollectorManifestCRD) ProtoMessage()               {}
func (*CollectorManifestCRD) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{14} }

func (m *CollectorManifestCRD) GetManifest() *CollectorManifest {
	if m != nil {
		return m.Manifest
	}
	return nil
}

type CollectorManifestCR struct {
	Manifest *CollectorManifest `protobuf:"bytes,1,opt,name=manifest" json:"manifest,omitempty"`
}

func (m *CollectorManifestCR) Reset()                    { *m = CollectorManifestCR{} }
func (m *CollectorManifestCR) String() string            { return proto.CompactTextString(m) }
func (*CollectorManifestCR) ProtoMessage()               {}
func (*CollectorManifestCR) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{15} }

func (m *CollectorManifestCR) GetManifest() *CollectorManifest {
	if m != nil {
		return m.Manifest
	}
	return nil
}

type CollectorNamespace struct {
	ClusterName string       `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string       `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32        `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32        `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Namespaces  []*Namespace `protobuf:"bytes,5,rep,name=namespaces" json:"namespaces,omitempty"`
	Tags        []string     `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorNamespace) Reset()                    { *m = CollectorNamespace{} }
func (m *CollectorNamespace) String() string            { return proto.CompactTextString(m) }
func (*CollectorNamespace) ProtoMessage()               {}
func (*CollectorNamespace) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{16} }

func (m *CollectorNamespace) GetNamespaces() []*Namespace {
	if m != nil {
		return m.Namespaces
	}
	return nil
}

type CollectorJob struct {
	ClusterName string   `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string   `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32    `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Jobs        []*Job   `protobuf:"bytes,5,rep,name=jobs" json:"jobs,omitempty"`
	Tags        []string `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorJob) Reset()                    { *m = CollectorJob{} }
func (m *CollectorJob) String() string            { return proto.CompactTextString(m) }
func (*CollectorJob) ProtoMessage()               {}
func (*CollectorJob) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{17} }

func (m *CollectorJob) GetJobs() []*Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

type CollectorCronJob struct {
	ClusterName string     `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string     `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32      `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32      `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	CronJobs    []*CronJob `protobuf:"bytes,5,rep,name=cronJobs" json:"cronJobs,omitempty"`
	Tags        []string   `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorCronJob) Reset()                    { *m = CollectorCronJob{} }
func (m *CollectorCronJob) String() string            { return proto.CompactTextString(m) }
func (*CollectorCronJob) ProtoMessage()               {}
func (*CollectorCronJob) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{18} }

func (m *CollectorCronJob) GetCronJobs() []*CronJob {
	if m != nil {
		return m.CronJobs
	}
	return nil
}

type CollectorDaemonSet struct {
	ClusterName string       `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string       `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32        `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32        `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	DaemonSets  []*DaemonSet `protobuf:"bytes,5,rep,name=daemonSets" json:"daemonSets,omitempty"`
	Tags        []string     `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorDaemonSet) Reset()                    { *m = CollectorDaemonSet{} }
func (m *CollectorDaemonSet) String() string            { return proto.CompactTextString(m) }
func (*CollectorDaemonSet) ProtoMessage()               {}
func (*CollectorDaemonSet) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{19} }

func (m *CollectorDaemonSet) GetDaemonSets() []*DaemonSet {
	if m != nil {
		return m.DaemonSets
	}
	return nil
}

type CollectorStatefulSet struct {
	ClusterName  string         `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId    string         `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId      int32          `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize    int32          `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	StatefulSets []*StatefulSet `protobuf:"bytes,5,rep,name=statefulSets" json:"statefulSets,omitempty"`
	Tags         []string       `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorStatefulSet) Reset()                    { *m = CollectorStatefulSet{} }
func (m *CollectorStatefulSet) String() string            { return proto.CompactTextString(m) }
func (*CollectorStatefulSet) ProtoMessage()               {}
func (*CollectorStatefulSet) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{20} }

func (m *CollectorStatefulSet) GetStatefulSets() []*StatefulSet {
	if m != nil {
		return m.StatefulSets
	}
	return nil
}

type CollectorPersistentVolume struct {
	ClusterName       string              `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId         string              `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId           int32               `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize         int32               `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	PersistentVolumes []*PersistentVolume `protobuf:"bytes,5,rep,name=persistentVolumes" json:"persistentVolumes,omitempty"`
	Tags              []string            `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorPersistentVolume) Reset()                    { *m = CollectorPersistentVolume{} }
func (m *CollectorPersistentVolume) String() string            { return proto.CompactTextString(m) }
func (*CollectorPersistentVolume) ProtoMessage()               {}
func (*CollectorPersistentVolume) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{21} }

func (m *CollectorPersistentVolume) GetPersistentVolumes() []*PersistentVolume {
	if m != nil {
		return m.PersistentVolumes
	}
	return nil
}

type CollectorPersistentVolumeClaim struct {
	ClusterName            string                   `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId              string                   `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId                int32                    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize              int32                    `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	PersistentVolumeClaims []*PersistentVolumeClaim `protobuf:"bytes,5,rep,name=persistentVolumeClaims" json:"persistentVolumeClaims,omitempty"`
	Tags                   []string                 `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorPersistentVolumeClaim) Reset()         { *m = CollectorPersistentVolumeClaim{} }
func (m *CollectorPersistentVolumeClaim) String() string { return proto.CompactTextString(m) }
func (*CollectorPersistentVolumeClaim) ProtoMessage()    {}
func (*CollectorPersistentVolumeClaim) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{22}
}

func (m *CollectorPersistentVolumeClaim) GetPersistentVolumeClaims() []*PersistentVolumeClaim {
	if m != nil {
		return m.PersistentVolumeClaims
	}
	return nil
}

type CollectorRole struct {
	ClusterName string   `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string   `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32    `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Roles       []*Role  `protobuf:"bytes,5,rep,name=roles" json:"roles,omitempty"`
	Tags        []string `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorRole) Reset()                    { *m = CollectorRole{} }
func (m *CollectorRole) String() string            { return proto.CompactTextString(m) }
func (*CollectorRole) ProtoMessage()               {}
func (*CollectorRole) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{23} }

func (m *CollectorRole) GetRoles() []*Role {
	if m != nil {
		return m.Roles
	}
	return nil
}

type CollectorRoleBinding struct {
	ClusterName  string         `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId    string         `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId      int32          `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize    int32          `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	RoleBindings []*RoleBinding `protobuf:"bytes,5,rep,name=roleBindings" json:"roleBindings,omitempty"`
	Tags         []string       `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorRoleBinding) Reset()                    { *m = CollectorRoleBinding{} }
func (m *CollectorRoleBinding) String() string            { return proto.CompactTextString(m) }
func (*CollectorRoleBinding) ProtoMessage()               {}
func (*CollectorRoleBinding) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{24} }

func (m *CollectorRoleBinding) GetRoleBindings() []*RoleBinding {
	if m != nil {
		return m.RoleBindings
	}
	return nil
}

type CollectorClusterRole struct {
	ClusterName  string         `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId    string         `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId      int32          `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize    int32          `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	ClusterRoles []*ClusterRole `protobuf:"bytes,5,rep,name=clusterRoles" json:"clusterRoles,omitempty"`
	Tags         []string       `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorClusterRole) Reset()                    { *m = CollectorClusterRole{} }
func (m *CollectorClusterRole) String() string            { return proto.CompactTextString(m) }
func (*CollectorClusterRole) ProtoMessage()               {}
func (*CollectorClusterRole) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{25} }

func (m *CollectorClusterRole) GetClusterRoles() []*ClusterRole {
	if m != nil {
		return m.ClusterRoles
	}
	return nil
}

type CollectorClusterRoleBinding struct {
	ClusterName         string                `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId           string                `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId             int32                 `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize           int32                 `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	ClusterRoleBindings []*ClusterRoleBinding `protobuf:"bytes,5,rep,name=clusterRoleBindings" json:"clusterRoleBindings,omitempty"`
	Tags                []string              `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorClusterRoleBinding) Reset()         { *m = CollectorClusterRoleBinding{} }
func (m *CollectorClusterRoleBinding) String() string { return proto.CompactTextString(m) }
func (*CollectorClusterRoleBinding) ProtoMessage()    {}
func (*CollectorClusterRoleBinding) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{26}
}

func (m *CollectorClusterRoleBinding) GetClusterRoleBindings() []*ClusterRoleBinding {
	if m != nil {
		return m.ClusterRoleBindings
	}
	return nil
}

type CollectorServiceAccount struct {
	ClusterName     string            `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId       string            `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId         int32             `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize       int32             `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	ServiceAccounts []*ServiceAccount `protobuf:"bytes,5,rep,name=serviceAccounts" json:"serviceAccounts,omitempty"`
	Tags            []string          `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorServiceAccount) Reset()                    { *m = CollectorServiceAccount{} }
func (m *CollectorServiceAccount) String() string            { return proto.CompactTextString(m) }
func (*CollectorServiceAccount) ProtoMessage()               {}
func (*CollectorServiceAccount) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{27} }

func (m *CollectorServiceAccount) GetServiceAccounts() []*ServiceAccount {
	if m != nil {
		return m.ServiceAccounts
	}
	return nil
}

type CollectorIngress struct {
	ClusterName string     `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId   string     `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId     int32      `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize   int32      `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	Ingresses   []*Ingress `protobuf:"bytes,5,rep,name=ingresses" json:"ingresses,omitempty"`
	Tags        []string   `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorIngress) Reset()                    { *m = CollectorIngress{} }
func (m *CollectorIngress) String() string            { return proto.CompactTextString(m) }
func (*CollectorIngress) ProtoMessage()               {}
func (*CollectorIngress) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{28} }

func (m *CollectorIngress) GetIngresses() []*Ingress {
	if m != nil {
		return m.Ingresses
	}
	return nil
}

type CollectorVerticalPodAutoscaler struct {
	ClusterName            string                   `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId              string                   `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId                int32                    `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize              int32                    `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	VerticalPodAutoscalers []*VerticalPodAutoscaler `protobuf:"bytes,5,rep,name=verticalPodAutoscalers" json:"verticalPodAutoscalers,omitempty"`
	Tags                   []string                 `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorVerticalPodAutoscaler) Reset()         { *m = CollectorVerticalPodAutoscaler{} }
func (m *CollectorVerticalPodAutoscaler) String() string { return proto.CompactTextString(m) }
func (*CollectorVerticalPodAutoscaler) ProtoMessage()    {}
func (*CollectorVerticalPodAutoscaler) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{29}
}

func (m *CollectorVerticalPodAutoscaler) GetVerticalPodAutoscalers() []*VerticalPodAutoscaler {
	if m != nil {
		return m.VerticalPodAutoscalers
	}
	return nil
}

type CollectorHorizontalPodAutoscaler struct {
	ClusterName              string                     `protobuf:"bytes,1,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ClusterId                string                     `protobuf:"bytes,2,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	GroupId                  int32                      `protobuf:"varint,3,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize                int32                      `protobuf:"varint,4,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	HorizontalPodAutoscalers []*HorizontalPodAutoscaler `protobuf:"bytes,5,rep,name=horizontalPodAutoscalers" json:"horizontalPodAutoscalers,omitempty"`
	Tags                     []string                   `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *CollectorHorizontalPodAutoscaler) Reset()         { *m = CollectorHorizontalPodAutoscaler{} }
func (m *CollectorHorizontalPodAutoscaler) String() string { return proto.CompactTextString(m) }
func (*CollectorHorizontalPodAutoscaler) ProtoMessage()    {}
func (*CollectorHorizontalPodAutoscaler) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{30}
}

func (m *CollectorHorizontalPodAutoscaler) GetHorizontalPodAutoscalers() []*HorizontalPodAutoscaler {
	if m != nil {
		return m.HorizontalPodAutoscalers
	}
	return nil
}

type CollectorStatus struct {
	ActiveClients int32 `protobuf:"varint,1,opt,name=activeClients,proto3" json:"activeClients,omitempty"`
	Interval      int32 `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (m *CollectorStatus) Reset()                    { *m = CollectorStatus{} }
func (m *CollectorStatus) String() string            { return proto.CompactTextString(m) }
func (*CollectorStatus) ProtoMessage()               {}
func (*CollectorStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{31} }

type Process struct {
	Key                    uint32           `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Pid                    int32            `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	NsPid                  int32            `protobuf:"varint,20,opt,name=nsPid,proto3" json:"nsPid,omitempty"`
	Host                   *Host            `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	Command                *Command         `protobuf:"bytes,4,opt,name=command" json:"command,omitempty"`
	User                   *ProcessUser     `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	Memory                 *MemoryStat      `protobuf:"bytes,7,opt,name=memory" json:"memory,omitempty"`
	Cpu                    *CPUStat         `protobuf:"bytes,8,opt,name=cpu" json:"cpu,omitempty"`
	CreateTime             int64            `protobuf:"varint,9,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Container              *Container       `protobuf:"bytes,10,opt,name=container" json:"container,omitempty"`
	OpenFdCount            int32            `protobuf:"varint,11,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	State                  ProcessState     `protobuf:"varint,12,opt,name=state,proto3,enum=datadog.process_agent.ProcessState" json:"state,omitempty"`
	IoStat                 *IOStat          `protobuf:"bytes,13,opt,name=ioStat" json:"ioStat,omitempty"`
	ContainerId            string           `protobuf:"bytes,14,opt,name=containerId,proto3" json:"containerId,omitempty"`
	ContainerKey           uint32           `protobuf:"varint,15,opt,name=containerKey,proto3" json:"containerKey,omitempty"`
	VoluntaryCtxSwitches   uint64           `protobuf:"varint,16,opt,name=voluntaryCtxSwitches,proto3" json:"voluntaryCtxSwitches,omitempty"`
	InvoluntaryCtxSwitches uint64           `protobuf:"varint,17,opt,name=involuntaryCtxSwitches,proto3" json:"involuntaryCtxSwitches,omitempty"`
	ByteKey                []byte           `protobuf:"bytes,18,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	ContainerByteKey       []byte           `protobuf:"bytes,19,opt,name=containerByteKey,proto3" json:"containerByteKey,omitempty"`
	Networks               *ProcessNetworks `protobuf:"bytes,21,opt,name=networks" json:"networks,omitempty"`
}

func (m *Process) Reset()                    { *m = Process{} }
func (m *Process) String() string            { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()               {}
func (*Process) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{32} }

func (m *Process) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Process) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *Process) GetUser() *ProcessUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Process) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *Process) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *Process) GetContainer() *Container {
	if m != nil {
		return m.Container
	}
	return nil
}

func (m *Process) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

func (m *Process) GetNetworks() *ProcessNetworks {
	if m != nil {
		return m.Networks
	}
	return nil
}

type ProcessDiscovery struct {
	Pid        int32        `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	NsPid      int32        `protobuf:"varint,2,opt,name=nsPid,proto3" json:"nsPid,omitempty"`
	Host       *Host        `protobuf:"bytes,3,opt,name=host" json:"host,omitempty"`
	Command    *Command     `protobuf:"bytes,4,opt,name=command" json:"command,omitempty"`
	User       *ProcessUser `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	CreateTime int64        `protobuf:"varint,6,opt,name=createTime,proto3" json:"createTime,omitempty"`
	ByteKey    []byte       `protobuf:"bytes,7,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
}

func (m *ProcessDiscovery) Reset()                    { *m = ProcessDiscovery{} }
func (m *ProcessDiscovery) String() string            { return proto.CompactTextString(m) }
func (*ProcessDiscovery) ProtoMessage()               {}
func (*ProcessDiscovery) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{33} }

func (m *ProcessDiscovery) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *ProcessDiscovery) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ProcessDiscovery) GetUser() *ProcessUser {
	if m != nil {
		return m.User
	}
	return nil
}

type Command struct {
	Args   []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
	Cwd    string   `protobuf:"bytes,3,opt,name=cwd,proto3" json:"cwd,omitempty"`
	Root   string   `protobuf:"bytes,4,opt,name=root,proto3" json:"root,omitempty"`
	OnDisk bool     `protobuf:"varint,5,opt,name=onDisk,proto3" json:"onDisk,omitempty"`
	Ppid   int32    `protobuf:"varint,6,opt,name=ppid,proto3" json:"ppid,omitempty"`
	Pgroup int32    `protobuf:"varint,7,opt,name=pgroup,proto3" json:"pgroup,omitempty"`
	Exe    string   `protobuf:"bytes,8,opt,name=exe,proto3" json:"exe,omitempty"`
	Comm   string   `protobuf:"bytes,9,opt,name=comm,proto3" json:"comm,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{34} }

type ProcessUser struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uid  int32  `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Gid  int32  `protobuf:"varint,3,opt,name=gid,proto3" json:"gid,omitempty"`
	Euid int32  `protobuf:"varint,4,opt,name=euid,proto3" json:"euid,omitempty"`
	Egid int32  `protobuf:"varint,5,opt,name=egid,proto3" json:"egid,omitempty"`
	Suid int32  `protobuf:"varint,6,opt,name=suid,proto3" json:"suid,omitempty"`
	Sgid int32  `protobuf:"varint,7,opt,name=sgid,proto3" json:"sgid,omitempty"`
}

func (m *ProcessUser) Reset()                    { *m = ProcessUser{} }
func (m *ProcessUser) String() string            { return proto.CompactTextString(m) }
func (*ProcessUser) ProtoMessage()               {}
func (*ProcessUser) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{35} }

// ProcessNetworks is a structure that holds network related metrics for processes
type ProcessNetworks struct {
	ConnectionRate float32 `protobuf:"fixed32,1,opt,name=connectionRate,proto3" json:"connectionRate,omitempty"`
	BytesRate      float32 `protobuf:"fixed32,2,opt,name=bytesRate,proto3" json:"bytesRate,omitempty"`
}

func (m *ProcessNetworks) Reset()                    { *m = ProcessNetworks{} }
func (m *ProcessNetworks) String() string            { return proto.CompactTextString(m) }
func (*ProcessNetworks) ProtoMessage()               {}
func (*ProcessNetworks) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{36} }

// ContainerAddr records the IPs, Ports and Protocols for each container
type ContainerAddr struct {
	Ip       string         `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Port     int32          `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Protocol ConnectionType `protobuf:"varint,3,opt,name=protocol,proto3,enum=datadog.process_agent.ConnectionType" json:"protocol,omitempty"`
}

func (m *ContainerAddr) Reset()                    { *m = ContainerAddr{} }
func (m *ContainerAddr) String() string            { return proto.CompactTextString(m) }
func (*ContainerAddr) ProtoMessage()               {}
func (*ContainerAddr) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{37} }

type Container struct {
	Type         string           `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Id           string           `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Name         string           `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Image        string           `protobuf:"bytes,4,opt,name=image,proto3" json:"image,omitempty"`
	CpuLimit     float32          `protobuf:"fixed32,5,opt,name=cpuLimit,proto3" json:"cpuLimit,omitempty"`
	MemoryLimit  uint64           `protobuf:"varint,6,opt,name=memoryLimit,proto3" json:"memoryLimit,omitempty"`
	State        ContainerState   `protobuf:"varint,8,opt,name=state,proto3,enum=datadog.process_agent.ContainerState" json:"state,omitempty"`
	Health       ContainerHealth  `protobuf:"varint,9,opt,name=health,proto3,enum=datadog.process_agent.ContainerHealth" json:"health,omitempty"`
	Created      int64            `protobuf:"varint,10,opt,name=created,proto3" json:"created,omitempty"`
	Rbps         float32          `protobuf:"fixed32,11,opt,name=rbps,proto3" json:"rbps,omitempty"`
	Wbps         float32          `protobuf:"fixed32,12,opt,name=wbps,proto3" json:"wbps,omitempty"`
	Key          uint32           `protobuf:"varint,13,opt,name=key,proto3" json:"key,omitempty"`
	NetRcvdPs    float32          `protobuf:"fixed32,14,opt,name=netRcvdPs,proto3" json:"netRcvdPs,omitempty"`
	NetSentPs    float32          `protobuf:"fixed32,15,opt,name=netSentPs,proto3" json:"netSentPs,omitempty"`
	NetRcvdBps   float32          `protobuf:"fixed32,16,opt,name=netRcvdBps,proto3" json:"netRcvdBps,omitempty"`
	NetSentBps   float32          `protobuf:"fixed32,17,opt,name=netSentBps,proto3" json:"netSentBps,omitempty"`
	UserPct      float32          `protobuf:"fixed32,18,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct    float32          `protobuf:"fixed32,19,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	TotalPct     float32          `protobuf:"fixed32,20,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	MemRss       uint64           `protobuf:"varint,21,opt,name=memRss,proto3" json:"memRss,omitempty"`
	MemCache     uint64           `protobuf:"varint,22,opt,name=memCache,proto3" json:"memCache,omitempty"`
	Host         *Host            `protobuf:"bytes,23,opt,name=host" json:"host,omitempty"`
	Started      int64            `protobuf:"varint,24,opt,name=started,proto3" json:"started,omitempty"`
	ByteKey      []byte           `protobuf:"bytes,25,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	Tags         []string         `protobuf:"bytes,26,rep,name=tags" json:"tags,omitempty"`
	Addresses    []*ContainerAddr `protobuf:"bytes,27,rep,name=addresses" json:"addresses,omitempty"`
	ThreadCount  uint64           `protobuf:"varint,28,opt,name=threadCount,proto3" json:"threadCount,omitempty"`
	ThreadLimit  uint64           `protobuf:"varint,29,opt,name=threadLimit,proto3" json:"threadLimit,omitempty"`
	MemUsage     uint64           `protobuf:"varint,30,opt,name=memUsage,proto3" json:"memUsage,omitempty"`
	CpuUsageNs   float32          `protobuf:"fixed32,31,opt,name=cpuUsageNs,proto3" json:"cpuUsageNs,omitempty"`
	MemAccounted uint64           `protobuf:"varint,32,opt,name=memAccounted,proto3" json:"memAccounted,omitempty"`
}

func (m *Container) Reset()                    { *m = Container{} }
func (m *Container) String() string            { return proto.CompactTextString(m) }
func (*Container) ProtoMessage()               {}
func (*Container) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{38} }

func (m *Container) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Container) GetAddresses() []*ContainerAddr {
	if m != nil {
		return m.Addresses
	}
	return nil
}

// ProcessStat is used for real-time process messages. It should only contain
// data that can change for a running process (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small.
type ProcessStat struct {
	Pid int32 `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	// In milliseconds
	CreateTime  int64       `protobuf:"varint,2,opt,name=createTime,proto3" json:"createTime,omitempty"`
	Memory      *MemoryStat `protobuf:"bytes,3,opt,name=memory" json:"memory,omitempty"`
	Cpu         *CPUStat    `protobuf:"bytes,4,opt,name=cpu" json:"cpu,omitempty"`
	Nice        int32       `protobuf:"varint,5,opt,name=nice,proto3" json:"nice,omitempty"`
	Threads     int32       `protobuf:"varint,7,opt,name=threads,proto3" json:"threads,omitempty"`
	OpenFdCount int32       `protobuf:"varint,8,opt,name=openFdCount,proto3" json:"openFdCount,omitempty"`
	Key         uint32      `protobuf:"varint,9,opt,name=key,proto3" json:"key,omitempty"`
	// we need container id because we need to do the scoring by container
	ContainerId    string           `protobuf:"bytes,10,opt,name=containerId,proto3" json:"containerId,omitempty"`
	ContainerState ContainerState   `protobuf:"varint,11,opt,name=containerState,proto3,enum=datadog.process_agent.ContainerState" json:"containerState,omitempty"`
	ProcessState   ProcessState     `protobuf:"varint,12,opt,name=processState,proto3,enum=datadog.process_agent.ProcessState" json:"processState,omitempty"`
	IoStat         *IOStat          `protobuf:"bytes,19,opt,name=ioStat" json:"ioStat,omitempty"`
	Networks       *ProcessNetworks `protobuf:"bytes,28,opt,name=networks" json:"networks,omitempty"`
	// DEPRECATED: All container-level stats (except ID) have moved into ContainerStat.
	// These will be removed in the future.
	// These stats are from the container level but are stored per-process
	// because we don't send a container primitive yet.
	ContainerHealth        ContainerHealth `protobuf:"varint,15,opt,name=containerHealth,proto3,enum=datadog.process_agent.ContainerHealth" json:"containerHealth,omitempty"`
	ContainerRbps          float32         `protobuf:"fixed32,16,opt,name=containerRbps,proto3" json:"containerRbps,omitempty"`
	ContainerWbps          float32         `protobuf:"fixed32,17,opt,name=containerWbps,proto3" json:"containerWbps,omitempty"`
	ContainerKey           uint32          `protobuf:"varint,18,opt,name=containerKey,proto3" json:"containerKey,omitempty"`
	ContainerNetRcvdPs     float32         `protobuf:"fixed32,20,opt,name=containerNetRcvdPs,proto3" json:"containerNetRcvdPs,omitempty"`
	ContainerNetSentPs     float32         `protobuf:"fixed32,21,opt,name=containerNetSentPs,proto3" json:"containerNetSentPs,omitempty"`
	ContainerNetRcvdBps    float32         `protobuf:"fixed32,22,opt,name=containerNetRcvdBps,proto3" json:"containerNetRcvdBps,omitempty"`
	ContainerNetSentBps    float32         `protobuf:"fixed32,23,opt,name=containerNetSentBps,proto3" json:"containerNetSentBps,omitempty"`
	VoluntaryCtxSwitches   uint64          `protobuf:"varint,24,opt,name=voluntaryCtxSwitches,proto3" json:"voluntaryCtxSwitches,omitempty"`
	InvoluntaryCtxSwitches uint64          `protobuf:"varint,25,opt,name=involuntaryCtxSwitches,proto3" json:"involuntaryCtxSwitches,omitempty"`
	ByteKey                []byte          `protobuf:"bytes,26,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	ContainerByteKey       []byte          `protobuf:"bytes,27,opt,name=containerByteKey,proto3" json:"containerByteKey,omitempty"`
}

func (m *ProcessStat) Reset()                    { *m = ProcessStat{} }
func (m *ProcessStat) String() string            { return proto.CompactTextString(m) }
func (*ProcessStat) ProtoMessage()               {}
func (*ProcessStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{39} }

func (m *ProcessStat) GetMemory() *MemoryStat {
	if m != nil {
		return m.Memory
	}
	return nil
}

func (m *ProcessStat) GetCpu() *CPUStat {
	if m != nil {
		return m.Cpu
	}
	return nil
}

func (m *ProcessStat) GetIoStat() *IOStat {
	if m != nil {
		return m.IoStat
	}
	return nil
}

func (m *ProcessStat) GetNetworks() *ProcessNetworks {
	if m != nil {
		return m.Networks
	}
	return nil
}

// ProcStatsWithPerm is holding attributes for processes that requires extra permission to collect.
// It is used to pass data between system-probe and process-agent
type ProcStatsWithPerm struct {
	OpenFDCount int32 `protobuf:"varint,1,opt,name=openFDCount,proto3" json:"openFDCount,omitempty"`
	ReadCount   int64 `protobuf:"varint,2,opt,name=readCount,proto3" json:"readCount,omitempty"`
	WriteCount  int64 `protobuf:"varint,3,opt,name=writeCount,proto3" json:"writeCount,omitempty"`
	ReadBytes   int64 `protobuf:"varint,4,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	WriteBytes  int64 `protobuf:"varint,5,opt,name=writeBytes,proto3" json:"writeBytes,omitempty"`
}

func (m *ProcStatsWithPerm) Reset()                    { *m = ProcStatsWithPerm{} }
func (m *ProcStatsWithPerm) String() string            { return proto.CompactTextString(m) }
func (*ProcStatsWithPerm) ProtoMessage()               {}
func (*ProcStatsWithPerm) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{40} }

// ProcStatsWithPermByPID stores ProcStatsWithPerm in a map with key as PIDs
type ProcStatsWithPermByPID struct {
	StatsByPID map[int32]*ProcStatsWithPerm `protobuf:"bytes,1,rep,name=statsByPID" json:"statsByPID,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ProcStatsWithPermByPID) Reset()                    { *m = ProcStatsWithPermByPID{} }
func (m *ProcStatsWithPermByPID) String() string            { return proto.CompactTextString(m) }
func (*ProcStatsWithPermByPID) ProtoMessage()               {}
func (*ProcStatsWithPermByPID) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{41} }

func (m *ProcStatsWithPermByPID) GetStatsByPID() map[int32]*ProcStatsWithPerm {
	if m != nil {
		return m.StatsByPID
	}
	return nil
}

// ContainerStat is used for real-time container messages. It should only contain
// data that can change for a running container (and relevant information to
// generate a key). We will send a lot of these in the real-time messages so
// it's critical to keep this small (basically no strings except ID)
type ContainerStat struct {
	Id         string          `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	UserPct    float32         `protobuf:"fixed32,2,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32         `protobuf:"fixed32,3,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	TotalPct   float32         `protobuf:"fixed32,4,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	CpuLimit   float32         `protobuf:"fixed32,5,opt,name=cpuLimit,proto3" json:"cpuLimit,omitempty"`
	MemRss     uint64          `protobuf:"varint,6,opt,name=memRss,proto3" json:"memRss,omitempty"`
	MemCache   uint64          `protobuf:"varint,7,opt,name=memCache,proto3" json:"memCache,omitempty"`
	MemLimit   uint64          `protobuf:"varint,8,opt,name=memLimit,proto3" json:"memLimit,omitempty"`
	Rbps       float32         `protobuf:"fixed32,9,opt,name=rbps,proto3" json:"rbps,omitempty"`
	Wbps       float32         `protobuf:"fixed32,10,opt,name=wbps,proto3" json:"wbps,omitempty"`
	NetRcvdPs  float32         `protobuf:"fixed32,11,opt,name=netRcvdPs,proto3" json:"netRcvdPs,omitempty"`
	NetSentPs  float32         `protobuf:"fixed32,12,opt,name=netSentPs,proto3" json:"netSentPs,omitempty"`
	NetRcvdBps float32         `protobuf:"fixed32,13,opt,name=netRcvdBps,proto3" json:"netRcvdBps,omitempty"`
	NetSentBps float32         `protobuf:"fixed32,14,opt,name=netSentBps,proto3" json:"netSentBps,omitempty"`
	State      ContainerState  `protobuf:"varint,15,opt,name=state,proto3,enum=datadog.process_agent.ContainerState" json:"state,omitempty"`
	Health     ContainerHealth `protobuf:"varint,16,opt,name=health,proto3,enum=datadog.process_agent.ContainerHealth" json:"health,omitempty"`
	// Post-resolved fields
	Key          uint32  `protobuf:"varint,17,opt,name=key,proto3" json:"key,omitempty"`
	Started      int64   `protobuf:"varint,18,opt,name=started,proto3" json:"started,omitempty"`
	ByteKey      []byte  `protobuf:"bytes,19,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	ThreadCount  uint64  `protobuf:"varint,20,opt,name=threadCount,proto3" json:"threadCount,omitempty"`
	ThreadLimit  uint64  `protobuf:"varint,21,opt,name=threadLimit,proto3" json:"threadLimit,omitempty"`
	MemUsage     uint64  `protobuf:"varint,22,opt,name=memUsage,proto3" json:"memUsage,omitempty"`
	CpuUsageNs   float32 `protobuf:"fixed32,23,opt,name=cpuUsageNs,proto3" json:"cpuUsageNs,omitempty"`
	MemAccounted uint64  `protobuf:"varint,24,opt,name=memAccounted,proto3" json:"memAccounted,omitempty"`
}

func (m *ContainerStat) Reset()                    { *m = ContainerStat{} }
func (m *ContainerStat) String() string            { return proto.CompactTextString(m) }
func (*ContainerStat) ProtoMessage()               {}
func (*ContainerStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{42} }

type SystemInfo struct {
	Uuid        string     `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Os          *OSInfo    `protobuf:"bytes,2,opt,name=os" json:"os,omitempty"`
	Cpus        []*CPUInfo `protobuf:"bytes,3,rep,name=cpus" json:"cpus,omitempty"`
	TotalMemory int64      `protobuf:"varint,5,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
}

func (m *SystemInfo) Reset()                    { *m = SystemInfo{} }
func (m *SystemInfo) String() string            { return proto.CompactTextString(m) }
func (*SystemInfo) ProtoMessage()               {}
func (*SystemInfo) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{43} }

func (m *SystemInfo) GetOs() *OSInfo {
	if m != nil {
		return m.Os
	}
	return nil
}

func (m *SystemInfo) GetCpus() []*CPUInfo {
	if m != nil {
		return m.Cpus
	}
	return nil
}

type OSInfo struct {
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Platform      string `protobuf:"bytes,2,opt,name=platform,proto3" json:"platform,omitempty"`
	Family        string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Version       string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	KernelVersion string `protobuf:"bytes,5,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
}

func (m *OSInfo) Reset()                    { *m = OSInfo{} }
func (m *OSInfo) String() string            { return proto.CompactTextString(m) }
func (*OSInfo) ProtoMessage()               {}
func (*OSInfo) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{44} }

type IOStat struct {
	ReadRate       float32 `protobuf:"fixed32,1,opt,name=readRate,proto3" json:"readRate,omitempty"`
	WriteRate      float32 `protobuf:"fixed32,2,opt,name=writeRate,proto3" json:"writeRate,omitempty"`
	ReadBytesRate  float32 `protobuf:"fixed32,3,opt,name=readBytesRate,proto3" json:"readBytesRate,omitempty"`
	WriteBytesRate float32 `protobuf:"fixed32,4,opt,name=writeBytesRate,proto3" json:"writeBytesRate,omitempty"`
}

func (m *IOStat) Reset()                    { *m = IOStat{} }
func (m *IOStat) String() string            { return proto.CompactTextString(m) }
func (*IOStat) ProtoMessage()               {}
func (*IOStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{45} }

type MemoryStat struct {
	Rss    uint64 `protobuf:"varint,1,opt,name=rss,proto3" json:"rss,omitempty"`
	Vms    uint64 `protobuf:"varint,2,opt,name=vms,proto3" json:"vms,omitempty"`
	Swap   uint64 `protobuf:"varint,3,opt,name=swap,proto3" json:"swap,omitempty"`
	Shared uint64 `protobuf:"varint,4,opt,name=shared,proto3" json:"shared,omitempty"`
	Text   uint64 `protobuf:"varint,5,opt,name=text,proto3" json:"text,omitempty"`
	Lib    uint64 `protobuf:"varint,6,opt,name=lib,proto3" json:"lib,omitempty"`
	Data   uint64 `protobuf:"varint,7,opt,name=data,proto3" json:"data,omitempty"`
	Dirty  uint64 `protobuf:"varint,8,opt,name=dirty,proto3" json:"dirty,omitempty"`
}

func (m *MemoryStat) Reset()                    { *m = MemoryStat{} }
func (m *MemoryStat) String() string            { return proto.CompactTextString(m) }
func (*MemoryStat) ProtoMessage()               {}
func (*MemoryStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{46} }

type CPUStat struct {
	LastCpu    string           `protobuf:"bytes,1,opt,name=lastCpu,proto3" json:"lastCpu,omitempty"`
	TotalPct   float32          `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
	UserPct    float32          `protobuf:"fixed32,3,opt,name=userPct,proto3" json:"userPct,omitempty"`
	SystemPct  float32          `protobuf:"fixed32,4,opt,name=systemPct,proto3" json:"systemPct,omitempty"`
	NumThreads int32            `protobuf:"varint,5,opt,name=numThreads,proto3" json:"numThreads,omitempty"`
	Cpus       []*SingleCPUStat `protobuf:"bytes,6,rep,name=cpus" json:"cpus,omitempty"`
	Nice       int32            `protobuf:"varint,7,opt,name=nice,proto3" json:"nice,omitempty"`
	UserTime   int64            `protobuf:"varint,8,opt,name=userTime,proto3" json:"userTime,omitempty"`
	SystemTime int64            `protobuf:"varint,9,opt,name=systemTime,proto3" json:"systemTime,omitempty"`
}

func (m *CPUStat) Reset()                    { *m = CPUStat{} }
func (m *CPUStat) String() string            { return proto.CompactTextString(m) }
func (*CPUStat) ProtoMessage()               {}
func (*CPUStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{47} }

func (m *CPUStat) GetCpus() []*SingleCPUStat {
	if m != nil {
		return m.Cpus
	}
	return nil
}

type SingleCPUStat struct {
	Name     string  `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	TotalPct float32 `protobuf:"fixed32,2,opt,name=totalPct,proto3" json:"totalPct,omitempty"`
}

func (m *SingleCPUStat) Reset()                    { *m = SingleCPUStat{} }
func (m *SingleCPUStat) String() string            { return proto.CompactTextString(m) }
func (*SingleCPUStat) ProtoMessage()               {}
func (*SingleCPUStat) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{48} }

type CPUInfo struct {
	Number     int32  `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	Vendor     string `protobuf:"bytes,2,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Family     string `protobuf:"bytes,3,opt,name=family,proto3" json:"family,omitempty"`
	Model      string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	PhysicalId string `protobuf:"bytes,5,opt,name=physicalId,proto3" json:"physicalId,omitempty"`
	CoreId     string `protobuf:"bytes,6,opt,name=coreId,proto3" json:"coreId,omitempty"`
	Cores      int32  `protobuf:"varint,7,opt,name=cores,proto3" json:"cores,omitempty"`
	Mhz        int64  `protobuf:"varint,8,opt,name=mhz,proto3" json:"mhz,omitempty"`
	CacheSize  int32  `protobuf:"varint,9,opt,name=cacheSize,proto3" json:"cacheSize,omitempty"`
}

func (m *CPUInfo) Reset()                    { *m = CPUInfo{} }
func (m *CPUInfo) String() string            { return proto.CompactTextString(m) }
func (*CPUInfo) ProtoMessage()               {}
func (*CPUInfo) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{49} }

type Host struct {
	Id           int64    `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	OrgId        int32    `protobuf:"varint,2,opt,name=orgId,proto3" json:"orgId,omitempty"`
	Name         string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	AllTags      []string `protobuf:"bytes,6,rep,name=allTags" json:"allTags,omitempty"`
	NumCpus      int32    `protobuf:"varint,7,opt,name=numCpus,proto3" json:"numCpus,omitempty"`
	TotalMemory  int64    `protobuf:"varint,8,opt,name=totalMemory,proto3" json:"totalMemory,omitempty"`
	TagIndex     int32    `protobuf:"varint,9,opt,name=tagIndex,proto3" json:"tagIndex,omitempty"`
	TagsModified int64    `protobuf:"varint,10,opt,name=tagsModified,proto3" json:"tagsModified,omitempty"`
}

func (m *Host) Reset()                    { *m = Host{} }
func (m *Host) String() string            { return proto.CompactTextString(m) }
func (*Host) ProtoMessage()               {}
func (*Host) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{50} }

type Cluster struct {
	NodeCount         int32            `protobuf:"varint,1,opt,name=nodeCount,proto3" json:"nodeCount,omitempty"`
	KubeletVersions   map[string]int32 `protobuf:"bytes,2,rep,name=kubeletVersions" json:"kubeletVersions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	ApiServerVersions map[string]int32 `protobuf:"bytes,3,rep,name=apiServerVersions" json:"apiServerVersions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// sum of all nodes capacities and allocatables.
	// Using smallest possible quantity levels.
	// For memory it is bytes, for CPU it is millicore.
	PodCapacity       uint32           `protobuf:"varint,4,opt,name=podCapacity,proto3" json:"podCapacity,omitempty"`
	PodAllocatable    uint32           `protobuf:"varint,5,opt,name=podAllocatable,proto3" json:"podAllocatable,omitempty"`
	MemoryAllocatable uint64           `protobuf:"varint,6,opt,name=memoryAllocatable,proto3" json:"memoryAllocatable,omitempty"`
	MemoryCapacity    uint64           `protobuf:"varint,7,opt,name=memoryCapacity,proto3" json:"memoryCapacity,omitempty"`
	CpuAllocatable    uint64           `protobuf:"varint,8,opt,name=cpuAllocatable,proto3" json:"cpuAllocatable,omitempty"`
	CpuCapacity       uint64           `protobuf:"varint,9,opt,name=cpuCapacity,proto3" json:"cpuCapacity,omitempty"`
	ResourceVersion   string           `protobuf:"bytes,10,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	CreationTimestamp int64            `protobuf:"varint,11,opt,name=creationTimestamp,proto3" json:"creationTimestamp,omitempty"`
	Tags              []string         `protobuf:"bytes,12,rep,name=tags" json:"tags,omitempty"`
	Metrics           *ResourceMetrics `protobuf:"bytes,13,opt,name=metrics" json:"metrics,omitempty"`
}

func (m *Cluster) Reset()                    { *m = Cluster{} }
func (m *Cluster) String() string            { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()               {}
func (*Cluster) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{51} }

func (m *Cluster) GetKubeletVersions() map[string]int32 {
	if m != nil {
		return m.KubeletVersions
	}
	return nil
}

func (m *Cluster) GetApiServerVersions() map[string]int32 {
	if m != nil {
		return m.ApiServerVersions
	}
	return nil
}

func (m *Cluster) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// reference https://github.com/kubernetes/apimachinery/blob/2373d029717c4d169463414a6127cd1d0d12680e/pkg/apis/meta/v1/generated.proto#L521
type Metadata struct {
	Name              string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Namespace         string            `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Uid               string            `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	CreationTimestamp int64             `protobuf:"varint,4,opt,name=creationTimestamp,proto3" json:"creationTimestamp,omitempty"`
	DeletionTimestamp int64             `protobuf:"varint,5,opt,name=deletionTimestamp,proto3" json:"deletionTimestamp,omitempty"`
	Labels            []string          `protobuf:"bytes,6,rep,name=labels" json:"labels,omitempty"`
	Annotations       []string          `protobuf:"bytes,7,rep,name=annotations" json:"annotations,omitempty"`
	OwnerReferences   []*OwnerReference `protobuf:"bytes,8,rep,name=ownerReferences" json:"ownerReferences,omitempty"`
	ResourceVersion   string            `protobuf:"bytes,9,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	Finalizers        []string          `protobuf:"bytes,10,rep,name=finalizers" json:"finalizers,omitempty"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{52} }

func (m *Metadata) GetOwnerReferences() []*OwnerReference {
	if m != nil {
		return m.OwnerReferences
	}
	return nil
}

type OwnerReference struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Uid  string `protobuf:"bytes,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *OwnerReference) Reset()                    { *m = OwnerReference{} }
func (m *OwnerReference) String() string            { return proto.CompactTextString(m) }
func (*OwnerReference) ProtoMessage()               {}
func (*OwnerReference) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{53} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/pkg/apis/core/types.go#L4317
type ObjectReference struct {
	Kind            string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Namespace       string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Name            string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Uid             string `protobuf:"bytes,4,opt,name=uid,proto3" json:"uid,omitempty"`
	ApiVersion      string `protobuf:"bytes,5,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
	ResourceVersion string `protobuf:"bytes,6,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	FieldPath       string `protobuf:"bytes,7,opt,name=fieldPath,proto3" json:"fieldPath,omitempty"`
}

func (m *ObjectReference) Reset()                    { *m = ObjectReference{} }
func (m *ObjectReference) String() string            { return proto.CompactTextString(m) }
func (*ObjectReference) ProtoMessage()               {}
func (*ObjectReference) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{54} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L4571
type ServicePort struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Protocol   string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Port       int32  `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	TargetPort string `protobuf:"bytes,4,opt,name=targetPort,proto3" json:"targetPort,omitempty"`
	NodePort   int32  `protobuf:"varint,5,opt,name=nodePort,proto3" json:"nodePort,omitempty"`
}

func (m *ServicePort) Reset()                    { *m = ServicePort{} }
func (m *ServicePort) String() string            { return proto.CompactTextString(m) }
func (*ServicePort) ProtoMessage()               {}
func (*ServicePort) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{55} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L4756
type ServiceSessionAffinityConfig struct {
	ClientIPTimeoutSeconds int32 `protobuf:"varint,1,opt,name=clientIPTimeoutSeconds,proto3" json:"clientIPTimeoutSeconds,omitempty"`
}

func (m *ServiceSessionAffinityConfig) Reset()         { *m = ServiceSessionAffinityConfig{} }
func (m *ServiceSessionAffinityConfig) String() string { return proto.CompactTextString(m) }
func (*ServiceSessionAffinityConfig) ProtoMessage()    {}
func (*ServiceSessionAffinityConfig) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{56}
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2107
type Node struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// spec reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2312
	PodCIDR       string      `protobuf:"bytes,2,opt,name=podCIDR,proto3" json:"podCIDR,omitempty"`
	PodCIDRs      []string    `protobuf:"bytes,3,rep,name=podCIDRs" json:"podCIDRs,omitempty"`
	Unschedulable bool        `protobuf:"varint,4,opt,name=unschedulable,proto3" json:"unschedulable,omitempty"`
	Taints        []*Taint    `protobuf:"bytes,5,rep,name=taints" json:"taints,omitempty"`
	Status        *NodeStatus `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
	Yaml          []byte      `protobuf:"bytes,7,opt,name=yaml,proto3" json:"yaml,omitempty"`
	// we parse it from the labels. Similar to upstream https://github.com/kubernetes/kubernetes/blob/1e12d92a5179dbfeb455c79dbf9120c8536e5f9c/pkg/printers/internalversion/printers.go#L1487
	Roles      []string         `protobuf:"bytes,8,rep,name=roles" json:"roles,omitempty"`
	Tags       []string         `protobuf:"bytes,9,rep,name=tags" json:"tags,omitempty"`
	ProviderID string           `protobuf:"bytes,10,opt,name=providerID,proto3" json:"providerID,omitempty"`
	Host       *Host            `protobuf:"bytes,11,opt,name=host" json:"host,omitempty"`
	Metrics    *ResourceMetrics `protobuf:"bytes,12,opt,name=metrics" json:"metrics,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{57} }

func (m *Node) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Node) GetTaints() []*Taint {
	if m != nil {
		return m.Taints
	}
	return nil
}

func (m *Node) GetStatus() *NodeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Node) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Node) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2348
type NodeStatus struct {
	// Key/Value of a resource type and a corresponding quantity as an int64.
	Capacity map[string]int64 `protobuf:"bytes,1,rep,name=capacity" json:"capacity,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Key/Value of a resource type and a corresponding quantity as an int64.
	Allocatable map[string]int64 `protobuf:"bytes,2,rep,name=allocatable" json:"allocatable,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2127
	// these are valid types https://github.com/kubernetes/api/blob/master/core/v1/types.go#L4739-L4753
	NodeAddresses map[string]string `protobuf:"bytes,3,rep,name=nodeAddresses" json:"nodeAddresses,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// node status displayed by "kubectl get node"
	// mostly based on NodeCondition
	// and https://github.com/kubernetes/kubernetes/blob/1e12d92a5179dbfeb455c79dbf9120c8536e5f9c/pkg/printers/internalversion/printers.go#L1410
	Status         string            `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	KubeletVersion string            `protobuf:"bytes,5,opt,name=kubeletVersion,proto3" json:"kubeletVersion,omitempty"`
	Conditions     []*NodeCondition  `protobuf:"bytes,6,rep,name=conditions" json:"conditions,omitempty"`
	Images         []*ContainerImage `protobuf:"bytes,7,rep,name=images" json:"images,omitempty"`
	// node system info reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2411
	KubeProxyVersion        string `protobuf:"bytes,8,opt,name=kubeProxyVersion,proto3" json:"kubeProxyVersion,omitempty"`
	OperatingSystem         string `protobuf:"bytes,9,opt,name=operatingSystem,proto3" json:"operatingSystem,omitempty"`
	Architecture            string `protobuf:"bytes,10,opt,name=architecture,proto3" json:"architecture,omitempty"`
	KernelVersion           string `protobuf:"bytes,11,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
	OsImage                 string `protobuf:"bytes,12,opt,name=osImage,proto3" json:"osImage,omitempty"`
	ContainerRuntimeVersion string `protobuf:"bytes,13,opt,name=containerRuntimeVersion,proto3" json:"containerRuntimeVersion,omitempty"`
}

func (m *NodeStatus) Reset()                    { *m = NodeStatus{} }
func (m *NodeStatus) String() string            { return proto.CompactTextString(m) }
func (*NodeStatus) ProtoMessage()               {}
func (*NodeStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{58} }

func (m *NodeStatus) GetCapacity() map[string]int64 {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *NodeStatus) GetAllocatable() map[string]int64 {
	if m != nil {
		return m.Allocatable
	}
	return nil
}

func (m *NodeStatus) GetNodeAddresses() map[string]string {
	if m != nil {
		return m.NodeAddresses
	}
	return nil
}

func (m *NodeStatus) GetConditions() []*NodeCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *NodeStatus) GetImages() []*ContainerImage {
	if m != nil {
		return m.Images
	}
	return nil
}

// reference: https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2158
type NodeCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *NodeCondition) Reset()                    { *m = NodeCondition{} }
func (m *NodeCondition) String() string            { return proto.CompactTextString(m) }
func (*NodeCondition) ProtoMessage()               {}
func (*NodeCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{59} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L777
type ContainerImage struct {
	Names     []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
	SizeBytes int64    `protobuf:"varint,2,opt,name=sizeBytes,proto3" json:"sizeBytes,omitempty"`
}

func (m *ContainerImage) Reset()                    { *m = ContainerImage{} }
func (m *ContainerImage) String() string            { return proto.CompactTextString(m) }
func (*ContainerImage) ProtoMessage()               {}
func (*ContainerImage) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{60} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L4849
type Taint struct {
	Key       string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value     string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Effect    string `protobuf:"bytes,3,opt,name=effect,proto3" json:"effect,omitempty"`
	TimeAdded int64  `protobuf:"varint,4,opt,name=timeAdded,proto3" json:"timeAdded,omitempty"`
}

func (m *Taint) Reset()                    { *m = Taint{} }
func (m *Taint) String() string            { return proto.CompactTextString(m) }
func (*Taint) ProtoMessage()               {}
func (*Taint) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{61} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L4620
type ServiceSpec struct {
	Ports                    []*ServicePort                `protobuf:"bytes,1,rep,name=ports" json:"ports,omitempty"`
	Selectors                []*LabelSelectorRequirement   `protobuf:"bytes,2,rep,name=selectors" json:"selectors,omitempty"`
	ClusterIP                string                        `protobuf:"bytes,3,opt,name=clusterIP,proto3" json:"clusterIP,omitempty"`
	Type                     string                        `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	ExternalIPs              []string                      `protobuf:"bytes,5,rep,name=externalIPs" json:"externalIPs,omitempty"`
	SessionAffinity          string                        `protobuf:"bytes,6,opt,name=sessionAffinity,proto3" json:"sessionAffinity,omitempty"`
	LoadBalancerIP           string                        `protobuf:"bytes,7,opt,name=loadBalancerIP,proto3" json:"loadBalancerIP,omitempty"`
	LoadBalancerSourceRanges []string                      `protobuf:"bytes,8,rep,name=loadBalancerSourceRanges" json:"loadBalancerSourceRanges,omitempty"`
	ExternalName             string                        `protobuf:"bytes,9,opt,name=externalName,proto3" json:"externalName,omitempty"`
	ExternalTrafficPolicy    string                        `protobuf:"bytes,10,opt,name=externalTrafficPolicy,proto3" json:"externalTrafficPolicy,omitempty"`
	HealthCheckNodePort      int32                         `protobuf:"varint,11,opt,name=healthCheckNodePort,proto3" json:"healthCheckNodePort,omitempty"`
	PublishNotReadyAddresses bool                          `protobuf:"varint,12,opt,name=publishNotReadyAddresses,proto3" json:"publishNotReadyAddresses,omitempty"`
	SessionAffinityConfig    *ServiceSessionAffinityConfig `protobuf:"bytes,13,opt,name=sessionAffinityConfig" json:"sessionAffinityConfig,omitempty"`
	IpFamily                 string                        `protobuf:"bytes,14,opt,name=ipFamily,proto3" json:"ipFamily,omitempty"`
}

func (m *ServiceSpec) Reset()                    { *m = ServiceSpec{} }
func (m *ServiceSpec) String() string            { return proto.CompactTextString(m) }
func (*ServiceSpec) ProtoMessage()               {}
func (*ServiceSpec) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{62} }

func (m *ServiceSpec) GetPorts() []*ServicePort {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *ServiceSpec) GetSelectors() []*LabelSelectorRequirement {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *ServiceSpec) GetSessionAffinityConfig() *ServiceSessionAffinityConfig {
	if m != nil {
		return m.SessionAffinityConfig
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L4748
type ServiceStatus struct {
	LoadBalancerIngress []string `protobuf:"bytes,17,rep,name=loadBalancerIngress" json:"loadBalancerIngress,omitempty"`
}

func (m *ServiceStatus) Reset()                    { *m = ServiceStatus{} }
func (m *ServiceStatus) String() string            { return proto.CompactTextString(m) }
func (*ServiceStatus) ProtoMessage()               {}
func (*ServiceStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{63} }

// reference https://github.com/kubernetes/kubernetes/blob/release-1.19/staging/src/k8s.io/api/core/v1/generated.proto
type Service struct {
	Metadata *Metadata        `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec     *ServiceSpec     `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status   *ServiceStatus   `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml     []byte           `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string         `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Metrics  *ResourceMetrics `protobuf:"bytes,6,opt,name=metrics" json:"metrics,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{64} }

func (m *Service) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Service) GetSpec() *ServiceSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Service) GetStatus() *ServiceStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Service) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L236
type DeploymentCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastUpdateTime     int64  `protobuf:"varint,6,opt,name=lastUpdateTime,proto3" json:"lastUpdateTime,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,7,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *DeploymentCondition) Reset()                    { *m = DeploymentCondition{} }
func (m *DeploymentCondition) String() string            { return proto.CompactTextString(m) }
func (*DeploymentCondition) ProtoMessage()               {}
func (*DeploymentCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{65} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L221
type Deployment struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// spec
	ReplicasDesired    int32                       `protobuf:"varint,2,opt,name=replicasDesired,proto3" json:"replicasDesired,omitempty"`
	DeploymentStrategy string                      `protobuf:"bytes,3,opt,name=deploymentStrategy,proto3" json:"deploymentStrategy,omitempty"`
	MaxUnavailable     string                      `protobuf:"bytes,4,opt,name=maxUnavailable,proto3" json:"maxUnavailable,omitempty"`
	MaxSurge           string                      `protobuf:"bytes,5,opt,name=maxSurge,proto3" json:"maxSurge,omitempty"`
	Paused             bool                        `protobuf:"varint,6,opt,name=paused,proto3" json:"paused,omitempty"`
	Selectors          []*LabelSelectorRequirement `protobuf:"bytes,7,rep,name=selectors" json:"selectors,omitempty"`
	// status
	Replicas             int32                   `protobuf:"varint,8,opt,name=replicas,proto3" json:"replicas,omitempty"`
	UpdatedReplicas      int32                   `protobuf:"varint,9,opt,name=updatedReplicas,proto3" json:"updatedReplicas,omitempty"`
	ReadyReplicas        int32                   `protobuf:"varint,10,opt,name=readyReplicas,proto3" json:"readyReplicas,omitempty"`
	AvailableReplicas    int32                   `protobuf:"varint,11,opt,name=availableReplicas,proto3" json:"availableReplicas,omitempty"`
	UnavailableReplicas  int32                   `protobuf:"varint,12,opt,name=unavailableReplicas,proto3" json:"unavailableReplicas,omitempty"`
	ConditionMessage     string                  `protobuf:"bytes,13,opt,name=conditionMessage,proto3" json:"conditionMessage,omitempty"`
	ResourceRequirements []*ResourceRequirements `protobuf:"bytes,16,rep,name=resourceRequirements" json:"resourceRequirements,omitempty"`
	Yaml                 []byte                  `protobuf:"bytes,14,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags                 []string                `protobuf:"bytes,15,rep,name=tags" json:"tags,omitempty"`
	Metrics              *ResourceMetrics        `protobuf:"bytes,17,opt,name=metrics" json:"metrics,omitempty"`
	Conditions           []*DeploymentCondition  `protobuf:"bytes,18,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *Deployment) Reset()                    { *m = Deployment{} }
func (m *Deployment) String() string            { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()               {}
func (*Deployment) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{66} }

func (m *Deployment) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Deployment) GetSelectors() []*LabelSelectorRequirement {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *Deployment) GetResourceRequirements() []*ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

func (m *Deployment) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Deployment) GetConditions() []*DeploymentCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L388
type ReplicaSetCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ReplicaSetCondition) Reset()                    { *m = ReplicaSetCondition{} }
func (m *ReplicaSetCondition) String() string            { return proto.CompactTextString(m) }
func (*ReplicaSetCondition) ProtoMessage()               {}
func (*ReplicaSetCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{67} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L366
type ReplicaSet struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// spec
	ReplicasDesired int32                       `protobuf:"varint,2,opt,name=replicasDesired,proto3" json:"replicasDesired,omitempty"`
	Selectors       []*LabelSelectorRequirement `protobuf:"bytes,3,rep,name=selectors" json:"selectors,omitempty"`
	// status
	Replicas             int32                   `protobuf:"varint,4,opt,name=replicas,proto3" json:"replicas,omitempty"`
	FullyLabeledReplicas int32                   `protobuf:"varint,5,opt,name=fullyLabeledReplicas,proto3" json:"fullyLabeledReplicas,omitempty"`
	ReadyReplicas        int32                   `protobuf:"varint,6,opt,name=readyReplicas,proto3" json:"readyReplicas,omitempty"`
	AvailableReplicas    int32                   `protobuf:"varint,7,opt,name=availableReplicas,proto3" json:"availableReplicas,omitempty"`
	ResourceRequirements []*ResourceRequirements `protobuf:"bytes,10,rep,name=resourceRequirements" json:"resourceRequirements,omitempty"`
	Yaml                 []byte                  `protobuf:"bytes,8,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags                 []string                `protobuf:"bytes,9,rep,name=tags" json:"tags,omitempty"`
	Metrics              *ResourceMetrics        `protobuf:"bytes,11,opt,name=metrics" json:"metrics,omitempty"`
	Conditions           []*ReplicaSetCondition  `protobuf:"bytes,12,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *ReplicaSet) Reset()                    { *m = ReplicaSet{} }
func (m *ReplicaSet) String() string            { return proto.CompactTextString(m) }
func (*ReplicaSet) ProtoMessage()               {}
func (*ReplicaSet) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{68} }

func (m *ReplicaSet) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ReplicaSet) GetSelectors() []*LabelSelectorRequirement {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *ReplicaSet) GetResourceRequirements() []*ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

func (m *ReplicaSet) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *ReplicaSet) GetConditions() []*ReplicaSetCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type LabelSelectorRequirement struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator string   `protobuf:"bytes,2,opt,name=operator,proto3" json:"operator,omitempty"`
	Values   []string `protobuf:"bytes,3,rep,name=values" json:"values,omitempty"`
}

func (m *LabelSelectorRequirement) Reset()                    { *m = LabelSelectorRequirement{} }
func (m *LabelSelectorRequirement) String() string            { return proto.CompactTextString(m) }
func (*LabelSelectorRequirement) ProtoMessage()               {}
func (*LabelSelectorRequirement) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{69} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto
type Pod struct {
	Metadata *Metadata `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	// status
	IP                    string                  `protobuf:"bytes,2,opt,name=IP,proto3" json:"IP,omitempty"`
	NominatedNodeName     string                  `protobuf:"bytes,3,opt,name=nominatedNodeName,proto3" json:"nominatedNodeName,omitempty"`
	NodeName              string                  `protobuf:"bytes,4,opt,name=nodeName,proto3" json:"nodeName,omitempty"`
	Phase                 string                  `protobuf:"bytes,5,opt,name=phase,proto3" json:"phase,omitempty"`
	RestartCount          int32                   `protobuf:"varint,6,opt,name=restartCount,proto3" json:"restartCount,omitempty"`
	ContainerStatuses     []*ContainerStatus      `protobuf:"bytes,7,rep,name=containerStatuses" json:"containerStatuses,omitempty"`
	InitContainerStatuses []*ContainerStatus      `protobuf:"bytes,14,rep,name=initContainerStatuses" json:"initContainerStatuses,omitempty"`
	ConditionMessage      string                  `protobuf:"bytes,8,opt,name=conditionMessage,proto3" json:"conditionMessage,omitempty"`
	Status                string                  `protobuf:"bytes,9,opt,name=status,proto3" json:"status,omitempty"`
	Yaml                  []byte                  `protobuf:"bytes,10,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags                  []string                `protobuf:"bytes,11,rep,name=tags" json:"tags,omitempty"`
	Host                  *Host                   `protobuf:"bytes,12,opt,name=host" json:"host,omitempty"`
	ResourceRequirements  []*ResourceRequirements `protobuf:"bytes,13,rep,name=resourceRequirements" json:"resourceRequirements,omitempty"`
	QOSClass              string                  `protobuf:"bytes,15,opt,name=QOSClass,proto3" json:"QOSClass,omitempty"`
	PriorityClass         string                  `protobuf:"bytes,16,opt,name=priorityClass,proto3" json:"priorityClass,omitempty"`
	Metrics               *ResourceMetrics        `protobuf:"bytes,17,opt,name=metrics" json:"metrics,omitempty"`
	StartTime             int64                   `protobuf:"varint,18,opt,name=startTime,proto3" json:"startTime,omitempty"`
	ScheduledTime         int64                   `protobuf:"varint,19,opt,name=scheduledTime,proto3" json:"scheduledTime,omitempty"`
	Conditions            []*PodCondition         `protobuf:"bytes,20,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *Pod) Reset()                    { *m = Pod{} }
func (m *Pod) String() string            { return proto.CompactTextString(m) }
func (*Pod) ProtoMessage()               {}
func (*Pod) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{70} }

func (m *Pod) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Pod) GetContainerStatuses() []*ContainerStatus {
	if m != nil {
		return m.ContainerStatuses
	}
	return nil
}

func (m *Pod) GetInitContainerStatuses() []*ContainerStatus {
	if m != nil {
		return m.InitContainerStatuses
	}
	return nil
}

func (m *Pod) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *Pod) GetResourceRequirements() []*ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

func (m *Pod) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *Pod) GetConditions() []*PodCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type PodCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastProbeTime      int64  `protobuf:"varint,3,opt,name=lastProbeTime,proto3" json:"lastProbeTime,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,4,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PodCondition) Reset()                    { *m = PodCondition{} }
func (m *PodCondition) String() string            { return proto.CompactTextString(m) }
func (*PodCondition) ProtoMessage()               {}
func (*PodCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{71} }

type ContainerStatus struct {
	Name         string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ContainerID  string `protobuf:"bytes,2,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Ready        bool   `protobuf:"varint,3,opt,name=ready,proto3" json:"ready,omitempty"`
	RestartCount int32  `protobuf:"varint,4,opt,name=restartCount,proto3" json:"restartCount,omitempty"`
	State        string `protobuf:"bytes,5,opt,name=state,proto3" json:"state,omitempty"`
	Message      string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *ContainerStatus) Reset()                    { *m = ContainerStatus{} }
func (m *ContainerStatus) String() string            { return proto.CompactTextString(m) }
func (*ContainerStatus) ProtoMessage()               {}
func (*ContainerStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{72} }

type Manifest struct {
	Type            int32  `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	ResourceVersion string `protobuf:"bytes,2,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	Uid             string `protobuf:"bytes,3,opt,name=uid,proto3" json:"uid,omitempty"`
	Content         []byte `protobuf:"bytes,4,opt,name=content,proto3" json:"content,omitempty"`
	ContentType     string `protobuf:"bytes,5,opt,name=contentType,proto3" json:"contentType,omitempty"`
	Version         string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Manifest) Reset()                    { *m = Manifest{} }
func (m *Manifest) String() string            { return proto.CompactTextString(m) }
func (*Manifest) ProtoMessage()               {}
func (*Manifest) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{73} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2054
type NamespaceCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *NamespaceCondition) Reset()                    { *m = NamespaceCondition{} }
func (m *NamespaceCondition) String() string            { return proto.CompactTextString(m) }
func (*NamespaceCondition) ProtoMessage()               {}
func (*NamespaceCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{74} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L2036
type Namespace struct {
	Metadata         *Metadata             `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Status           string                `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	ConditionMessage string                `protobuf:"bytes,3,opt,name=conditionMessage,proto3" json:"conditionMessage,omitempty"`
	Yaml             []byte                `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags             []string              `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Conditions       []*NamespaceCondition `protobuf:"bytes,6,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{75} }

func (m *Namespace) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Namespace) GetConditions() []*NamespaceCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// https://github.com/kubernetes/kubernetes/blob/4112d8db20c5550cc27d30d3cee2723db0f8e1c4/staging/src/k8s.io/api/core/v1/types.go#L2097
// Using smallest possible quantity levels.
// For memory it is bytes, for CPU it is millicore.
type ResourceRequirements struct {
	// Limits describes the maximum amount of compute resources allowed.
	// Key/Value of a resource type and a corresponding quantity as an int64.
	Limits map[string]int64 `protobuf:"bytes,1,rep,name=limits" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Requests describes the minimum amount of compute resources required.
	// Key/Value of a resource type and a corresponding quantity as an int64.
	Requests map[string]int64 `protobuf:"bytes,2,rep,name=requests" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Name describes the name of the holder of the resource requirements (e.g. a container name).
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// ResourceRequirementsType describes the type which uses the ResourceRequirements.
	Type ResourceRequirementsType `protobuf:"varint,4,opt,name=type,proto3,enum=datadog.process_agent.ResourceRequirementsType" json:"type,omitempty"`
}

func (m *ResourceRequirements) Reset()                    { *m = ResourceRequirements{} }
func (m *ResourceRequirements) String() string            { return proto.CompactTextString(m) }
func (*ResourceRequirements) ProtoMessage()               {}
func (*ResourceRequirements) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{76} }

func (m *ResourceRequirements) GetLimits() map[string]int64 {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *ResourceRequirements) GetRequests() map[string]int64 {
	if m != nil {
		return m.Requests
	}
	return nil
}

// ResourceMetrics is used in backend enrichment.
type ResourceMetrics struct {
	MetricValues map[string]float64 `protobuf:"bytes,1,rep,name=metricValues" json:"metricValues,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
}

func (m *ResourceMetrics) Reset()                    { *m = ResourceMetrics{} }
func (m *ResourceMetrics) String() string            { return proto.CompactTextString(m) }
func (*ResourceMetrics) ProtoMessage()               {}
func (*ResourceMetrics) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{77} }

func (m *ResourceMetrics) GetMetricValues() map[string]float64 {
	if m != nil {
		return m.MetricValues
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/batch/v1/types.go#L61
type JobSpec struct {
	Parallelism           int32                       `protobuf:"varint,1,opt,name=parallelism,proto3" json:"parallelism,omitempty"`
	Completions           int32                       `protobuf:"varint,2,opt,name=completions,proto3" json:"completions,omitempty"`
	ActiveDeadlineSeconds int64                       `protobuf:"varint,3,opt,name=activeDeadlineSeconds,proto3" json:"activeDeadlineSeconds,omitempty"`
	BackoffLimit          int32                       `protobuf:"varint,4,opt,name=backoffLimit,proto3" json:"backoffLimit,omitempty"`
	Selectors             []*LabelSelectorRequirement `protobuf:"bytes,5,rep,name=selectors" json:"selectors,omitempty"`
	ManualSelector        bool                        `protobuf:"varint,6,opt,name=manualSelector,proto3" json:"manualSelector,omitempty"`
	ResourceRequirements  []*ResourceRequirements     `protobuf:"bytes,7,rep,name=resourceRequirements" json:"resourceRequirements,omitempty"`
}

func (m *JobSpec) Reset()                    { *m = JobSpec{} }
func (m *JobSpec) String() string            { return proto.CompactTextString(m) }
func (*JobSpec) ProtoMessage()               {}
func (*JobSpec) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{78} }

func (m *JobSpec) GetSelectors() []*LabelSelectorRequirement {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *JobSpec) GetResourceRequirements() []*ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/batch/v1/types.go#L132
type JobStatus struct {
	ConditionMessage string `protobuf:"bytes,1,opt,name=conditionMessage,proto3" json:"conditionMessage,omitempty"`
	StartTime        int64  `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	CompletionTime   int64  `protobuf:"varint,3,opt,name=completionTime,proto3" json:"completionTime,omitempty"`
	Active           int32  `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
	Succeeded        int32  `protobuf:"varint,5,opt,name=succeeded,proto3" json:"succeeded,omitempty"`
	Failed           int32  `protobuf:"varint,6,opt,name=failed,proto3" json:"failed,omitempty"`
}

func (m *JobStatus) Reset()                    { *m = JobStatus{} }
func (m *JobStatus) String() string            { return proto.CompactTextString(m) }
func (*JobStatus) ProtoMessage()               {}
func (*JobStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{79} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/batch/v1/generated.proto#L51
type JobCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastProbeTime      int64  `protobuf:"varint,3,opt,name=lastProbeTime,proto3" json:"lastProbeTime,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,4,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *JobCondition) Reset()                    { *m = JobCondition{} }
func (m *JobCondition) String() string            { return proto.CompactTextString(m) }
func (*JobCondition) ProtoMessage()               {}
func (*JobCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{80} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/batch/v1/types.go#L28
type Job struct {
	Metadata   *Metadata       `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec       *JobSpec        `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status     *JobStatus      `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml       []byte          `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags       []string        `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Conditions []*JobCondition `protobuf:"bytes,6,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{81} }

func (m *Job) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Job) GetSpec() *JobSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Job) GetStatus() *JobStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Job) GetConditions() []*JobCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/batch/v1beta1/types.go#L92
type CronJobSpec struct {
	Schedule                   string                  `protobuf:"bytes,1,opt,name=schedule,proto3" json:"schedule,omitempty"`
	StartingDeadlineSeconds    int64                   `protobuf:"varint,2,opt,name=startingDeadlineSeconds,proto3" json:"startingDeadlineSeconds,omitempty"`
	ConcurrencyPolicy          string                  `protobuf:"bytes,3,opt,name=concurrencyPolicy,proto3" json:"concurrencyPolicy,omitempty"`
	Suspend                    bool                    `protobuf:"varint,4,opt,name=suspend,proto3" json:"suspend,omitempty"`
	SuccessfulJobsHistoryLimit int32                   `protobuf:"varint,5,opt,name=successfulJobsHistoryLimit,proto3" json:"successfulJobsHistoryLimit,omitempty"`
	FailedJobsHistoryLimit     int32                   `protobuf:"varint,6,opt,name=failedJobsHistoryLimit,proto3" json:"failedJobsHistoryLimit,omitempty"`
	ResourceRequirements       []*ResourceRequirements `protobuf:"bytes,7,rep,name=resourceRequirements" json:"resourceRequirements,omitempty"`
}

func (m *CronJobSpec) Reset()                    { *m = CronJobSpec{} }
func (m *CronJobSpec) String() string            { return proto.CompactTextString(m) }
func (*CronJobSpec) ProtoMessage()               {}
func (*CronJobSpec) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{82} }

func (m *CronJobSpec) GetResourceRequirements() []*ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/batch/v1beta1/types.go#L150
type CronJobStatus struct {
	Active           []*ObjectReference `protobuf:"bytes,1,rep,name=active" json:"active,omitempty"`
	LastScheduleTime int64              `protobuf:"varint,2,opt,name=lastScheduleTime,proto3" json:"lastScheduleTime,omitempty"`
}

func (m *CronJobStatus) Reset()                    { *m = CronJobStatus{} }
func (m *CronJobStatus) String() string            { return proto.CompactTextString(m) }
func (*CronJobStatus) ProtoMessage()               {}
func (*CronJobStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{83} }

func (m *CronJobStatus) GetActive() []*ObjectReference {
	if m != nil {
		return m.Active
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/batch/v1beta1/types.go#L58
type CronJob struct {
	Metadata *Metadata      `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec     *CronJobSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status   *CronJobStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml     []byte         `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string       `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
}

func (m *CronJob) Reset()                    { *m = CronJob{} }
func (m *CronJob) String() string            { return proto.CompactTextString(m) }
func (*CronJob) ProtoMessage()               {}
func (*CronJob) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{84} }

func (m *CronJob) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CronJob) GetSpec() *CronJobSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *CronJob) GetStatus() *CronJobStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L119
type DaemonSetSpec struct {
	Selectors            []*LabelSelectorRequirement `protobuf:"bytes,1,rep,name=selectors" json:"selectors,omitempty"`
	DeploymentStrategy   string                      `protobuf:"bytes,2,opt,name=deploymentStrategy,proto3" json:"deploymentStrategy,omitempty"`
	MaxUnavailable       string                      `protobuf:"bytes,3,opt,name=maxUnavailable,proto3" json:"maxUnavailable,omitempty"`
	MinReadySeconds      int32                       `protobuf:"varint,4,opt,name=minReadySeconds,proto3" json:"minReadySeconds,omitempty"`
	RevisionHistoryLimit int32                       `protobuf:"varint,5,opt,name=revisionHistoryLimit,proto3" json:"revisionHistoryLimit,omitempty"`
	ResourceRequirements []*ResourceRequirements     `protobuf:"bytes,6,rep,name=resourceRequirements" json:"resourceRequirements,omitempty"`
}

func (m *DaemonSetSpec) Reset()                    { *m = DaemonSetSpec{} }
func (m *DaemonSetSpec) String() string            { return proto.CompactTextString(m) }
func (*DaemonSetSpec) ProtoMessage()               {}
func (*DaemonSetSpec) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{85} }

func (m *DaemonSetSpec) GetSelectors() []*LabelSelectorRequirement {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *DaemonSetSpec) GetResourceRequirements() []*ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L152
type DaemonSetStatus struct {
	CurrentNumberScheduled int32 `protobuf:"varint,1,opt,name=currentNumberScheduled,proto3" json:"currentNumberScheduled,omitempty"`
	NumberMisscheduled     int32 `protobuf:"varint,2,opt,name=numberMisscheduled,proto3" json:"numberMisscheduled,omitempty"`
	DesiredNumberScheduled int32 `protobuf:"varint,3,opt,name=desiredNumberScheduled,proto3" json:"desiredNumberScheduled,omitempty"`
	NumberReady            int32 `protobuf:"varint,4,opt,name=numberReady,proto3" json:"numberReady,omitempty"`
	UpdatedNumberScheduled int32 `protobuf:"varint,6,opt,name=updatedNumberScheduled,proto3" json:"updatedNumberScheduled,omitempty"`
	NumberAvailable        int32 `protobuf:"varint,7,opt,name=numberAvailable,proto3" json:"numberAvailable,omitempty"`
	NumberUnavailable      int32 `protobuf:"varint,8,opt,name=numberUnavailable,proto3" json:"numberUnavailable,omitempty"`
}

func (m *DaemonSetStatus) Reset()                    { *m = DaemonSetStatus{} }
func (m *DaemonSetStatus) String() string            { return proto.CompactTextString(m) }
func (*DaemonSetStatus) ProtoMessage()               {}
func (*DaemonSetStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{86} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L87
type DaemonSetCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *DaemonSetCondition) Reset()                    { *m = DaemonSetCondition{} }
func (m *DaemonSetCondition) String() string            { return proto.CompactTextString(m) }
func (*DaemonSetCondition) ProtoMessage()               {}
func (*DaemonSetCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{87} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L66
type DaemonSet struct {
	Metadata   *Metadata             `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec       *DaemonSetSpec        `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status     *DaemonSetStatus      `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml       []byte                `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags       []string              `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Metrics    *ResourceMetrics      `protobuf:"bytes,6,opt,name=metrics" json:"metrics,omitempty"`
	Conditions []*DaemonSetCondition `protobuf:"bytes,7,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *DaemonSet) Reset()                    { *m = DaemonSet{} }
func (m *DaemonSet) String() string            { return proto.CompactTextString(m) }
func (*DaemonSet) ProtoMessage()               {}
func (*DaemonSet) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{88} }

func (m *DaemonSet) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *DaemonSet) GetSpec() *DaemonSetSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *DaemonSet) GetStatus() *DaemonSetStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DaemonSet) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *DaemonSet) GetConditions() []*DaemonSetCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L586
type StatefulSetSpec struct {
	DesiredReplicas      int32                       `protobuf:"varint,1,opt,name=desiredReplicas,proto3" json:"desiredReplicas,omitempty"`
	Selectors            []*LabelSelectorRequirement `protobuf:"bytes,2,rep,name=selectors" json:"selectors,omitempty"`
	ServiceName          string                      `protobuf:"bytes,3,opt,name=serviceName,proto3" json:"serviceName,omitempty"`
	PodManagementPolicy  string                      `protobuf:"bytes,4,opt,name=podManagementPolicy,proto3" json:"podManagementPolicy,omitempty"`
	UpdateStrategy       string                      `protobuf:"bytes,5,opt,name=updateStrategy,proto3" json:"updateStrategy,omitempty"`
	Partition            int32                       `protobuf:"varint,6,opt,name=partition,proto3" json:"partition,omitempty"`
	ResourceRequirements []*ResourceRequirements     `protobuf:"bytes,7,rep,name=resourceRequirements" json:"resourceRequirements,omitempty"`
}

func (m *StatefulSetSpec) Reset()                    { *m = StatefulSetSpec{} }
func (m *StatefulSetSpec) String() string            { return proto.CompactTextString(m) }
func (*StatefulSetSpec) ProtoMessage()               {}
func (*StatefulSetSpec) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{89} }

func (m *StatefulSetSpec) GetSelectors() []*LabelSelectorRequirement {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *StatefulSetSpec) GetResourceRequirements() []*ResourceRequirements {
	if m != nil {
		return m.ResourceRequirements
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L647
type StatefulSetStatus struct {
	Replicas        int32 `protobuf:"varint,1,opt,name=replicas,proto3" json:"replicas,omitempty"`
	ReadyReplicas   int32 `protobuf:"varint,2,opt,name=readyReplicas,proto3" json:"readyReplicas,omitempty"`
	CurrentReplicas int32 `protobuf:"varint,3,opt,name=currentReplicas,proto3" json:"currentReplicas,omitempty"`
	UpdatedReplicas int32 `protobuf:"varint,4,opt,name=updatedReplicas,proto3" json:"updatedReplicas,omitempty"`
}

func (m *StatefulSetStatus) Reset()                    { *m = StatefulSetStatus{} }
func (m *StatefulSetStatus) String() string            { return proto.CompactTextString(m) }
func (*StatefulSetStatus) ProtoMessage()               {}
func (*StatefulSetStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{90} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L557
type StatefulSetCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *StatefulSetCondition) Reset()                    { *m = StatefulSetCondition{} }
func (m *StatefulSetCondition) String() string            { return proto.CompactTextString(m) }
func (*StatefulSetCondition) ProtoMessage()               {}
func (*StatefulSetCondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{91} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/apps/v1/generated.proto#L542
type StatefulSet struct {
	Metadata   *Metadata               `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec       *StatefulSetSpec        `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status     *StatefulSetStatus      `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml       []byte                  `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags       []string                `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Metrics    *ResourceMetrics        `protobuf:"bytes,6,opt,name=metrics" json:"metrics,omitempty"`
	Conditions []*StatefulSetCondition `protobuf:"bytes,7,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *StatefulSet) Reset()                    { *m = StatefulSet{} }
func (m *StatefulSet) String() string            { return proto.CompactTextString(m) }
func (*StatefulSet) ProtoMessage()               {}
func (*StatefulSet) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{92} }

func (m *StatefulSet) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *StatefulSet) GetSpec() *StatefulSetSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *StatefulSet) GetStatus() *StatefulSetStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *StatefulSet) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *StatefulSet) GetConditions() []*StatefulSetCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L2576
type PersistentVolume struct {
	Metadata *Metadata               `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec     *PersistentVolumeSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status   *PersistentVolumeStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml     []byte                  `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string                `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
}

func (m *PersistentVolume) Reset()                    { *m = PersistentVolume{} }
func (m *PersistentVolume) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolume) ProtoMessage()               {}
func (*PersistentVolume) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{93} }

func (m *PersistentVolume) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *PersistentVolume) GetSpec() *PersistentVolumeSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PersistentVolume) GetStatus() *PersistentVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L2889
type PersistentVolumeSpec struct {
	// Key/Value of a resource type and a corresponding quantity as an int64.
	Capacity map[string]int64 `protobuf:"bytes,1,rep,name=capacity" json:"capacity,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// in kubernetes these are actually fields in a struct where only one can be set.
	// For now we only set it to a string with the name.
	PersistentVolumeType          string                  `protobuf:"bytes,2,opt,name=persistentVolumeType,proto3" json:"persistentVolumeType,omitempty"`
	AccessModes                   []string                `protobuf:"bytes,3,rep,name=accessModes" json:"accessModes,omitempty"`
	ClaimRef                      *ObjectReference        `protobuf:"bytes,4,opt,name=claimRef" json:"claimRef,omitempty"`
	PersistentVolumeReclaimPolicy string                  `protobuf:"bytes,5,opt,name=persistentVolumeReclaimPolicy,proto3" json:"persistentVolumeReclaimPolicy,omitempty"`
	StorageClassName              string                  `protobuf:"bytes,6,opt,name=storageClassName,proto3" json:"storageClassName,omitempty"`
	MountOptions                  []string                `protobuf:"bytes,7,rep,name=mountOptions" json:"mountOptions,omitempty"`
	VolumeMode                    string                  `protobuf:"bytes,8,opt,name=volumeMode,proto3" json:"volumeMode,omitempty"`
	NodeAffinity                  []*NodeSelectorTerm     `protobuf:"bytes,9,rep,name=nodeAffinity" json:"nodeAffinity,omitempty"`
	PersistentVolumeSource        *PersistentVolumeSource `protobuf:"bytes,10,opt,name=persistentVolumeSource" json:"persistentVolumeSource,omitempty"`
}

func (m *PersistentVolumeSpec) Reset()                    { *m = PersistentVolumeSpec{} }
func (m *PersistentVolumeSpec) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolumeSpec) ProtoMessage()               {}
func (*PersistentVolumeSpec) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{94} }

func (m *PersistentVolumeSpec) GetCapacity() map[string]int64 {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *PersistentVolumeSpec) GetClaimRef() *ObjectReference {
	if m != nil {
		return m.ClaimRef
	}
	return nil
}

func (m *PersistentVolumeSpec) GetNodeAffinity() []*NodeSelectorTerm {
	if m != nil {
		return m.NodeAffinity
	}
	return nil
}

func (m *PersistentVolumeSpec) GetPersistentVolumeSource() *PersistentVolumeSource {
	if m != nil {
		return m.PersistentVolumeSource
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/release-1.27/core/v1/generated.proto#L1722
type PersistentVolumeSource struct {
	GcePersistentDisk    *GCEPersistentDiskVolumeSource    `protobuf:"bytes,1,opt,name=gcePersistentDisk" json:"gcePersistentDisk,omitempty"`
	AwsElasticBlockStore *AWSElasticBlockStoreVolumeSource `protobuf:"bytes,2,opt,name=awsElasticBlockStore" json:"awsElasticBlockStore,omitempty"`
	AzureFile            *AzureFilePersistentVolumeSource  `protobuf:"bytes,3,opt,name=azureFile" json:"azureFile,omitempty"`
	AzureDisk            *AzureDiskVolumeSource            `protobuf:"bytes,4,opt,name=azureDisk" json:"azureDisk,omitempty"`
	Csi                  *CSIVolumeSource                  `protobuf:"bytes,5,opt,name=csi" json:"csi,omitempty"`
}

func (m *PersistentVolumeSource) Reset()                    { *m = PersistentVolumeSource{} }
func (m *PersistentVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolumeSource) ProtoMessage()               {}
func (*PersistentVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{95} }

func (m *PersistentVolumeSource) GetGcePersistentDisk() *GCEPersistentDiskVolumeSource {
	if m != nil {
		return m.GcePersistentDisk
	}
	return nil
}

func (m *PersistentVolumeSource) GetAwsElasticBlockStore() *AWSElasticBlockStoreVolumeSource {
	if m != nil {
		return m.AwsElasticBlockStore
	}
	return nil
}

func (m *PersistentVolumeSource) GetAzureFile() *AzureFilePersistentVolumeSource {
	if m != nil {
		return m.AzureFile
	}
	return nil
}

func (m *PersistentVolumeSource) GetAzureDisk() *AzureDiskVolumeSource {
	if m != nil {
		return m.AzureDisk
	}
	return nil
}

func (m *PersistentVolumeSource) GetCsi() *CSIVolumeSource {
	if m != nil {
		return m.Csi
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L1616
type GCEPersistentDiskVolumeSource struct {
	PdName    string `protobuf:"bytes,1,opt,name=pdName,proto3" json:"pdName,omitempty"`
	FsType    string `protobuf:"bytes,2,opt,name=fsType,proto3" json:"fsType,omitempty"`
	Partition int32  `protobuf:"varint,3,opt,name=partition,proto3" json:"partition,omitempty"`
	ReadOnly  bool   `protobuf:"varint,4,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
}

func (m *GCEPersistentDiskVolumeSource) Reset()         { *m = GCEPersistentDiskVolumeSource{} }
func (m *GCEPersistentDiskVolumeSource) String() string { return proto.CompactTextString(m) }
func (*GCEPersistentDiskVolumeSource) ProtoMessage()    {}
func (*GCEPersistentDiskVolumeSource) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{96}
}

// reference https://github.com/kubernetes/api/blob/release-1.27/core/v1/generated.proto#L39
type AWSElasticBlockStoreVolumeSource struct {
	VolumeID  string `protobuf:"bytes,1,opt,name=volumeID,proto3" json:"volumeID,omitempty"`
	FsType    string `protobuf:"bytes,2,opt,name=fsType,proto3" json:"fsType,omitempty"`
	Partition int32  `protobuf:"varint,3,opt,name=partition,proto3" json:"partition,omitempty"`
	ReadOnly  bool   `protobuf:"varint,4,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
}

func (m *AWSElasticBlockStoreVolumeSource) Reset()         { *m = AWSElasticBlockStoreVolumeSource{} }
func (m *AWSElasticBlockStoreVolumeSource) String() string { return proto.CompactTextString(m) }
func (*AWSElasticBlockStoreVolumeSource) ProtoMessage()    {}
func (*AWSElasticBlockStoreVolumeSource) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{97}
}

// reference https://github.com/kubernetes/api/blob/release-1.27/core/v1/generated.proto#L127
type AzureFilePersistentVolumeSource struct {
	SecretName      string `protobuf:"bytes,1,opt,name=secretName,proto3" json:"secretName,omitempty"`
	ShareName       string `protobuf:"bytes,2,opt,name=shareName,proto3" json:"shareName,omitempty"`
	ReadOnly        bool   `protobuf:"varint,3,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
	SecretNamespace string `protobuf:"bytes,4,opt,name=secretNamespace,proto3" json:"secretNamespace,omitempty"`
}

func (m *AzureFilePersistentVolumeSource) Reset()         { *m = AzureFilePersistentVolumeSource{} }
func (m *AzureFilePersistentVolumeSource) String() string { return proto.CompactTextString(m) }
func (*AzureFilePersistentVolumeSource) ProtoMessage()    {}
func (*AzureFilePersistentVolumeSource) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{98}
}

// reference https://github.com/kubernetes/api/blob/release-1.27/core/v1/generated.proto#L100
type AzureDiskVolumeSource struct {
	DiskName    string `protobuf:"bytes,1,opt,name=diskName,proto3" json:"diskName,omitempty"`
	DiskURI     string `protobuf:"bytes,2,opt,name=diskURI,proto3" json:"diskURI,omitempty"`
	CachingMode string `protobuf:"bytes,3,opt,name=cachingMode,proto3" json:"cachingMode,omitempty"`
	FsType      string `protobuf:"bytes,4,opt,name=fsType,proto3" json:"fsType,omitempty"`
	ReadOnly    bool   `protobuf:"varint,5,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
	Kind        string `protobuf:"bytes,6,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *AzureDiskVolumeSource) Reset()                    { *m = AzureDiskVolumeSource{} }
func (m *AzureDiskVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*AzureDiskVolumeSource) ProtoMessage()               {}
func (*AzureDiskVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{99} }

// reference https://github.com/kubernetes/api/blob/release-1.27/core/v1/generated.proto#L172
type CSIVolumeSource struct {
	Driver                     string            `protobuf:"bytes,1,opt,name=driver,proto3" json:"driver,omitempty"`
	VolumeHandle               string            `protobuf:"bytes,2,opt,name=volumeHandle,proto3" json:"volumeHandle,omitempty"`
	ReadOnly                   bool              `protobuf:"varint,3,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
	FsType                     string            `protobuf:"bytes,4,opt,name=fsType,proto3" json:"fsType,omitempty"`
	VolumeAttributes           map[string]string `protobuf:"bytes,5,rep,name=volumeAttributes" json:"volumeAttributes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ControllerPublishSecretRef *SecretReference  `protobuf:"bytes,6,opt,name=controllerPublishSecretRef" json:"controllerPublishSecretRef,omitempty"`
	NodeStageSecretRef         *SecretReference  `protobuf:"bytes,7,opt,name=nodeStageSecretRef" json:"nodeStageSecretRef,omitempty"`
	NodePublishSecretRef       *SecretReference  `protobuf:"bytes,8,opt,name=nodePublishSecretRef" json:"nodePublishSecretRef,omitempty"`
	ControllerExpandSecretRef  *SecretReference  `protobuf:"bytes,9,opt,name=controllerExpandSecretRef" json:"controllerExpandSecretRef,omitempty"`
	NodeExpandSecretRef        *SecretReference  `protobuf:"bytes,10,opt,name=nodeExpandSecretRef" json:"nodeExpandSecretRef,omitempty"`
}

func (m *CSIVolumeSource) Reset()                    { *m = CSIVolumeSource{} }
func (m *CSIVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*CSIVolumeSource) ProtoMessage()               {}
func (*CSIVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{100} }

func (m *CSIVolumeSource) GetVolumeAttributes() map[string]string {
	if m != nil {
		return m.VolumeAttributes
	}
	return nil
}

func (m *CSIVolumeSource) GetControllerPublishSecretRef() *SecretReference {
	if m != nil {
		return m.ControllerPublishSecretRef
	}
	return nil
}

func (m *CSIVolumeSource) GetNodeStageSecretRef() *SecretReference {
	if m != nil {
		return m.NodeStageSecretRef
	}
	return nil
}

func (m *CSIVolumeSource) GetNodePublishSecretRef() *SecretReference {
	if m != nil {
		return m.NodePublishSecretRef
	}
	return nil
}

func (m *CSIVolumeSource) GetControllerExpandSecretRef() *SecretReference {
	if m != nil {
		return m.ControllerExpandSecretRef
	}
	return nil
}

func (m *CSIVolumeSource) GetNodeExpandSecretRef() *SecretReference {
	if m != nil {
		return m.NodeExpandSecretRef
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L4553
type SecretReference struct {
	Name      string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Namespace string `protobuf:"bytes,2,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *SecretReference) Reset()                    { *m = SecretReference{} }
func (m *SecretReference) String() string            { return proto.CompactTextString(m) }
func (*SecretReference) ProtoMessage()               {}
func (*SecretReference) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{101} }

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L2940
type PersistentVolumeStatus struct {
	Phase   string `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Reason  string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *PersistentVolumeStatus) Reset()                    { *m = PersistentVolumeStatus{} }
func (m *PersistentVolumeStatus) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolumeStatus) ProtoMessage()               {}
func (*PersistentVolumeStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{102} }

type NodeSelectorTerm struct {
	MatchExpressions []*LabelSelectorRequirement `protobuf:"bytes,1,rep,name=matchExpressions" json:"matchExpressions,omitempty"`
	MatchFields      []*LabelSelectorRequirement `protobuf:"bytes,2,rep,name=matchFields" json:"matchFields,omitempty"`
}

func (m *NodeSelectorTerm) Reset()                    { *m = NodeSelectorTerm{} }
func (m *NodeSelectorTerm) String() string            { return proto.CompactTextString(m) }
func (*NodeSelectorTerm) ProtoMessage()               {}
func (*NodeSelectorTerm) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{103} }

func (m *NodeSelectorTerm) GetMatchExpressions() []*LabelSelectorRequirement {
	if m != nil {
		return m.MatchExpressions
	}
	return nil
}

func (m *NodeSelectorTerm) GetMatchFields() []*LabelSelectorRequirement {
	if m != nil {
		return m.MatchFields
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L2597
type PersistentVolumeClaim struct {
	Metadata *Metadata                    `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec     *PersistentVolumeClaimSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status   *PersistentVolumeClaimStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml     []byte                       `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string                     `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
}

func (m *PersistentVolumeClaim) Reset()                    { *m = PersistentVolumeClaim{} }
func (m *PersistentVolumeClaim) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolumeClaim) ProtoMessage()               {}
func (*PersistentVolumeClaim) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{104} }

func (m *PersistentVolumeClaim) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *PersistentVolumeClaim) GetSpec() *PersistentVolumeClaimSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PersistentVolumeClaim) GetStatus() *PersistentVolumeClaimStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L2715
type PersistentVolumeClaimStatus struct {
	Phase       string                            `protobuf:"bytes,1,opt,name=phase,proto3" json:"phase,omitempty"`
	AccessModes []string                          `protobuf:"bytes,2,rep,name=accessModes" json:"accessModes,omitempty"`
	Capacity    map[string]int64                  `protobuf:"bytes,3,rep,name=capacity" json:"capacity,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	Conditions  []*PersistentVolumeClaimCondition `protobuf:"bytes,4,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *PersistentVolumeClaimStatus) Reset()         { *m = PersistentVolumeClaimStatus{} }
func (m *PersistentVolumeClaimStatus) String() string { return proto.CompactTextString(m) }
func (*PersistentVolumeClaimStatus) ProtoMessage()    {}
func (*PersistentVolumeClaimStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{105}
}

func (m *PersistentVolumeClaimStatus) GetCapacity() map[string]int64 {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *PersistentVolumeClaimStatus) GetConditions() []*PersistentVolumeClaimCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L2654
type PersistentVolumeClaimSpec struct {
	AccessModes      []string                    `protobuf:"bytes,1,rep,name=accessModes" json:"accessModes,omitempty"`
	Resources        *ResourceRequirements       `protobuf:"bytes,2,opt,name=resources" json:"resources,omitempty"`
	VolumeName       string                      `protobuf:"bytes,3,opt,name=volumeName,proto3" json:"volumeName,omitempty"`
	Selector         []*LabelSelectorRequirement `protobuf:"bytes,4,rep,name=selector" json:"selector,omitempty"`
	StorageClassName string                      `protobuf:"bytes,5,opt,name=storageClassName,proto3" json:"storageClassName,omitempty"`
	VolumeMode       string                      `protobuf:"bytes,6,opt,name=volumeMode,proto3" json:"volumeMode,omitempty"`
	DataSource       *TypedLocalObjectReference  `protobuf:"bytes,7,opt,name=dataSource" json:"dataSource,omitempty"`
}

func (m *PersistentVolumeClaimSpec) Reset()         { *m = PersistentVolumeClaimSpec{} }
func (m *PersistentVolumeClaimSpec) String() string { return proto.CompactTextString(m) }
func (*PersistentVolumeClaimSpec) ProtoMessage()    {}
func (*PersistentVolumeClaimSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{106}
}

func (m *PersistentVolumeClaimSpec) GetResources() *ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PersistentVolumeClaimSpec) GetSelector() []*LabelSelectorRequirement {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *PersistentVolumeClaimSpec) GetDataSource() *TypedLocalObjectReference {
	if m != nil {
		return m.DataSource
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L5327
type TypedLocalObjectReference struct {
	ApiGroup string `protobuf:"bytes,1,opt,name=apiGroup,proto3" json:"apiGroup,omitempty"`
	Kind     string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *TypedLocalObjectReference) Reset()         { *m = TypedLocalObjectReference{} }
func (m *TypedLocalObjectReference) String() string { return proto.CompactTextString(m) }
func (*TypedLocalObjectReference) ProtoMessage()    {}
func (*TypedLocalObjectReference) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{107}
}

// reference https://github.com/kubernetes/api/blob/4bdcbc60ffeee2c04231f11ff114314c1a93ce65/core/v1/generated.proto#L2616
type PersistentVolumeClaimCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastProbeTime      int64  `protobuf:"varint,3,opt,name=lastProbeTime,proto3" json:"lastProbeTime,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,4,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *PersistentVolumeClaimCondition) Reset()         { *m = PersistentVolumeClaimCondition{} }
func (m *PersistentVolumeClaimCondition) String() string { return proto.CompactTextString(m) }
func (*PersistentVolumeClaimCondition) ProtoMessage()    {}
func (*PersistentVolumeClaimCondition) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{108}
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/rbac/v1/generated.proto#L94
type PolicyRule struct {
	Verbs           []string `protobuf:"bytes,1,rep,name=verbs" json:"verbs,omitempty"`
	ApiGroups       []string `protobuf:"bytes,2,rep,name=apiGroups" json:"apiGroups,omitempty"`
	Resources       []string `protobuf:"bytes,3,rep,name=resources" json:"resources,omitempty"`
	ResourceNames   []string `protobuf:"bytes,4,rep,name=resourceNames" json:"resourceNames,omitempty"`
	NonResourceURLs []string `protobuf:"bytes,5,rep,name=nonResourceURLs" json:"nonResourceURLs,omitempty"`
}

func (m *PolicyRule) Reset()                    { *m = PolicyRule{} }
func (m *PolicyRule) String() string            { return proto.CompactTextString(m) }
func (*PolicyRule) ProtoMessage()               {}
func (*PolicyRule) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{109} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/rbac/v1/generated.proto#L180
type Subject struct {
	Kind      string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	ApiGroup  string `protobuf:"bytes,2,opt,name=apiGroup,proto3" json:"apiGroup,omitempty"`
	Name      string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Namespace string `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
}

func (m *Subject) Reset()                    { *m = Subject{} }
func (m *Subject) String() string            { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()               {}
func (*Subject) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{110} }

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/rbac/v1/generated.proto#L119
type Role struct {
	Metadata *Metadata     `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Rules    []*PolicyRule `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
	Yaml     []byte        `protobuf:"bytes,3,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string      `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *Role) Reset()                    { *m = Role{} }
func (m *Role) String() string            { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()               {}
func (*Role) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{111} }

func (m *Role) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Role) GetRules() []*PolicyRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/rbac/v1/generated.proto#L132
type RoleBinding struct {
	Metadata *Metadata                  `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Subjects []*Subject                 `protobuf:"bytes,2,rep,name=subjects" json:"subjects,omitempty"`
	RoleRef  *TypedLocalObjectReference `protobuf:"bytes,3,opt,name=roleRef" json:"roleRef,omitempty"`
	Yaml     []byte                     `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string                   `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
}

func (m *RoleBinding) Reset()                    { *m = RoleBinding{} }
func (m *RoleBinding) String() string            { return proto.CompactTextString(m) }
func (*RoleBinding) ProtoMessage()               {}
func (*RoleBinding) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{112} }

func (m *RoleBinding) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *RoleBinding) GetSubjects() []*Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *RoleBinding) GetRoleRef() *TypedLocalObjectReference {
	if m != nil {
		return m.RoleRef
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/rbac/v1/generated.proto#L40
type ClusterRole struct {
	Metadata         *Metadata                   `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Rules            []*PolicyRule               `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
	AggregationRules []*LabelSelectorRequirement `protobuf:"bytes,3,rep,name=aggregationRules" json:"aggregationRules,omitempty"`
	Yaml             []byte                      `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags             []string                    `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Metrics          *ResourceMetrics            `protobuf:"bytes,6,opt,name=metrics" json:"metrics,omitempty"`
}

func (m *ClusterRole) Reset()                    { *m = ClusterRole{} }
func (m *ClusterRole) String() string            { return proto.CompactTextString(m) }
func (*ClusterRole) ProtoMessage()               {}
func (*ClusterRole) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{113} }

func (m *ClusterRole) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ClusterRole) GetRules() []*PolicyRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *ClusterRole) GetAggregationRules() []*LabelSelectorRequirement {
	if m != nil {
		return m.AggregationRules
	}
	return nil
}

func (m *ClusterRole) GetMetrics() *ResourceMetrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/rbac/v1/generated.proto#L58
type ClusterRoleBinding struct {
	Metadata *Metadata                  `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Subjects []*Subject                 `protobuf:"bytes,2,rep,name=subjects" json:"subjects,omitempty"`
	RoleRef  *TypedLocalObjectReference `protobuf:"bytes,3,opt,name=roleRef" json:"roleRef,omitempty"`
	Yaml     []byte                     `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string                   `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
}

func (m *ClusterRoleBinding) Reset()                    { *m = ClusterRoleBinding{} }
func (m *ClusterRoleBinding) String() string            { return proto.CompactTextString(m) }
func (*ClusterRoleBinding) ProtoMessage()               {}
func (*ClusterRoleBinding) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{114} }

func (m *ClusterRoleBinding) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ClusterRoleBinding) GetSubjects() []*Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *ClusterRoleBinding) GetRoleRef() *TypedLocalObjectReference {
	if m != nil {
		return m.RoleRef
	}
	return nil
}

// reference https://github.com/kubernetes/kubernetes/blob/cb19b56831d54d1d31249949318ef0b07bf00df9/staging/src/k8s.io/api/core/v1/generated.proto#L4495
type ServiceAccount struct {
	Metadata                     *Metadata                    `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Secrets                      []*ObjectReference           `protobuf:"bytes,2,rep,name=secrets" json:"secrets,omitempty"`
	ImagePullSecrets             []*TypedLocalObjectReference `protobuf:"bytes,3,rep,name=imagePullSecrets" json:"imagePullSecrets,omitempty"`
	AutomountServiceAccountToken bool                         `protobuf:"varint,4,opt,name=automountServiceAccountToken,proto3" json:"automountServiceAccountToken,omitempty"`
	Yaml                         []byte                       `protobuf:"bytes,5,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags                         []string                     `protobuf:"bytes,6,rep,name=tags" json:"tags,omitempty"`
}

func (m *ServiceAccount) Reset()                    { *m = ServiceAccount{} }
func (m *ServiceAccount) String() string            { return proto.CompactTextString(m) }
func (*ServiceAccount) ProtoMessage()               {}
func (*ServiceAccount) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{115} }

func (m *ServiceAccount) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ServiceAccount) GetSecrets() []*ObjectReference {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *ServiceAccount) GetImagePullSecrets() []*TypedLocalObjectReference {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L259
// Note: ServiceBackendPort (contains port name and number) is flattened.
type IngressServiceBackend struct {
	ServiceName string `protobuf:"bytes,1,opt,name=serviceName,proto3" json:"serviceName,omitempty"`
	PortName    string `protobuf:"bytes,2,opt,name=portName,proto3" json:"portName,omitempty"`
	PortNumber  int32  `protobuf:"varint,3,opt,name=portNumber,proto3" json:"portNumber,omitempty"`
}

func (m *IngressServiceBackend) Reset()                    { *m = IngressServiceBackend{} }
func (m *IngressServiceBackend) String() string            { return proto.CompactTextString(m) }
func (*IngressServiceBackend) ProtoMessage()               {}
func (*IngressServiceBackend) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{116} }

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L112
type IngressBackend struct {
	Service  *IngressServiceBackend     `protobuf:"bytes,1,opt,name=service" json:"service,omitempty"`
	Resource *TypedLocalObjectReference `protobuf:"bytes,2,opt,name=resource" json:"resource,omitempty"`
}

func (m *IngressBackend) Reset()                    { *m = IngressBackend{} }
func (m *IngressBackend) String() string            { return proto.CompactTextString(m) }
func (*IngressBackend) ProtoMessage()               {}
func (*IngressBackend) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{117} }

func (m *IngressBackend) GetService() *IngressServiceBackend {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *IngressBackend) GetResource() *TypedLocalObjectReference {
	if m != nil {
		return m.Resource
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L315
type IngressTLS struct {
	Hosts      []string `protobuf:"bytes,1,rep,name=hosts" json:"hosts,omitempty"`
	SecretName string   `protobuf:"bytes,2,opt,name=secretName,proto3" json:"secretName,omitempty"`
}

func (m *IngressTLS) Reset()                    { *m = IngressTLS{} }
func (m *IngressTLS) String() string            { return proto.CompactTextString(m) }
func (*IngressTLS) ProtoMessage()               {}
func (*IngressTLS) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{118} }

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L35
type HTTPIngressPath struct {
	Path     string          `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	PathType string          `protobuf:"bytes,3,opt,name=pathType,proto3" json:"pathType,omitempty"`
	Backend  *IngressBackend `protobuf:"bytes,2,opt,name=backend" json:"backend,omitempty"`
}

func (m *HTTPIngressPath) Reset()                    { *m = HTTPIngressPath{} }
func (m *HTTPIngressPath) String() string            { return proto.CompactTextString(m) }
func (*HTTPIngressPath) ProtoMessage()               {}
func (*HTTPIngressPath) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{119} }

func (m *HTTPIngressPath) GetBackend() *IngressBackend {
	if m != nil {
		return m.Backend
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L214
// Note: IngressRuleValue and HTTPIngressRuleValue are flattened
type IngressRule struct {
	Host      string             `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	HttpPaths []*HTTPIngressPath `protobuf:"bytes,2,rep,name=httpPaths" json:"httpPaths,omitempty"`
}

func (m *IngressRule) Reset()                    { *m = IngressRule{} }
func (m *IngressRule) String() string            { return proto.CompactTextString(m) }
func (*IngressRule) ProtoMessage()               {}
func (*IngressRule) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{120} }

func (m *IngressRule) GetHttpPaths() []*HTTPIngressPath {
	if m != nil {
		return m.HttpPaths
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L270
type IngressSpec struct {
	DefaultBackend   *IngressBackend `protobuf:"bytes,1,opt,name=defaultBackend" json:"defaultBackend,omitempty"`
	Tls              []*IngressTLS   `protobuf:"bytes,2,rep,name=tls" json:"tls,omitempty"`
	Rules            []*IngressRule  `protobuf:"bytes,3,rep,name=rules" json:"rules,omitempty"`
	IngressClassName string          `protobuf:"bytes,4,opt,name=ingressClassName,proto3" json:"ingressClassName,omitempty"`
}

func (m *IngressSpec) Reset()                    { *m = IngressSpec{} }
func (m *IngressSpec) String() string            { return proto.CompactTextString(m) }
func (*IngressSpec) ProtoMessage()               {}
func (*IngressSpec) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{121} }

func (m *IngressSpec) GetDefaultBackend() *IngressBackend {
	if m != nil {
		return m.DefaultBackend
	}
	return nil
}

func (m *IngressSpec) GetTls() []*IngressTLS {
	if m != nil {
		return m.Tls
	}
	return nil
}

func (m *IngressSpec) GetRules() []*IngressRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/v0.21.5/core/v1/generated.proto#L3781
type PortStatus struct {
	Port     int32  `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	Protocol string `protobuf:"bytes,2,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Error    string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *PortStatus) Reset()                    { *m = PortStatus{} }
func (m *PortStatus) String() string            { return proto.CompactTextString(m) }
func (*PortStatus) ProtoMessage()               {}
func (*PortStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{122} }

// reference https://github.com/kubernetes/api/blob/v0.21.5/core/v1/generated.proto#L2024
type LoadBalancerIngress struct {
	Ip       string        `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Hostname string        `protobuf:"bytes,2,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Ports    []*PortStatus `protobuf:"bytes,4,rep,name=ports" json:"ports,omitempty"`
}

func (m *LoadBalancerIngress) Reset()                    { *m = LoadBalancerIngress{} }
func (m *LoadBalancerIngress) String() string            { return proto.CompactTextString(m) }
func (*LoadBalancerIngress) ProtoMessage()               {}
func (*LoadBalancerIngress) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{123} }

func (m *LoadBalancerIngress) GetPorts() []*PortStatus {
	if m != nil {
		return m.Ports
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L308
// LoadBalancerStatus is flattened
type IngressStatus struct {
	Ingress []*LoadBalancerIngress `protobuf:"bytes,1,rep,name=ingress" json:"ingress,omitempty"`
}

func (m *IngressStatus) Reset()                    { *m = IngressStatus{} }
func (m *IngressStatus) String() string            { return proto.CompactTextString(m) }
func (*IngressStatus) ProtoMessage()               {}
func (*IngressStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{124} }

func (m *IngressStatus) GetIngress() []*LoadBalancerIngress {
	if m != nil {
		return m.Ingress
	}
	return nil
}

// reference https://github.com/kubernetes/api/blob/v0.21.5/networking/v1/generated.proto#L94
type Ingress struct {
	Metadata *Metadata      `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec     *IngressSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status   *IngressStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml     []byte         `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags     []string       `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
}

func (m *Ingress) Reset()                    { *m = Ingress{} }
func (m *Ingress) String() string            { return proto.CompactTextString(m) }
func (*Ingress) ProtoMessage()               {}
func (*Ingress) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{125} }

func (m *Ingress) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Ingress) GetSpec() *IngressSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Ingress) GetStatus() *IngressStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type KafkaRequestHeader struct {
	RequestType    uint32 `protobuf:"varint,1,opt,name=request_type,json=requestType,proto3" json:"request_type,omitempty"`
	RequestVersion uint32 `protobuf:"varint,2,opt,name=request_version,json=requestVersion,proto3" json:"request_version,omitempty"`
}

func (m *KafkaRequestHeader) Reset()                    { *m = KafkaRequestHeader{} }
func (m *KafkaRequestHeader) String() string            { return proto.CompactTextString(m) }
func (*KafkaRequestHeader) ProtoMessage()               {}
func (*KafkaRequestHeader) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{126} }

type KafkaAggregation struct {
	Header *KafkaRequestHeader `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	Topic  string              `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`
	Count  uint32              `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *KafkaAggregation) Reset()                    { *m = KafkaAggregation{} }
func (m *KafkaAggregation) String() string            { return proto.CompactTextString(m) }
func (*KafkaAggregation) ProtoMessage()               {}
func (*KafkaAggregation) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{127} }

func (m *KafkaAggregation) GetHeader() *KafkaRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

type DataStreamsAggregations struct {
	KafkaProduceAggregations *DataStreamsAggregations_KafkaProduceAggregations `protobuf:"bytes,1,opt,name=kafkaProduceAggregations" json:"kafkaProduceAggregations,omitempty"`
	KafkaFetchAggregations   *DataStreamsAggregations_KafkaFetchAggregations   `protobuf:"bytes,2,opt,name=kafkaFetchAggregations" json:"kafkaFetchAggregations,omitempty"`
	KafkaAggregations        []*KafkaAggregation                               `protobuf:"bytes,3,rep,name=kafkaAggregations" json:"kafkaAggregations,omitempty"`
}

func (m *DataStreamsAggregations) Reset()                    { *m = DataStreamsAggregations{} }
func (m *DataStreamsAggregations) String() string            { return proto.CompactTextString(m) }
func (*DataStreamsAggregations) ProtoMessage()               {}
func (*DataStreamsAggregations) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{128} }

func (m *DataStreamsAggregations) GetKafkaProduceAggregations() *DataStreamsAggregations_KafkaProduceAggregations {
	if m != nil {
		return m.KafkaProduceAggregations
	}
	return nil
}

func (m *DataStreamsAggregations) GetKafkaFetchAggregations() *DataStreamsAggregations_KafkaFetchAggregations {
	if m != nil {
		return m.KafkaFetchAggregations
	}
	return nil
}

func (m *DataStreamsAggregations) GetKafkaAggregations() []*KafkaAggregation {
	if m != nil {
		return m.KafkaAggregations
	}
	return nil
}

// TopicStats, KafkaProduceAggregations, and KafkaFetchAggregations should be deleted once we change dd-go to support the new DataStreamsAggregations format
type DataStreamsAggregations_TopicStats struct {
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	Count uint32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *DataStreamsAggregations_TopicStats) Reset()         { *m = DataStreamsAggregations_TopicStats{} }
func (m *DataStreamsAggregations_TopicStats) String() string { return proto.CompactTextString(m) }
func (*DataStreamsAggregations_TopicStats) ProtoMessage()    {}
func (*DataStreamsAggregations_TopicStats) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{128, 0}
}

type DataStreamsAggregations_KafkaProduceAggregations struct {
	Stats []*DataStreamsAggregations_TopicStats `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty"`
}

func (m *DataStreamsAggregations_KafkaProduceAggregations) Reset() {
	*m = DataStreamsAggregations_KafkaProduceAggregations{}
}
func (m *DataStreamsAggregations_KafkaProduceAggregations) String() string {
	return proto.CompactTextString(m)
}
func (*DataStreamsAggregations_KafkaProduceAggregations) ProtoMessage() {}
func (*DataStreamsAggregations_KafkaProduceAggregations) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{128, 1}
}

func (m *DataStreamsAggregations_KafkaProduceAggregations) GetStats() []*DataStreamsAggregations_TopicStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type DataStreamsAggregations_KafkaFetchAggregations struct {
	Stats []*DataStreamsAggregations_TopicStats `protobuf:"bytes,1,rep,name=stats" json:"stats,omitempty"`
}

func (m *DataStreamsAggregations_KafkaFetchAggregations) Reset() {
	*m = DataStreamsAggregations_KafkaFetchAggregations{}
}
func (m *DataStreamsAggregations_KafkaFetchAggregations) String() string {
	return proto.CompactTextString(m)
}
func (*DataStreamsAggregations_KafkaFetchAggregations) ProtoMessage() {}
func (*DataStreamsAggregations_KafkaFetchAggregations) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{128, 2}
}

func (m *DataStreamsAggregations_KafkaFetchAggregations) GetStats() []*DataStreamsAggregations_TopicStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type HTTPAggregations struct {
	EndpointAggregations []*HTTPStats `protobuf:"bytes,2,rep,name=endpointAggregations" json:"endpointAggregations,omitempty"`
}

func (m *HTTPAggregations) Reset()                    { *m = HTTPAggregations{} }
func (m *HTTPAggregations) String() string            { return proto.CompactTextString(m) }
func (*HTTPAggregations) ProtoMessage()               {}
func (*HTTPAggregations) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{129} }

func (m *HTTPAggregations) GetEndpointAggregations() []*HTTPStats {
	if m != nil {
		return m.EndpointAggregations
	}
	return nil
}

// The current state of HTTP2Aggregations is identical to that of HTTPAggregations.
// However, there is a possibility that additional fields might be added to it in the future.
type HTTP2Aggregations struct {
	EndpointAggregations []*HTTPStats `protobuf:"bytes,1,rep,name=endpointAggregations" json:"endpointAggregations,omitempty"`
}

func (m *HTTP2Aggregations) Reset()                    { *m = HTTP2Aggregations{} }
func (m *HTTP2Aggregations) String() string            { return proto.CompactTextString(m) }
func (*HTTP2Aggregations) ProtoMessage()               {}
func (*HTTP2Aggregations) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{130} }

func (m *HTTP2Aggregations) GetEndpointAggregations() []*HTTPStats {
	if m != nil {
		return m.EndpointAggregations
	}
	return nil
}

type HTTPStats struct {
	Path   string     `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	Method HTTPMethod `protobuf:"varint,5,opt,name=method,proto3,enum=datadog.process_agent.HTTPMethod" json:"method,omitempty"`
	// The agent can only read a limited part of the http header because
	// of cpu/memory contraints. It is thus possible that the path is not
	// read entirely.
	// In case we're sure we've read the http path entirely, fullPath will
	// be set to true. In any other cases, it would be set to false.
	FullPath              bool              `protobuf:"varint,6,opt,name=fullPath,proto3" json:"fullPath,omitempty"`
	StatsByResponseStatus []*HTTPStats_Data `protobuf:"bytes,1,rep,name=statsByResponseStatus" json:"statsByResponseStatus,omitempty"`
	// This is a temporary field, that might be removed (and the index to be reserved) in the near future.
	// This is the new format of saving aggregations. We support any status code rather than just the status code families
	// as used in statsByResponseStatus.
	StatsByStatusCode map[int32]*HTTPStats_Data `protobuf:"bytes,2,rep,name=statsByStatusCode" json:"statsByStatusCode,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HTTPStats) Reset()                    { *m = HTTPStats{} }
func (m *HTTPStats) String() string            { return proto.CompactTextString(m) }
func (*HTTPStats) ProtoMessage()               {}
func (*HTTPStats) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{131} }

func (m *HTTPStats) GetStatsByResponseStatus() []*HTTPStats_Data {
	if m != nil {
		return m.StatsByResponseStatus
	}
	return nil
}

func (m *HTTPStats) GetStatsByStatusCode() map[int32]*HTTPStats_Data {
	if m != nil {
		return m.StatsByStatusCode
	}
	return nil
}

type HTTPStats_Data struct {
	Count uint32 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	// a protobuf encoded sketch of all the requests in this HTTPStats. In nanoseconds.
	// this will be nil if count == 1
	// To decode:
	//    use a protobuf library to decode this into a github.com/DataDog/sketches-go/ddsketch/pb/sketchpb.DDSketch
	// then call github.com/DataDog/sketches-go/ddsketch.FromProto
	// To encode:
	//    create a github.com/DataDog/sketches-go/ddsketch.DDSketch
	//    call ToProto() and then run through a protobuf encoder
	Latencies []byte `protobuf:"bytes,2,opt,name=latencies,proto3" json:"latencies,omitempty"`
	// if the HTTPStats has a single sample, this field will be the latency (in nanoseconds) of the only sample.
	// this is purely to avoid the overhead of having single entry sketches.
	FirstLatencySample float64 `protobuf:"fixed64,4,opt,name=firstLatencySample,proto3" json:"firstLatencySample,omitempty"`
}

func (m *HTTPStats_Data) Reset()                    { *m = HTTPStats_Data{} }
func (m *HTTPStats_Data) String() string            { return proto.CompactTextString(m) }
func (*HTTPStats_Data) ProtoMessage()               {}
func (*HTTPStats_Data) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{131, 1} }

// replaces DNSEntry.  Is a list of DNS names that a given IP resolved to.
// List of offsets into the EncodedDomainDatabase.
type DNSDatabaseEntry struct {
	NameOffsets []int32 `protobuf:"varint,1,rep,name=nameOffsets" json:"nameOffsets,omitempty"`
}

func (m *DNSDatabaseEntry) Reset()                    { *m = DNSDatabaseEntry{} }
func (m *DNSDatabaseEntry) String() string            { return proto.CompactTextString(m) }
func (*DNSDatabaseEntry) ProtoMessage()               {}
func (*DNSDatabaseEntry) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{132} }

// ResourceList is a set of (resource name, quantity) pairs
// https://pkg.go.dev/k8s.io/api/core/v1#ResourceList
type ResourceList struct {
	MetricValues map[string]float64 `protobuf:"bytes,1,rep,name=metricValues" json:"metricValues,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"fixed64,2,opt,name=value,proto3"`
}

func (m *ResourceList) Reset()                    { *m = ResourceList{} }
func (m *ResourceList) String() string            { return proto.CompactTextString(m) }
func (*ResourceList) ProtoMessage()               {}
func (*ResourceList) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{133} }

func (m *ResourceList) GetMetricValues() map[string]float64 {
	if m != nil {
		return m.MetricValues
	}
	return nil
}

// https://github.com/kubernetes/autoscaler/blob/master/vertical-pod-autoscaler/pkg/apis/autoscaling.k8s.io/v1/types.go
type VerticalPodAutoscaler struct {
	Metadata   *Metadata                         `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec       *VerticalPodAutoscalerSpec        `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status     *VerticalPodAutoscalerStatus      `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml       []byte                            `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags       []string                          `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Conditions []*VerticalPodAutoscalerCondition `protobuf:"bytes,6,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *VerticalPodAutoscaler) Reset()                    { *m = VerticalPodAutoscaler{} }
func (m *VerticalPodAutoscaler) String() string            { return proto.CompactTextString(m) }
func (*VerticalPodAutoscaler) ProtoMessage()               {}
func (*VerticalPodAutoscaler) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{134} }

func (m *VerticalPodAutoscaler) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *VerticalPodAutoscaler) GetSpec() *VerticalPodAutoscalerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *VerticalPodAutoscaler) GetStatus() *VerticalPodAutoscalerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *VerticalPodAutoscaler) GetConditions() []*VerticalPodAutoscalerCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

// reference https://github.com/kubernetes/autoscaler/blob/master/vertical-pod-autoscaler/pkg/apis/autoscaling.k8s.io/v1/types.go#L295
type VerticalPodAutoscalerCondition struct {
	Type               string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Status             string `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *VerticalPodAutoscalerCondition) Reset()         { *m = VerticalPodAutoscalerCondition{} }
func (m *VerticalPodAutoscalerCondition) String() string { return proto.CompactTextString(m) }
func (*VerticalPodAutoscalerCondition) ProtoMessage()    {}
func (*VerticalPodAutoscalerCondition) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{135}
}

type VerticalPodAutoscalerSpec struct {
	Target           *VerticalPodAutoscalerTarget `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	UpdateMode       string                       `protobuf:"bytes,2,opt,name=updateMode,proto3" json:"updateMode,omitempty"`
	ResourcePolicies []*ContainerResourcePolicy   `protobuf:"bytes,3,rep,name=resourcePolicies" json:"resourcePolicies,omitempty"`
}

func (m *VerticalPodAutoscalerSpec) Reset()         { *m = VerticalPodAutoscalerSpec{} }
func (m *VerticalPodAutoscalerSpec) String() string { return proto.CompactTextString(m) }
func (*VerticalPodAutoscalerSpec) ProtoMessage()    {}
func (*VerticalPodAutoscalerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{136}
}

func (m *VerticalPodAutoscalerSpec) GetTarget() *VerticalPodAutoscalerTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *VerticalPodAutoscalerSpec) GetResourcePolicies() []*ContainerResourcePolicy {
	if m != nil {
		return m.ResourcePolicies
	}
	return nil
}

type VerticalPodAutoscalerTarget struct {
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *VerticalPodAutoscalerTarget) Reset()         { *m = VerticalPodAutoscalerTarget{} }
func (m *VerticalPodAutoscalerTarget) String() string { return proto.CompactTextString(m) }
func (*VerticalPodAutoscalerTarget) ProtoMessage()    {}
func (*VerticalPodAutoscalerTarget) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{137}
}

type ContainerResourcePolicy struct {
	ContainerName      string        `protobuf:"bytes,1,opt,name=containerName,proto3" json:"containerName,omitempty"`
	Mode               string        `protobuf:"bytes,2,opt,name=mode,proto3" json:"mode,omitempty"`
	MinAllowed         *ResourceList `protobuf:"bytes,3,opt,name=minAllowed" json:"minAllowed,omitempty"`
	MaxAllowed         *ResourceList `protobuf:"bytes,4,opt,name=maxAllowed" json:"maxAllowed,omitempty"`
	ControlledResource []string      `protobuf:"bytes,5,rep,name=controlledResource" json:"controlledResource,omitempty"`
	ControlledValues   string        `protobuf:"bytes,6,opt,name=controlledValues,proto3" json:"controlledValues,omitempty"`
}

func (m *ContainerResourcePolicy) Reset()                    { *m = ContainerResourcePolicy{} }
func (m *ContainerResourcePolicy) String() string            { return proto.CompactTextString(m) }
func (*ContainerResourcePolicy) ProtoMessage()               {}
func (*ContainerResourcePolicy) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{138} }

func (m *ContainerResourcePolicy) GetMinAllowed() *ResourceList {
	if m != nil {
		return m.MinAllowed
	}
	return nil
}

func (m *ContainerResourcePolicy) GetMaxAllowed() *ResourceList {
	if m != nil {
		return m.MaxAllowed
	}
	return nil
}

type VerticalPodAutoscalerStatus struct {
	LastRecommendedDate int64                      `protobuf:"varint,1,opt,name=LastRecommendedDate,proto3" json:"LastRecommendedDate,omitempty"`
	Recommendations     []*ContainerRecommendation `protobuf:"bytes,2,rep,name=recommendations" json:"recommendations,omitempty"`
	Conditions          []*VPACondition            `protobuf:"bytes,3,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *VerticalPodAutoscalerStatus) Reset()         { *m = VerticalPodAutoscalerStatus{} }
func (m *VerticalPodAutoscalerStatus) String() string { return proto.CompactTextString(m) }
func (*VerticalPodAutoscalerStatus) ProtoMessage()    {}
func (*VerticalPodAutoscalerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{139}
}

func (m *VerticalPodAutoscalerStatus) GetRecommendations() []*ContainerRecommendation {
	if m != nil {
		return m.Recommendations
	}
	return nil
}

func (m *VerticalPodAutoscalerStatus) GetConditions() []*VPACondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type ContainerRecommendation struct {
	ContainerName  string        `protobuf:"bytes,1,opt,name=containerName,proto3" json:"containerName,omitempty"`
	Target         *ResourceList `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	LowerBound     *ResourceList `protobuf:"bytes,3,opt,name=lowerBound" json:"lowerBound,omitempty"`
	UpperBound     *ResourceList `protobuf:"bytes,4,opt,name=upperBound" json:"upperBound,omitempty"`
	UncappedTarget *ResourceList `protobuf:"bytes,5,opt,name=uncappedTarget" json:"uncappedTarget,omitempty"`
}

func (m *ContainerRecommendation) Reset()                    { *m = ContainerRecommendation{} }
func (m *ContainerRecommendation) String() string            { return proto.CompactTextString(m) }
func (*ContainerRecommendation) ProtoMessage()               {}
func (*ContainerRecommendation) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{140} }

func (m *ContainerRecommendation) GetTarget() *ResourceList {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ContainerRecommendation) GetLowerBound() *ResourceList {
	if m != nil {
		return m.LowerBound
	}
	return nil
}

func (m *ContainerRecommendation) GetUpperBound() *ResourceList {
	if m != nil {
		return m.UpperBound
	}
	return nil
}

func (m *ContainerRecommendation) GetUncappedTarget() *ResourceList {
	if m != nil {
		return m.UncappedTarget
	}
	return nil
}

type VPACondition struct {
	ConditionType      string `protobuf:"bytes,1,opt,name=ConditionType,proto3" json:"ConditionType,omitempty"`
	ConditionStatus    string `protobuf:"bytes,2,opt,name=ConditionStatus,proto3" json:"ConditionStatus,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=LastTransitionTime,proto3" json:"LastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=Reason,proto3" json:"Reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=Message,proto3" json:"Message,omitempty"`
}

func (m *VPACondition) Reset()                    { *m = VPACondition{} }
func (m *VPACondition) String() string            { return proto.CompactTextString(m) }
func (*VPACondition) ProtoMessage()               {}
func (*VPACondition) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{141} }

// https://github.com/kubernetes/api/blob/v0.23.15/autoscaling/v2/types.go
type HorizontalPodAutoscaler struct {
	Metadata   *Metadata                           `protobuf:"bytes,1,opt,name=metadata" json:"metadata,omitempty"`
	Spec       *HorizontalPodAutoscalerSpec        `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status     *HorizontalPodAutoscalerStatus      `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
	Yaml       []byte                              `protobuf:"bytes,4,opt,name=yaml,proto3" json:"yaml,omitempty"`
	Tags       []string                            `protobuf:"bytes,5,rep,name=tags" json:"tags,omitempty"`
	Conditions []*HorizontalPodAutoscalerCondition `protobuf:"bytes,6,rep,name=conditions" json:"conditions,omitempty"`
}

func (m *HorizontalPodAutoscaler) Reset()                    { *m = HorizontalPodAutoscaler{} }
func (m *HorizontalPodAutoscaler) String() string            { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscaler) ProtoMessage()               {}
func (*HorizontalPodAutoscaler) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{142} }

func (m *HorizontalPodAutoscaler) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *HorizontalPodAutoscaler) GetSpec() *HorizontalPodAutoscalerSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *HorizontalPodAutoscaler) GetStatus() *HorizontalPodAutoscalerStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *HorizontalPodAutoscaler) GetConditions() []*HorizontalPodAutoscalerCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

type HorizontalPodAutoscalerSpec struct {
	Target      *HorizontalPodAutoscalerTarget       `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	MinReplicas int32                                `protobuf:"varint,2,opt,name=minReplicas,proto3" json:"minReplicas,omitempty"`
	MaxReplicas int32                                `protobuf:"varint,3,opt,name=maxReplicas,proto3" json:"maxReplicas,omitempty"`
	Metrics     []*HorizontalPodAutoscalerMetricSpec `protobuf:"bytes,4,rep,name=metrics" json:"metrics,omitempty"`
	Behavior    *HorizontalPodAutoscalerBehavior     `protobuf:"bytes,5,opt,name=behavior" json:"behavior,omitempty"`
}

func (m *HorizontalPodAutoscalerSpec) Reset()         { *m = HorizontalPodAutoscalerSpec{} }
func (m *HorizontalPodAutoscalerSpec) String() string { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscalerSpec) ProtoMessage()    {}
func (*HorizontalPodAutoscalerSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{143}
}

func (m *HorizontalPodAutoscalerSpec) GetTarget() *HorizontalPodAutoscalerTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *HorizontalPodAutoscalerSpec) GetMetrics() []*HorizontalPodAutoscalerMetricSpec {
	if m != nil {
		return m.Metrics
	}
	return nil
}

func (m *HorizontalPodAutoscalerSpec) GetBehavior() *HorizontalPodAutoscalerBehavior {
	if m != nil {
		return m.Behavior
	}
	return nil
}

type HorizontalPodAutoscalerTarget struct {
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *HorizontalPodAutoscalerTarget) Reset()         { *m = HorizontalPodAutoscalerTarget{} }
func (m *HorizontalPodAutoscalerTarget) String() string { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscalerTarget) ProtoMessage()    {}
func (*HorizontalPodAutoscalerTarget) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{144}
}

type HorizontalPodAutoscalerMetricSpec struct {
	Type              string                         `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Object            *ObjectMetricSource            `protobuf:"bytes,2,opt,name=object" json:"object,omitempty"`
	Pods              *PodsMetricSource              `protobuf:"bytes,3,opt,name=pods" json:"pods,omitempty"`
	Resource          *ResourceMetricSource          `protobuf:"bytes,4,opt,name=resource" json:"resource,omitempty"`
	ContainerResource *ContainerResourceMetricSource `protobuf:"bytes,5,opt,name=containerResource" json:"containerResource,omitempty"`
	External          *ExternalMetricSource          `protobuf:"bytes,6,opt,name=external" json:"external,omitempty"`
}

func (m *HorizontalPodAutoscalerMetricSpec) Reset()         { *m = HorizontalPodAutoscalerMetricSpec{} }
func (m *HorizontalPodAutoscalerMetricSpec) String() string { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscalerMetricSpec) ProtoMessage()    {}
func (*HorizontalPodAutoscalerMetricSpec) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{145}
}

func (m *HorizontalPodAutoscalerMetricSpec) GetObject() *ObjectMetricSource {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricSpec) GetPods() *PodsMetricSource {
	if m != nil {
		return m.Pods
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricSpec) GetResource() *ResourceMetricSource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricSpec) GetContainerResource() *ContainerResourceMetricSource {
	if m != nil {
		return m.ContainerResource
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricSpec) GetExternal() *ExternalMetricSource {
	if m != nil {
		return m.External
	}
	return nil
}

type ObjectMetricSource struct {
	DescribedObject *ObjectReference  `protobuf:"bytes,1,opt,name=describedObject" json:"describedObject,omitempty"`
	Target          *MetricTarget     `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	Metric          *MetricIdentifier `protobuf:"bytes,3,opt,name=metric" json:"metric,omitempty"`
}

func (m *ObjectMetricSource) Reset()                    { *m = ObjectMetricSource{} }
func (m *ObjectMetricSource) String() string            { return proto.CompactTextString(m) }
func (*ObjectMetricSource) ProtoMessage()               {}
func (*ObjectMetricSource) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{146} }

func (m *ObjectMetricSource) GetDescribedObject() *ObjectReference {
	if m != nil {
		return m.DescribedObject
	}
	return nil
}

func (m *ObjectMetricSource) GetTarget() *MetricTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *ObjectMetricSource) GetMetric() *MetricIdentifier {
	if m != nil {
		return m.Metric
	}
	return nil
}

type MetricTarget struct {
	Type  string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *MetricTarget) Reset()                    { *m = MetricTarget{} }
func (m *MetricTarget) String() string            { return proto.CompactTextString(m) }
func (*MetricTarget) ProtoMessage()               {}
func (*MetricTarget) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{147} }

type MetricIdentifier struct {
	Name          string                      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	LabelSelector []*LabelSelectorRequirement `protobuf:"bytes,2,rep,name=labelSelector" json:"labelSelector,omitempty"`
}

func (m *MetricIdentifier) Reset()                    { *m = MetricIdentifier{} }
func (m *MetricIdentifier) String() string            { return proto.CompactTextString(m) }
func (*MetricIdentifier) ProtoMessage()               {}
func (*MetricIdentifier) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{148} }

func (m *MetricIdentifier) GetLabelSelector() []*LabelSelectorRequirement {
	if m != nil {
		return m.LabelSelector
	}
	return nil
}

type PodsMetricSource struct {
	Metric *MetricIdentifier `protobuf:"bytes,1,opt,name=metric" json:"metric,omitempty"`
	Target *MetricTarget     `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *PodsMetricSource) Reset()                    { *m = PodsMetricSource{} }
func (m *PodsMetricSource) String() string            { return proto.CompactTextString(m) }
func (*PodsMetricSource) ProtoMessage()               {}
func (*PodsMetricSource) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{149} }

func (m *PodsMetricSource) GetMetric() *MetricIdentifier {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *PodsMetricSource) GetTarget() *MetricTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

type ResourceMetricSource struct {
	ResourceName string        `protobuf:"bytes,1,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
	Target       *MetricTarget `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *ResourceMetricSource) Reset()                    { *m = ResourceMetricSource{} }
func (m *ResourceMetricSource) String() string            { return proto.CompactTextString(m) }
func (*ResourceMetricSource) ProtoMessage()               {}
func (*ResourceMetricSource) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{150} }

func (m *ResourceMetricSource) GetTarget() *MetricTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

type ContainerResourceMetricSource struct {
	ResourceName string        `protobuf:"bytes,1,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
	Target       *MetricTarget `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	Container    string        `protobuf:"bytes,3,opt,name=container,proto3" json:"container,omitempty"`
}

func (m *ContainerResourceMetricSource) Reset()         { *m = ContainerResourceMetricSource{} }
func (m *ContainerResourceMetricSource) String() string { return proto.CompactTextString(m) }
func (*ContainerResourceMetricSource) ProtoMessage()    {}
func (*ContainerResourceMetricSource) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{151}
}

func (m *ContainerResourceMetricSource) GetTarget() *MetricTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

type ExternalMetricSource struct {
	Metric *MetricIdentifier `protobuf:"bytes,1,opt,name=metric" json:"metric,omitempty"`
	Target *MetricTarget     `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *ExternalMetricSource) Reset()                    { *m = ExternalMetricSource{} }
func (m *ExternalMetricSource) String() string            { return proto.CompactTextString(m) }
func (*ExternalMetricSource) ProtoMessage()               {}
func (*ExternalMetricSource) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{152} }

func (m *ExternalMetricSource) GetMetric() *MetricIdentifier {
	if m != nil {
		return m.Metric
	}
	return nil
}

func (m *ExternalMetricSource) GetTarget() *MetricTarget {
	if m != nil {
		return m.Target
	}
	return nil
}

type HorizontalPodAutoscalerBehavior struct {
	ScaleUp   *HPAScalingRules `protobuf:"bytes,1,opt,name=scaleUp" json:"scaleUp,omitempty"`
	ScaleDown *HPAScalingRules `protobuf:"bytes,2,opt,name=scaleDown" json:"scaleDown,omitempty"`
}

func (m *HorizontalPodAutoscalerBehavior) Reset()         { *m = HorizontalPodAutoscalerBehavior{} }
func (m *HorizontalPodAutoscalerBehavior) String() string { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscalerBehavior) ProtoMessage()    {}
func (*HorizontalPodAutoscalerBehavior) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{153}
}

func (m *HorizontalPodAutoscalerBehavior) GetScaleUp() *HPAScalingRules {
	if m != nil {
		return m.ScaleUp
	}
	return nil
}

func (m *HorizontalPodAutoscalerBehavior) GetScaleDown() *HPAScalingRules {
	if m != nil {
		return m.ScaleDown
	}
	return nil
}

type HPAScalingRules struct {
	StabilizationWindowSeconds int32               `protobuf:"varint,1,opt,name=stabilizationWindowSeconds,proto3" json:"stabilizationWindowSeconds,omitempty"`
	SelectPolicy               string              `protobuf:"bytes,2,opt,name=selectPolicy,proto3" json:"selectPolicy,omitempty"`
	Policies                   []*HPAScalingPolicy `protobuf:"bytes,3,rep,name=policies" json:"policies,omitempty"`
}

func (m *HPAScalingRules) Reset()                    { *m = HPAScalingRules{} }
func (m *HPAScalingRules) String() string            { return proto.CompactTextString(m) }
func (*HPAScalingRules) ProtoMessage()               {}
func (*HPAScalingRules) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{154} }

func (m *HPAScalingRules) GetPolicies() []*HPAScalingPolicy {
	if m != nil {
		return m.Policies
	}
	return nil
}

type HPAScalingPolicy struct {
	Type          string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Value         int32  `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	PeriodSeconds int32  `protobuf:"varint,3,opt,name=periodSeconds,proto3" json:"periodSeconds,omitempty"`
}

func (m *HPAScalingPolicy) Reset()                    { *m = HPAScalingPolicy{} }
func (m *HPAScalingPolicy) String() string            { return proto.CompactTextString(m) }
func (*HPAScalingPolicy) ProtoMessage()               {}
func (*HPAScalingPolicy) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{155} }

type HorizontalPodAutoscalerStatus struct {
	ObservedGeneration int64                                  `protobuf:"varint,1,opt,name=observedGeneration,proto3" json:"observedGeneration,omitempty"`
	LastScaleTime      int64                                  `protobuf:"varint,2,opt,name=lastScaleTime,proto3" json:"lastScaleTime,omitempty"`
	CurrentReplicas    int32                                  `protobuf:"varint,3,opt,name=currentReplicas,proto3" json:"currentReplicas,omitempty"`
	DesiredReplicas    int32                                  `protobuf:"varint,4,opt,name=desiredReplicas,proto3" json:"desiredReplicas,omitempty"`
	CurrentMetrics     []*HorizontalPodAutoscalerMetricStatus `protobuf:"bytes,5,rep,name=currentMetrics" json:"currentMetrics,omitempty"`
}

func (m *HorizontalPodAutoscalerStatus) Reset()         { *m = HorizontalPodAutoscalerStatus{} }
func (m *HorizontalPodAutoscalerStatus) String() string { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscalerStatus) ProtoMessage()    {}
func (*HorizontalPodAutoscalerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{156}
}

func (m *HorizontalPodAutoscalerStatus) GetCurrentMetrics() []*HorizontalPodAutoscalerMetricStatus {
	if m != nil {
		return m.CurrentMetrics
	}
	return nil
}

type HorizontalPodAutoscalerCondition struct {
	ConditionType      string `protobuf:"bytes,1,opt,name=conditionType,proto3" json:"conditionType,omitempty"`
	ConditionStatus    string `protobuf:"bytes,2,opt,name=conditionStatus,proto3" json:"conditionStatus,omitempty"`
	LastTransitionTime int64  `protobuf:"varint,3,opt,name=lastTransitionTime,proto3" json:"lastTransitionTime,omitempty"`
	Reason             string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
	Message            string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *HorizontalPodAutoscalerCondition) Reset()         { *m = HorizontalPodAutoscalerCondition{} }
func (m *HorizontalPodAutoscalerCondition) String() string { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscalerCondition) ProtoMessage()    {}
func (*HorizontalPodAutoscalerCondition) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{157}
}

type HorizontalPodAutoscalerMetricStatus struct {
	Type              string                         `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Object            *ObjectMetricStatus            `protobuf:"bytes,2,opt,name=object" json:"object,omitempty"`
	Pods              *PodsMetricStatus              `protobuf:"bytes,3,opt,name=pods" json:"pods,omitempty"`
	Resource          *ResourceMetricStatus          `protobuf:"bytes,4,opt,name=resource" json:"resource,omitempty"`
	ContainerResource *ContainerResourceMetricStatus `protobuf:"bytes,5,opt,name=containerResource" json:"containerResource,omitempty"`
	External          *ExternalMetricStatus          `protobuf:"bytes,6,opt,name=external" json:"external,omitempty"`
}

func (m *HorizontalPodAutoscalerMetricStatus) Reset()         { *m = HorizontalPodAutoscalerMetricStatus{} }
func (m *HorizontalPodAutoscalerMetricStatus) String() string { return proto.CompactTextString(m) }
func (*HorizontalPodAutoscalerMetricStatus) ProtoMessage()    {}
func (*HorizontalPodAutoscalerMetricStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{158}
}

func (m *HorizontalPodAutoscalerMetricStatus) GetObject() *ObjectMetricStatus {
	if m != nil {
		return m.Object
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricStatus) GetPods() *PodsMetricStatus {
	if m != nil {
		return m.Pods
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricStatus) GetResource() *ResourceMetricStatus {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricStatus) GetContainerResource() *ContainerResourceMetricStatus {
	if m != nil {
		return m.ContainerResource
	}
	return nil
}

func (m *HorizontalPodAutoscalerMetricStatus) GetExternal() *ExternalMetricStatus {
	if m != nil {
		return m.External
	}
	return nil
}

type ObjectMetricStatus struct {
	DescribedObject *ObjectReference  `protobuf:"bytes,1,opt,name=describedObject" json:"describedObject,omitempty"`
	Current         int64             `protobuf:"varint,2,opt,name=current,proto3" json:"current,omitempty"`
	Metric          *MetricIdentifier `protobuf:"bytes,3,opt,name=metric" json:"metric,omitempty"`
}

func (m *ObjectMetricStatus) Reset()                    { *m = ObjectMetricStatus{} }
func (m *ObjectMetricStatus) String() string            { return proto.CompactTextString(m) }
func (*ObjectMetricStatus) ProtoMessage()               {}
func (*ObjectMetricStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{159} }

func (m *ObjectMetricStatus) GetDescribedObject() *ObjectReference {
	if m != nil {
		return m.DescribedObject
	}
	return nil
}

func (m *ObjectMetricStatus) GetMetric() *MetricIdentifier {
	if m != nil {
		return m.Metric
	}
	return nil
}

type PodsMetricStatus struct {
	Metric  *MetricIdentifier `protobuf:"bytes,1,opt,name=metric" json:"metric,omitempty"`
	Current int64             `protobuf:"varint,2,opt,name=current,proto3" json:"current,omitempty"`
}

func (m *PodsMetricStatus) Reset()                    { *m = PodsMetricStatus{} }
func (m *PodsMetricStatus) String() string            { return proto.CompactTextString(m) }
func (*PodsMetricStatus) ProtoMessage()               {}
func (*PodsMetricStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{160} }

func (m *PodsMetricStatus) GetMetric() *MetricIdentifier {
	if m != nil {
		return m.Metric
	}
	return nil
}

type ResourceMetricStatus struct {
	ResourceName string `protobuf:"bytes,1,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
	Current      int64  `protobuf:"varint,2,opt,name=current,proto3" json:"current,omitempty"`
}

func (m *ResourceMetricStatus) Reset()                    { *m = ResourceMetricStatus{} }
func (m *ResourceMetricStatus) String() string            { return proto.CompactTextString(m) }
func (*ResourceMetricStatus) ProtoMessage()               {}
func (*ResourceMetricStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{161} }

type ContainerResourceMetricStatus struct {
	ResourceName string `protobuf:"bytes,1,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
	Current      int64  `protobuf:"varint,2,opt,name=current,proto3" json:"current,omitempty"`
	Container    string `protobuf:"bytes,3,opt,name=container,proto3" json:"container,omitempty"`
}

func (m *ContainerResourceMetricStatus) Reset()         { *m = ContainerResourceMetricStatus{} }
func (m *ContainerResourceMetricStatus) String() string { return proto.CompactTextString(m) }
func (*ContainerResourceMetricStatus) ProtoMessage()    {}
func (*ContainerResourceMetricStatus) Descriptor() ([]byte, []int) {
	return fileDescriptorAgent, []int{162}
}

type ExternalMetricStatus struct {
	Metric  *MetricIdentifier `protobuf:"bytes,1,opt,name=metric" json:"metric,omitempty"`
	Current int64             `protobuf:"varint,2,opt,name=current,proto3" json:"current,omitempty"`
}

func (m *ExternalMetricStatus) Reset()                    { *m = ExternalMetricStatus{} }
func (m *ExternalMetricStatus) String() string            { return proto.CompactTextString(m) }
func (*ExternalMetricStatus) ProtoMessage()               {}
func (*ExternalMetricStatus) Descriptor() ([]byte, []int) { return fileDescriptorAgent, []int{163} }

func (m *ExternalMetricStatus) GetMetric() *MetricIdentifier {
	if m != nil {
		return m.Metric
	}
	return nil
}

func init() {
	proto.RegisterType((*ResCollector)(nil), "datadog.process_agent.ResCollector")
	proto.RegisterType((*ResCollector_Header)(nil), "datadog.process_agent.ResCollector.Header")
	proto.RegisterType((*CollectorProc)(nil), "datadog.process_agent.CollectorProc")
	proto.RegisterType((*CollectorProcDiscovery)(nil), "datadog.process_agent.CollectorProcDiscovery")
	proto.RegisterType((*CollectorRealTime)(nil), "datadog.process_agent.CollectorRealTime")
	proto.RegisterType((*CollectorContainer)(nil), "datadog.process_agent.CollectorContainer")
	proto.RegisterType((*CollectorContainerRealTime)(nil), "datadog.process_agent.CollectorContainerRealTime")
	proto.RegisterType((*CollectorReqStatus)(nil), "datadog.process_agent.CollectorReqStatus")
	proto.RegisterType((*CollectorPod)(nil), "datadog.process_agent.CollectorPod")
	proto.RegisterType((*CollectorReplicaSet)(nil), "datadog.process_agent.CollectorReplicaSet")
	proto.RegisterType((*CollectorDeployment)(nil), "datadog.process_agent.CollectorDeployment")
	proto.RegisterType((*CollectorService)(nil), "datadog.process_agent.CollectorService")
	proto.RegisterType((*CollectorNode)(nil), "datadog.process_agent.CollectorNode")
	proto.RegisterType((*CollectorCluster)(nil), "datadog.process_agent.CollectorCluster")
	proto.RegisterType((*CollectorManifest)(nil), "datadog.process_agent.CollectorManifest")
	proto.RegisterType((*CollectorManifestCRD)(nil), "datadog.process_agent.CollectorManifestCRD")
	proto.RegisterType((*CollectorManifestCR)(nil), "datadog.process_agent.CollectorManifestCR")
	proto.RegisterType((*CollectorNamespace)(nil), "datadog.process_agent.CollectorNamespace")
	proto.RegisterType((*CollectorJob)(nil), "datadog.process_agent.CollectorJob")
	proto.RegisterType((*CollectorCronJob)(nil), "datadog.process_agent.CollectorCronJob")
	proto.RegisterType((*CollectorDaemonSet)(nil), "datadog.process_agent.CollectorDaemonSet")
	proto.RegisterType((*CollectorStatefulSet)(nil), "datadog.process_agent.CollectorStatefulSet")
	proto.RegisterType((*CollectorPersistentVolume)(nil), "datadog.process_agent.CollectorPersistentVolume")
	proto.RegisterType((*CollectorPersistentVolumeClaim)(nil), "datadog.process_agent.CollectorPersistentVolumeClaim")
	proto.RegisterType((*CollectorRole)(nil), "datadog.process_agent.CollectorRole")
	proto.RegisterType((*CollectorRoleBinding)(nil), "datadog.process_agent.CollectorRoleBinding")
	proto.RegisterType((*CollectorClusterRole)(nil), "datadog.process_agent.CollectorClusterRole")
	proto.RegisterType((*CollectorClusterRoleBinding)(nil), "datadog.process_agent.CollectorClusterRoleBinding")
	proto.RegisterType((*CollectorServiceAccount)(nil), "datadog.process_agent.CollectorServiceAccount")
	proto.RegisterType((*CollectorIngress)(nil), "datadog.process_agent.CollectorIngress")
	proto.RegisterType((*CollectorVerticalPodAutoscaler)(nil), "datadog.process_agent.CollectorVerticalPodAutoscaler")
	proto.RegisterType((*CollectorHorizontalPodAutoscaler)(nil), "datadog.process_agent.CollectorHorizontalPodAutoscaler")
	proto.RegisterType((*CollectorStatus)(nil), "datadog.process_agent.CollectorStatus")
	proto.RegisterType((*Process)(nil), "datadog.process_agent.Process")
	proto.RegisterType((*ProcessDiscovery)(nil), "datadog.process_agent.ProcessDiscovery")
	proto.RegisterType((*Command)(nil), "datadog.process_agent.Command")
	proto.RegisterType((*ProcessUser)(nil), "datadog.process_agent.ProcessUser")
	proto.RegisterType((*ProcessNetworks)(nil), "datadog.process_agent.ProcessNetworks")
	proto.RegisterType((*ContainerAddr)(nil), "datadog.process_agent.ContainerAddr")
	proto.RegisterType((*Container)(nil), "datadog.process_agent.Container")
	proto.RegisterType((*ProcessStat)(nil), "datadog.process_agent.ProcessStat")
	proto.RegisterType((*ProcStatsWithPerm)(nil), "datadog.process_agent.ProcStatsWithPerm")
	proto.RegisterType((*ProcStatsWithPermByPID)(nil), "datadog.process_agent.ProcStatsWithPermByPID")
	proto.RegisterType((*ContainerStat)(nil), "datadog.process_agent.ContainerStat")
	proto.RegisterType((*SystemInfo)(nil), "datadog.process_agent.SystemInfo")
	proto.RegisterType((*OSInfo)(nil), "datadog.process_agent.OSInfo")
	proto.RegisterType((*IOStat)(nil), "datadog.process_agent.IOStat")
	proto.RegisterType((*MemoryStat)(nil), "datadog.process_agent.MemoryStat")
	proto.RegisterType((*CPUStat)(nil), "datadog.process_agent.CPUStat")
	proto.RegisterType((*SingleCPUStat)(nil), "datadog.process_agent.SingleCPUStat")
	proto.RegisterType((*CPUInfo)(nil), "datadog.process_agent.CPUInfo")
	proto.RegisterType((*Host)(nil), "datadog.process_agent.Host")
	proto.RegisterType((*Cluster)(nil), "datadog.process_agent.Cluster")
	proto.RegisterType((*Metadata)(nil), "datadog.process_agent.Metadata")
	proto.RegisterType((*OwnerReference)(nil), "datadog.process_agent.OwnerReference")
	proto.RegisterType((*ObjectReference)(nil), "datadog.process_agent.ObjectReference")
	proto.RegisterType((*ServicePort)(nil), "datadog.process_agent.ServicePort")
	proto.RegisterType((*ServiceSessionAffinityConfig)(nil), "datadog.process_agent.ServiceSessionAffinityConfig")
	proto.RegisterType((*Node)(nil), "datadog.process_agent.Node")
	proto.RegisterType((*NodeStatus)(nil), "datadog.process_agent.NodeStatus")
	proto.RegisterType((*NodeCondition)(nil), "datadog.process_agent.NodeCondition")
	proto.RegisterType((*ContainerImage)(nil), "datadog.process_agent.ContainerImage")
	proto.RegisterType((*Taint)(nil), "datadog.process_agent.Taint")
	proto.RegisterType((*ServiceSpec)(nil), "datadog.process_agent.ServiceSpec")
	proto.RegisterType((*ServiceStatus)(nil), "datadog.process_agent.ServiceStatus")
	proto.RegisterType((*Service)(nil), "datadog.process_agent.Service")
	proto.RegisterType((*DeploymentCondition)(nil), "datadog.process_agent.DeploymentCondition")
	proto.RegisterType((*Deployment)(nil), "datadog.process_agent.Deployment")
	proto.RegisterType((*ReplicaSetCondition)(nil), "datadog.process_agent.ReplicaSetCondition")
	proto.RegisterType((*ReplicaSet)(nil), "datadog.process_agent.ReplicaSet")
	proto.RegisterType((*LabelSelectorRequirement)(nil), "datadog.process_agent.LabelSelectorRequirement")
	proto.RegisterType((*Pod)(nil), "datadog.process_agent.Pod")
	proto.RegisterType((*PodCondition)(nil), "datadog.process_agent.PodCondition")
	proto.RegisterType((*ContainerStatus)(nil), "datadog.process_agent.ContainerStatus")
	proto.RegisterType((*Manifest)(nil), "datadog.process_agent.Manifest")
	proto.RegisterType((*NamespaceCondition)(nil), "datadog.process_agent.NamespaceCondition")
	proto.RegisterType((*Namespace)(nil), "datadog.process_agent.Namespace")
	proto.RegisterType((*ResourceRequirements)(nil), "datadog.process_agent.ResourceRequirements")
	proto.RegisterType((*ResourceMetrics)(nil), "datadog.process_agent.ResourceMetrics")
	proto.RegisterType((*JobSpec)(nil), "datadog.process_agent.JobSpec")
	proto.RegisterType((*JobStatus)(nil), "datadog.process_agent.JobStatus")
	proto.RegisterType((*JobCondition)(nil), "datadog.process_agent.JobCondition")
	proto.RegisterType((*Job)(nil), "datadog.process_agent.Job")
	proto.RegisterType((*CronJobSpec)(nil), "datadog.process_agent.CronJobSpec")
	proto.RegisterType((*CronJobStatus)(nil), "datadog.process_agent.CronJobStatus")
	proto.RegisterType((*CronJob)(nil), "datadog.process_agent.CronJob")
	proto.RegisterType((*DaemonSetSpec)(nil), "datadog.process_agent.DaemonSetSpec")
	proto.RegisterType((*DaemonSetStatus)(nil), "datadog.process_agent.DaemonSetStatus")
	proto.RegisterType((*DaemonSetCondition)(nil), "datadog.process_agent.DaemonSetCondition")
	proto.RegisterType((*DaemonSet)(nil), "datadog.process_agent.DaemonSet")
	proto.RegisterType((*StatefulSetSpec)(nil), "datadog.process_agent.StatefulSetSpec")
	proto.RegisterType((*StatefulSetStatus)(nil), "datadog.process_agent.StatefulSetStatus")
	proto.RegisterType((*StatefulSetCondition)(nil), "datadog.process_agent.StatefulSetCondition")
	proto.RegisterType((*StatefulSet)(nil), "datadog.process_agent.StatefulSet")
	proto.RegisterType((*PersistentVolume)(nil), "datadog.process_agent.PersistentVolume")
	proto.RegisterType((*PersistentVolumeSpec)(nil), "datadog.process_agent.PersistentVolumeSpec")
	proto.RegisterType((*PersistentVolumeSource)(nil), "datadog.process_agent.PersistentVolumeSource")
	proto.RegisterType((*GCEPersistentDiskVolumeSource)(nil), "datadog.process_agent.GCEPersistentDiskVolumeSource")
	proto.RegisterType((*AWSElasticBlockStoreVolumeSource)(nil), "datadog.process_agent.AWSElasticBlockStoreVolumeSource")
	proto.RegisterType((*AzureFilePersistentVolumeSource)(nil), "datadog.process_agent.AzureFilePersistentVolumeSource")
	proto.RegisterType((*AzureDiskVolumeSource)(nil), "datadog.process_agent.AzureDiskVolumeSource")
	proto.RegisterType((*CSIVolumeSource)(nil), "datadog.process_agent.CSIVolumeSource")
	proto.RegisterType((*SecretReference)(nil), "datadog.process_agent.SecretReference")
	proto.RegisterType((*PersistentVolumeStatus)(nil), "datadog.process_agent.PersistentVolumeStatus")
	proto.RegisterType((*NodeSelectorTerm)(nil), "datadog.process_agent.NodeSelectorTerm")
	proto.RegisterType((*PersistentVolumeClaim)(nil), "datadog.process_agent.PersistentVolumeClaim")
	proto.RegisterType((*PersistentVolumeClaimStatus)(nil), "datadog.process_agent.PersistentVolumeClaimStatus")
	proto.RegisterType((*PersistentVolumeClaimSpec)(nil), "datadog.process_agent.PersistentVolumeClaimSpec")
	proto.RegisterType((*TypedLocalObjectReference)(nil), "datadog.process_agent.TypedLocalObjectReference")
	proto.RegisterType((*PersistentVolumeClaimCondition)(nil), "datadog.process_agent.PersistentVolumeClaimCondition")
	proto.RegisterType((*PolicyRule)(nil), "datadog.process_agent.PolicyRule")
	proto.RegisterType((*Subject)(nil), "datadog.process_agent.Subject")
	proto.RegisterType((*Role)(nil), "datadog.process_agent.Role")
	proto.RegisterType((*RoleBinding)(nil), "datadog.process_agent.RoleBinding")
	proto.RegisterType((*ClusterRole)(nil), "datadog.process_agent.ClusterRole")
	proto.RegisterType((*ClusterRoleBinding)(nil), "datadog.process_agent.ClusterRoleBinding")
	proto.RegisterType((*ServiceAccount)(nil), "datadog.process_agent.ServiceAccount")
	proto.RegisterType((*IngressServiceBackend)(nil), "datadog.process_agent.IngressServiceBackend")
	proto.RegisterType((*IngressBackend)(nil), "datadog.process_agent.IngressBackend")
	proto.RegisterType((*IngressTLS)(nil), "datadog.process_agent.IngressTLS")
	proto.RegisterType((*HTTPIngressPath)(nil), "datadog.process_agent.HTTPIngressPath")
	proto.RegisterType((*IngressRule)(nil), "datadog.process_agent.IngressRule")
	proto.RegisterType((*IngressSpec)(nil), "datadog.process_agent.IngressSpec")
	proto.RegisterType((*PortStatus)(nil), "datadog.process_agent.PortStatus")
	proto.RegisterType((*LoadBalancerIngress)(nil), "datadog.process_agent.LoadBalancerIngress")
	proto.RegisterType((*IngressStatus)(nil), "datadog.process_agent.IngressStatus")
	proto.RegisterType((*Ingress)(nil), "datadog.process_agent.Ingress")
	proto.RegisterType((*KafkaRequestHeader)(nil), "datadog.process_agent.KafkaRequestHeader")
	proto.RegisterType((*KafkaAggregation)(nil), "datadog.process_agent.KafkaAggregation")
	proto.RegisterType((*DataStreamsAggregations)(nil), "datadog.process_agent.DataStreamsAggregations")
	proto.RegisterType((*DataStreamsAggregations_TopicStats)(nil), "datadog.process_agent.DataStreamsAggregations.TopicStats")
	proto.RegisterType((*DataStreamsAggregations_KafkaProduceAggregations)(nil), "datadog.process_agent.DataStreamsAggregations.KafkaProduceAggregations")
	proto.RegisterType((*DataStreamsAggregations_KafkaFetchAggregations)(nil), "datadog.process_agent.DataStreamsAggregations.KafkaFetchAggregations")
	proto.RegisterType((*HTTPAggregations)(nil), "datadog.process_agent.HTTPAggregations")
	proto.RegisterType((*HTTP2Aggregations)(nil), "datadog.process_agent.HTTP2Aggregations")
	proto.RegisterType((*HTTPStats)(nil), "datadog.process_agent.HTTPStats")
	proto.RegisterType((*HTTPStats_Data)(nil), "datadog.process_agent.HTTPStats.Data")
	proto.RegisterType((*DNSDatabaseEntry)(nil), "datadog.process_agent.DNSDatabaseEntry")
	proto.RegisterType((*ResourceList)(nil), "datadog.process_agent.ResourceList")
	proto.RegisterType((*VerticalPodAutoscaler)(nil), "datadog.process_agent.VerticalPodAutoscaler")
	proto.RegisterType((*VerticalPodAutoscalerCondition)(nil), "datadog.process_agent.VerticalPodAutoscalerCondition")
	proto.RegisterType((*VerticalPodAutoscalerSpec)(nil), "datadog.process_agent.VerticalPodAutoscalerSpec")
	proto.RegisterType((*VerticalPodAutoscalerTarget)(nil), "datadog.process_agent.VerticalPodAutoscalerTarget")
	proto.RegisterType((*ContainerResourcePolicy)(nil), "datadog.process_agent.ContainerResourcePolicy")
	proto.RegisterType((*VerticalPodAutoscalerStatus)(nil), "datadog.process_agent.VerticalPodAutoscalerStatus")
	proto.RegisterType((*ContainerRecommendation)(nil), "datadog.process_agent.ContainerRecommendation")
	proto.RegisterType((*VPACondition)(nil), "datadog.process_agent.VPACondition")
	proto.RegisterType((*HorizontalPodAutoscaler)(nil), "datadog.process_agent.HorizontalPodAutoscaler")
	proto.RegisterType((*HorizontalPodAutoscalerSpec)(nil), "datadog.process_agent.HorizontalPodAutoscalerSpec")
	proto.RegisterType((*HorizontalPodAutoscalerTarget)(nil), "datadog.process_agent.HorizontalPodAutoscalerTarget")
	proto.RegisterType((*HorizontalPodAutoscalerMetricSpec)(nil), "datadog.process_agent.HorizontalPodAutoscalerMetricSpec")
	proto.RegisterType((*ObjectMetricSource)(nil), "datadog.process_agent.ObjectMetricSource")
	proto.RegisterType((*MetricTarget)(nil), "datadog.process_agent.MetricTarget")
	proto.RegisterType((*MetricIdentifier)(nil), "datadog.process_agent.MetricIdentifier")
	proto.RegisterType((*PodsMetricSource)(nil), "datadog.process_agent.PodsMetricSource")
	proto.RegisterType((*ResourceMetricSource)(nil), "datadog.process_agent.ResourceMetricSource")
	proto.RegisterType((*ContainerResourceMetricSource)(nil), "datadog.process_agent.ContainerResourceMetricSource")
	proto.RegisterType((*ExternalMetricSource)(nil), "datadog.process_agent.ExternalMetricSource")
	proto.RegisterType((*HorizontalPodAutoscalerBehavior)(nil), "datadog.process_agent.HorizontalPodAutoscalerBehavior")
	proto.RegisterType((*HPAScalingRules)(nil), "datadog.process_agent.HPAScalingRules")
	proto.RegisterType((*HPAScalingPolicy)(nil), "datadog.process_agent.HPAScalingPolicy")
	proto.RegisterType((*HorizontalPodAutoscalerStatus)(nil), "datadog.process_agent.HorizontalPodAutoscalerStatus")
	proto.RegisterType((*HorizontalPodAutoscalerCondition)(nil), "datadog.process_agent.HorizontalPodAutoscalerCondition")
	proto.RegisterType((*HorizontalPodAutoscalerMetricStatus)(nil), "datadog.process_agent.HorizontalPodAutoscalerMetricStatus")
	proto.RegisterType((*ObjectMetricStatus)(nil), "datadog.process_agent.ObjectMetricStatus")
	proto.RegisterType((*PodsMetricStatus)(nil), "datadog.process_agent.PodsMetricStatus")
	proto.RegisterType((*ResourceMetricStatus)(nil), "datadog.process_agent.ResourceMetricStatus")
	proto.RegisterType((*ContainerResourceMetricStatus)(nil), "datadog.process_agent.ContainerResourceMetricStatus")
	proto.RegisterType((*ExternalMetricStatus)(nil), "datadog.process_agent.ExternalMetricStatus")
	proto.RegisterEnum("datadog.process_agent.ContainerHostType", ContainerHostType_name, ContainerHostType_value)
	proto.RegisterEnum("datadog.process_agent.ContainerState", ContainerState_name, ContainerState_value)
	proto.RegisterEnum("datadog.process_agent.ContainerHealth", ContainerHealth_name, ContainerHealth_value)
	proto.RegisterEnum("datadog.process_agent.ProcessState", ProcessState_name, ProcessState_value)
	proto.RegisterEnum("datadog.process_agent.ConnectionType", ConnectionType_name, ConnectionType_value)
	proto.RegisterEnum("datadog.process_agent.K8SResource", K8SResource_name, K8SResource_value)
	proto.RegisterEnum("datadog.process_agent.ResourceRequirementsType", ResourceRequirementsType_name, ResourceRequirementsType_value)
	proto.RegisterEnum("datadog.process_agent.HTTPResponseStatus", HTTPResponseStatus_name, HTTPResponseStatus_value)
	proto.RegisterEnum("datadog.process_agent.HTTPMethod", HTTPMethod_name, HTTPMethod_value)
}
func (m *ResCollector) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResCollector) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Header.Size()))
		n1, err := m.Header.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Message) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n2, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *ResCollector_Header) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResCollector_Header) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Type))
	}
	return i, nil
}

func (m *CollectorProc) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorProc) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.Processes) > 0 {
		for _, msg := range m.Processes {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Host != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n3, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Info != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Info.Size()))
		n4, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.GroupId != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Containers) > 0 {
		for _, msg := range m.Containers {
			data[i] = 0x52
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.NetworkId) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.NetworkId)))
		i += copy(data[i:], m.NetworkId)
	}
	if m.ContainerHostType != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerHostType))
	}
	if m.Hints != nil {
		nn5, err := m.Hints.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *CollectorProc_HintMask) MarshalTo(data []byte) (int, error) {
	i := 0
	data[i] = 0x70
	i++
	i = encodeVarintAgent(data, i, uint64(m.HintMask))
	return i, nil
}
func (m *CollectorProcDiscovery) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorProcDiscovery) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if m.GroupId != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.ProcessDiscoveries) > 0 {
		for _, msg := range m.ProcessDiscoveries {
			data[i] = 0x22
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Host != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n6, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *CollectorRealTime) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorRealTime) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HostId != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.HostId))
	}
	if m.OrgId != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.OrgId))
	}
	if m.GroupId != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if m.NumCpus != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.TotalMemory))
	}
	if len(m.ContainerStats) > 0 {
		for _, msg := range m.ContainerStats {
			data[i] = 0x52
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ContainerHostType != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerHostType))
	}
	return i, nil
}

func (m *CollectorContainer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorContainer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if m.Info != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Info.Size()))
		n7, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Containers) > 0 {
		for _, msg := range m.Containers {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GroupId != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if m.Host != nil {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n8, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ContainerHostType != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerHostType))
	}
	if len(m.NetworkId) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.NetworkId)))
		i += copy(data[i:], m.NetworkId)
	}
	return i, nil
}

func (m *CollectorContainerRealTime) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorContainerRealTime) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NumCpus != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.TotalMemory))
	}
	if m.HostId != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.HostId))
	}
	if m.GroupId != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if m.ContainerHostType != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerHostType))
	}
	return i, nil
}

func (m *CollectorReqStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorReqStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	return i, nil
}

func (m *CollectorPod) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorPod) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.ClusterName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Pods) > 0 {
		for _, msg := range m.Pods {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Host != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n9, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorReplicaSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorReplicaSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.ReplicaSets) > 0 {
		for _, msg := range m.ReplicaSets {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorDeployment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorDeployment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Deployments) > 0 {
		for _, msg := range m.Deployments {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorService) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorService) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Services) > 0 {
		for _, msg := range m.Services {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorNode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorNode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Nodes) > 0 {
		for _, msg := range m.Nodes {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.HostAliasMapping) > 0 {
		for k, _ := range m.HostAliasMapping {
			data[i] = 0x3a
			i++
			v := m.HostAliasMapping[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAgent(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + msgSize
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintAgent(data, i, uint64(v.Size()))
				n10, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n10
			}
		}
	}
	return i, nil
}

func (m *CollectorCluster) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorCluster) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if m.Cluster != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Cluster.Size()))
		n11, err := m.Cluster.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorManifest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorManifest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Manifests) > 0 {
		for _, msg := range m.Manifests {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CollectorManifestCRD) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorManifestCRD) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Manifest != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Manifest.Size()))
		n12, err := m.Manifest.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *CollectorManifestCR) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorManifestCR) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Manifest != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Manifest.Size()))
		n13, err := m.Manifest.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *CollectorNamespace) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorNamespace) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Namespaces) > 0 {
		for _, msg := range m.Namespaces {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorJob) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorJob) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Jobs) > 0 {
		for _, msg := range m.Jobs {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorCronJob) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorCronJob) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.CronJobs) > 0 {
		for _, msg := range m.CronJobs {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorDaemonSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorDaemonSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.DaemonSets) > 0 {
		for _, msg := range m.DaemonSets {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorStatefulSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorStatefulSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.StatefulSets) > 0 {
		for _, msg := range m.StatefulSets {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorPersistentVolume) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorPersistentVolume) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.PersistentVolumes) > 0 {
		for _, msg := range m.PersistentVolumes {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorPersistentVolumeClaim) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorPersistentVolumeClaim) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.PersistentVolumeClaims) > 0 {
		for _, msg := range m.PersistentVolumeClaims {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorRole) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorRole) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Roles) > 0 {
		for _, msg := range m.Roles {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorRoleBinding) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorRoleBinding) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.RoleBindings) > 0 {
		for _, msg := range m.RoleBindings {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorClusterRole) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorClusterRole) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.ClusterRoles) > 0 {
		for _, msg := range m.ClusterRoles {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorClusterRoleBinding) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorClusterRoleBinding) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.ClusterRoleBindings) > 0 {
		for _, msg := range m.ClusterRoleBindings {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorServiceAccount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorServiceAccount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.ServiceAccounts) > 0 {
		for _, msg := range m.ServiceAccounts {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorIngress) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorIngress) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.Ingresses) > 0 {
		for _, msg := range m.Ingresses {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorVerticalPodAutoscaler) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorVerticalPodAutoscaler) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.VerticalPodAutoscalers) > 0 {
		for _, msg := range m.VerticalPodAutoscalers {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorHorizontalPodAutoscaler) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorHorizontalPodAutoscaler) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClusterName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterName)))
		i += copy(data[i:], m.ClusterName)
	}
	if len(m.ClusterId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterId)))
		i += copy(data[i:], m.ClusterId)
	}
	if m.GroupId != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.GroupSize))
	}
	if len(m.HorizontalPodAutoscalers) > 0 {
		for _, msg := range m.HorizontalPodAutoscalers {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CollectorStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActiveClients != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.ActiveClients))
	}
	if m.Interval != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Interval))
	}
	return i, nil
}

func (m *Process) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Process) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Key))
	}
	if m.Pid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pid))
	}
	if m.Host != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n14, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Command != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Command.Size()))
		n15, err := m.Command.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.User != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.User.Size()))
		n16, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Memory != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Memory.Size()))
		n17, err := m.Memory.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Cpu != nil {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(m.Cpu.Size()))
		n18, err := m.Cpu.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.CreateTime != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.CreateTime))
	}
	if m.Container != nil {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(m.Container.Size()))
		n19, err := m.Container.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.OpenFdCount != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.OpenFdCount))
	}
	if m.State != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintAgent(data, i, uint64(m.State))
	}
	if m.IoStat != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintAgent(data, i, uint64(m.IoStat.Size()))
		n20, err := m.IoStat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.ContainerId) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerId)))
		i += copy(data[i:], m.ContainerId)
	}
	if m.ContainerKey != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerKey))
	}
	if m.VoluntaryCtxSwitches != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.InvoluntaryCtxSwitches))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if len(m.ContainerByteKey) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerByteKey)))
		i += copy(data[i:], m.ContainerByteKey)
	}
	if m.NsPid != 0 {
		data[i] = 0xa0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.NsPid))
	}
	if m.Networks != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Networks.Size()))
		n21, err := m.Networks.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *ProcessDiscovery) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessDiscovery) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pid))
	}
	if m.NsPid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.NsPid))
	}
	if m.Host != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n22, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Command != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Command.Size()))
		n23, err := m.Command.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.User != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.User.Size()))
		n24, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.CreateTime != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.CreateTime))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	return i, nil
}

func (m *Command) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Command) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Cwd) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Cwd)))
		i += copy(data[i:], m.Cwd)
	}
	if len(m.Root) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Root)))
		i += copy(data[i:], m.Root)
	}
	if m.OnDisk {
		data[i] = 0x28
		i++
		if m.OnDisk {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Ppid != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Ppid))
	}
	if m.Pgroup != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pgroup))
	}
	if len(m.Exe) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Exe)))
		i += copy(data[i:], m.Exe)
	}
	if len(m.Comm) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Comm)))
		i += copy(data[i:], m.Comm)
	}
	return i, nil
}

func (m *ProcessUser) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessUser) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Uid != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Uid))
	}
	if m.Gid != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Gid))
	}
	if m.Euid != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Euid))
	}
	if m.Egid != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Egid))
	}
	if m.Suid != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Suid))
	}
	if m.Sgid != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Sgid))
	}
	return i, nil
}

func (m *ProcessNetworks) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessNetworks) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConnectionRate != 0 {
		data[i] = 0xd
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ConnectionRate))))
	}
	if m.BytesRate != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.BytesRate))))
	}
	return i, nil
}

func (m *ContainerAddr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerAddr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Ip)))
		i += copy(data[i:], m.Ip)
	}
	if m.Port != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Port))
	}
	if m.Protocol != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Protocol))
	}
	return i, nil
}

func (m *Container) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Container) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Id) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Image) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Image)))
		i += copy(data[i:], m.Image)
	}
	if m.CpuLimit != 0 {
		data[i] = 0x2d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.CpuLimit))))
	}
	if m.MemoryLimit != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemoryLimit))
	}
	if m.State != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.State))
	}
	if m.Health != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.Health))
	}
	if m.Created != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintAgent(data, i, uint64(m.Created))
	}
	if m.Rbps != 0 {
		data[i] = 0x5d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.Rbps))))
	}
	if m.Wbps != 0 {
		data[i] = 0x65
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.Wbps))))
	}
	if m.Key != 0 {
		data[i] = 0x68
		i++
		i = encodeVarintAgent(data, i, uint64(m.Key))
	}
	if m.NetRcvdPs != 0 {
		data[i] = 0x75
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetRcvdPs))))
	}
	if m.NetSentPs != 0 {
		data[i] = 0x7d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetSentPs))))
	}
	if m.NetRcvdBps != 0 {
		data[i] = 0x85
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetRcvdBps))))
	}
	if m.NetSentBps != 0 {
		data[i] = 0x8d
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetSentBps))))
	}
	if m.UserPct != 0 {
		data[i] = 0x95
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.UserPct))))
	}
	if m.SystemPct != 0 {
		data[i] = 0x9d
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.SystemPct))))
	}
	if m.TotalPct != 0 {
		data[i] = 0xa5
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	if m.MemRss != 0 {
		data[i] = 0xa8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemCache))
	}
	if m.Host != nil {
		data[i] = 0xba
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n25, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Started != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Started))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0xca
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0xd2
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Addresses) > 0 {
		for _, msg := range m.Addresses {
			data[i] = 0xda
			i++
			data[i] = 0x1
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ThreadCount != 0 {
		data[i] = 0xe0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.ThreadCount))
	}
	if m.ThreadLimit != 0 {
		data[i] = 0xe8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.ThreadLimit))
	}
	if m.MemUsage != 0 {
		data[i] = 0xf0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemUsage))
	}
	if m.CpuUsageNs != 0 {
		data[i] = 0xfd
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.CpuUsageNs))))
	}
	if m.MemAccounted != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x2
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemAccounted))
	}
	return i, nil
}

func (m *ProcessStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pid))
	}
	if m.CreateTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.CreateTime))
	}
	if m.Memory != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Memory.Size()))
		n26, err := m.Memory.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Cpu != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Cpu.Size()))
		n27, err := m.Cpu.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Nice != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Nice))
	}
	if m.Threads != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Threads))
	}
	if m.OpenFdCount != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.OpenFdCount))
	}
	if m.Key != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.Key))
	}
	if len(m.ContainerId) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerId)))
		i += copy(data[i:], m.ContainerId)
	}
	if m.ContainerState != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerState))
	}
	if m.ProcessState != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintAgent(data, i, uint64(m.ProcessState))
	}
	if m.ContainerHealth != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerHealth))
	}
	if m.ContainerRbps != 0 {
		data[i] = 0x85
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerRbps))))
	}
	if m.ContainerWbps != 0 {
		data[i] = 0x8d
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerWbps))))
	}
	if m.ContainerKey != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerKey))
	}
	if m.IoStat != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.IoStat.Size()))
		n28, err := m.IoStat.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.ContainerNetRcvdPs != 0 {
		data[i] = 0xa5
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerNetRcvdPs))))
	}
	if m.ContainerNetSentPs != 0 {
		data[i] = 0xad
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerNetSentPs))))
	}
	if m.ContainerNetRcvdBps != 0 {
		data[i] = 0xb5
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerNetRcvdBps))))
	}
	if m.ContainerNetSentBps != 0 {
		data[i] = 0xbd
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ContainerNetSentBps))))
	}
	if m.VoluntaryCtxSwitches != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.InvoluntaryCtxSwitches))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0xd2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if len(m.ContainerByteKey) > 0 {
		data[i] = 0xda
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerByteKey)))
		i += copy(data[i:], m.ContainerByteKey)
	}
	if m.Networks != nil {
		data[i] = 0xe2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Networks.Size()))
		n29, err := m.Networks.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *ProcStatsWithPerm) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcStatsWithPerm) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenFDCount != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.OpenFDCount))
	}
	if m.ReadCount != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReadCount))
	}
	if m.WriteCount != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.WriteCount))
	}
	if m.ReadBytes != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReadBytes))
	}
	if m.WriteBytes != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.WriteBytes))
	}
	return i, nil
}

func (m *ProcStatsWithPermByPID) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcStatsWithPermByPID) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StatsByPID) > 0 {
		for k, _ := range m.StatsByPID {
			data[i] = 0xa
			i++
			v := m.StatsByPID[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAgent(uint64(msgSize))
			}
			mapSize := 1 + sovAgent(uint64(k)) + msgSize
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintAgent(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintAgent(data, i, uint64(v.Size()))
				n30, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n30
			}
		}
	}
	return i, nil
}

func (m *ContainerStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.UserPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.UserPct))))
	}
	if m.SystemPct != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.SystemPct))))
	}
	if m.TotalPct != 0 {
		data[i] = 0x25
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	if m.CpuLimit != 0 {
		data[i] = 0x2d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.CpuLimit))))
	}
	if m.MemRss != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemCache))
	}
	if m.MemLimit != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemLimit))
	}
	if m.Rbps != 0 {
		data[i] = 0x4d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.Rbps))))
	}
	if m.Wbps != 0 {
		data[i] = 0x55
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.Wbps))))
	}
	if m.NetRcvdPs != 0 {
		data[i] = 0x5d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetRcvdPs))))
	}
	if m.NetSentPs != 0 {
		data[i] = 0x65
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetSentPs))))
	}
	if m.NetRcvdBps != 0 {
		data[i] = 0x6d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetRcvdBps))))
	}
	if m.NetSentBps != 0 {
		data[i] = 0x75
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.NetSentBps))))
	}
	if m.State != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintAgent(data, i, uint64(m.State))
	}
	if m.Health != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Health))
	}
	if m.Key != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Key))
	}
	if m.Started != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Started))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if m.ThreadCount != 0 {
		data[i] = 0xa0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.ThreadCount))
	}
	if m.ThreadLimit != 0 {
		data[i] = 0xa8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.ThreadLimit))
	}
	if m.MemUsage != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemUsage))
	}
	if m.CpuUsageNs != 0 {
		data[i] = 0xbd
		i++
		data[i] = 0x1
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.CpuUsageNs))))
	}
	if m.MemAccounted != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemAccounted))
	}
	return i, nil
}

func (m *SystemInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SystemInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uuid) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Uuid)))
		i += copy(data[i:], m.Uuid)
	}
	if m.Os != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Os.Size()))
		n31, err := m.Os.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Cpus) > 0 {
		for _, msg := range m.Cpus {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalMemory != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.TotalMemory))
	}
	return i, nil
}

func (m *OSInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OSInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Platform) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Platform)))
		i += copy(data[i:], m.Platform)
	}
	if len(m.Family) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Family)))
		i += copy(data[i:], m.Family)
	}
	if len(m.Version) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.KernelVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.KernelVersion)))
		i += copy(data[i:], m.KernelVersion)
	}
	return i, nil
}

func (m *IOStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IOStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReadRate != 0 {
		data[i] = 0xd
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ReadRate))))
	}
	if m.WriteRate != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.WriteRate))))
	}
	if m.ReadBytesRate != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.ReadBytesRate))))
	}
	if m.WriteBytesRate != 0 {
		data[i] = 0x25
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.WriteBytesRate))))
	}
	return i, nil
}

func (m *MemoryStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MemoryStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rss != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Rss))
	}
	if m.Vms != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Vms))
	}
	if m.Swap != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Swap))
	}
	if m.Shared != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Shared))
	}
	if m.Text != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Text))
	}
	if m.Lib != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Lib))
	}
	if m.Data != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Data))
	}
	if m.Dirty != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.Dirty))
	}
	return i, nil
}

func (m *CPUStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CPUStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LastCpu) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.LastCpu)))
		i += copy(data[i:], m.LastCpu)
	}
	if m.TotalPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	if m.UserPct != 0 {
		data[i] = 0x1d
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.UserPct))))
	}
	if m.SystemPct != 0 {
		data[i] = 0x25
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.SystemPct))))
	}
	if m.NumThreads != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumThreads))
	}
	if len(m.Cpus) > 0 {
		for _, msg := range m.Cpus {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Nice != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Nice))
	}
	if m.UserTime != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.UserTime))
	}
	if m.SystemTime != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.SystemTime))
	}
	return i, nil
}

func (m *SingleCPUStat) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SingleCPUStat) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.TotalPct != 0 {
		data[i] = 0x15
		i++
		i = encodeFixed32Agent(data, i, uint32(math.Float32bits(float32(m.TotalPct))))
	}
	return i, nil
}

func (m *CPUInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CPUInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Number))
	}
	if len(m.Vendor) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Vendor)))
		i += copy(data[i:], m.Vendor)
	}
	if len(m.Family) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Family)))
		i += copy(data[i:], m.Family)
	}
	if len(m.Model) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Model)))
		i += copy(data[i:], m.Model)
	}
	if len(m.PhysicalId) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PhysicalId)))
		i += copy(data[i:], m.PhysicalId)
	}
	if len(m.CoreId) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.CoreId)))
		i += copy(data[i:], m.CoreId)
	}
	if m.Cores != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.Cores))
	}
	if m.Mhz != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.Mhz))
	}
	if m.CacheSize != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.CacheSize))
	}
	return i, nil
}

func (m *Host) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Host) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Id))
	}
	if m.OrgId != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.OrgId))
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.AllTags) > 0 {
		for _, s := range m.AllTags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.NumCpus != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.TotalMemory))
	}
	if m.TagIndex != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.TagIndex))
	}
	if m.TagsModified != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintAgent(data, i, uint64(m.TagsModified))
	}
	return i, nil
}

func (m *Cluster) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Cluster) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeCount != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.NodeCount))
	}
	if len(m.KubeletVersions) > 0 {
		for k, _ := range m.KubeletVersions {
			data[i] = 0x12
			i++
			v := m.KubeletVersions[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if len(m.ApiServerVersions) > 0 {
		for k, _ := range m.ApiServerVersions {
			data[i] = 0x1a
			i++
			v := m.ApiServerVersions[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if m.PodCapacity != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.PodCapacity))
	}
	if m.PodAllocatable != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.PodAllocatable))
	}
	if m.MemoryAllocatable != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemoryAllocatable))
	}
	if m.MemoryCapacity != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.MemoryCapacity))
	}
	if m.CpuAllocatable != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.CpuAllocatable))
	}
	if m.CpuCapacity != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.CpuCapacity))
	}
	if len(m.ResourceVersion) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceVersion)))
		i += copy(data[i:], m.ResourceVersion)
	}
	if m.CreationTimestamp != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.CreationTimestamp))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Metrics != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n32, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *Metadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Metadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	if len(m.Uid) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if m.CreationTimestamp != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.CreationTimestamp))
	}
	if m.DeletionTimestamp != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.DeletionTimestamp))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Annotations) > 0 {
		for _, s := range m.Annotations {
			data[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.OwnerReferences) > 0 {
		for _, msg := range m.OwnerReferences {
			data[i] = 0x42
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ResourceVersion) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceVersion)))
		i += copy(data[i:], m.ResourceVersion)
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			data[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *OwnerReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *OwnerReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Uid) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	return i, nil
}

func (m *ObjectReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ObjectReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Namespace) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Uid) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.ApiVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ApiVersion)))
		i += copy(data[i:], m.ApiVersion)
	}
	if len(m.ResourceVersion) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceVersion)))
		i += copy(data[i:], m.ResourceVersion)
	}
	if len(m.FieldPath) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.FieldPath)))
		i += copy(data[i:], m.FieldPath)
	}
	return i, nil
}

func (m *ServicePort) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServicePort) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Protocol) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Protocol)))
		i += copy(data[i:], m.Protocol)
	}
	if m.Port != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Port))
	}
	if len(m.TargetPort) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.TargetPort)))
		i += copy(data[i:], m.TargetPort)
	}
	if m.NodePort != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.NodePort))
	}
	return i, nil
}

func (m *ServiceSessionAffinityConfig) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServiceSessionAffinityConfig) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClientIPTimeoutSeconds != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.ClientIPTimeoutSeconds))
	}
	return i, nil
}

func (m *Node) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Node) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n33, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.PodCIDR) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PodCIDR)))
		i += copy(data[i:], m.PodCIDR)
	}
	if len(m.PodCIDRs) > 0 {
		for _, s := range m.PodCIDRs {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Unschedulable {
		data[i] = 0x20
		i++
		if m.Unschedulable {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Taints) > 0 {
		for _, msg := range m.Taints {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Status != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n34, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ProviderID) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ProviderID)))
		i += copy(data[i:], m.ProviderID)
	}
	if m.Host != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n35, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.Metrics != nil {
		data[i] = 0x62
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n36, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	return i, nil
}

func (m *NodeStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodeStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Capacity) > 0 {
		for k, _ := range m.Capacity {
			data[i] = 0xa
			i++
			v := m.Capacity[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if len(m.Allocatable) > 0 {
		for k, _ := range m.Allocatable {
			data[i] = 0x12
			i++
			v := m.Allocatable[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if len(m.NodeAddresses) > 0 {
		for k, _ := range m.NodeAddresses {
			data[i] = 0x1a
			i++
			v := m.NodeAddresses[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.Status) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if len(m.KubeletVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.KubeletVersion)))
		i += copy(data[i:], m.KubeletVersion)
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Images) > 0 {
		for _, msg := range m.Images {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.KubeProxyVersion) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.KubeProxyVersion)))
		i += copy(data[i:], m.KubeProxyVersion)
	}
	if len(m.OperatingSystem) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.OperatingSystem)))
		i += copy(data[i:], m.OperatingSystem)
	}
	if len(m.Architecture) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Architecture)))
		i += copy(data[i:], m.Architecture)
	}
	if len(m.KernelVersion) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.KernelVersion)))
		i += copy(data[i:], m.KernelVersion)
	}
	if len(m.OsImage) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.OsImage)))
		i += copy(data[i:], m.OsImage)
	}
	if len(m.ContainerRuntimeVersion) > 0 {
		data[i] = 0x6a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerRuntimeVersion)))
		i += copy(data[i:], m.ContainerRuntimeVersion)
	}
	return i, nil
}

func (m *NodeCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodeCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *ContainerImage) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerImage) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.SizeBytes != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.SizeBytes))
	}
	return i, nil
}

func (m *Taint) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Taint) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if len(m.Effect) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Effect)))
		i += copy(data[i:], m.Effect)
	}
	if m.TimeAdded != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.TimeAdded))
	}
	return i, nil
}

func (m *ServiceSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServiceSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ClusterIP) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ClusterIP)))
		i += copy(data[i:], m.ClusterIP)
	}
	if len(m.Type) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.SessionAffinity) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.SessionAffinity)))
		i += copy(data[i:], m.SessionAffinity)
	}
	if len(m.LoadBalancerIP) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.LoadBalancerIP)))
		i += copy(data[i:], m.LoadBalancerIP)
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ExternalName) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ExternalName)))
		i += copy(data[i:], m.ExternalName)
	}
	if len(m.ExternalTrafficPolicy) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ExternalTrafficPolicy)))
		i += copy(data[i:], m.ExternalTrafficPolicy)
	}
	if m.HealthCheckNodePort != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.HealthCheckNodePort))
	}
	if m.PublishNotReadyAddresses {
		data[i] = 0x60
		i++
		if m.PublishNotReadyAddresses {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SessionAffinityConfig != nil {
		data[i] = 0x6a
		i++
		i = encodeVarintAgent(data, i, uint64(m.SessionAffinityConfig.Size()))
		n37, err := m.SessionAffinityConfig.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if len(m.IpFamily) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.IpFamily)))
		i += copy(data[i:], m.IpFamily)
	}
	return i, nil
}

func (m *ServiceStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServiceStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.LoadBalancerIngress) > 0 {
		for _, s := range m.LoadBalancerIngress {
			data[i] = 0x8a
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Service) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Service) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n38, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n39, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n40, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Metrics != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n41, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	return i, nil
}

func (m *DeploymentCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeploymentCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if m.LastUpdateTime != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastUpdateTime))
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	return i, nil
}

func (m *Deployment) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Deployment) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n42, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.ReplicasDesired != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReplicasDesired))
	}
	if len(m.DeploymentStrategy) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.DeploymentStrategy)))
		i += copy(data[i:], m.DeploymentStrategy)
	}
	if len(m.MaxUnavailable) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.MaxUnavailable)))
		i += copy(data[i:], m.MaxUnavailable)
	}
	if len(m.MaxSurge) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.MaxSurge)))
		i += copy(data[i:], m.MaxSurge)
	}
	if m.Paused {
		data[i] = 0x30
		i++
		if m.Paused {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Replicas != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.Replicas))
	}
	if m.UpdatedReplicas != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintAgent(data, i, uint64(m.UpdatedReplicas))
	}
	if m.ReadyReplicas != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReadyReplicas))
	}
	if m.AvailableReplicas != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintAgent(data, i, uint64(m.AvailableReplicas))
	}
	if m.UnavailableReplicas != 0 {
		data[i] = 0x60
		i++
		i = encodeVarintAgent(data, i, uint64(m.UnavailableReplicas))
	}
	if len(m.ConditionMessage) > 0 {
		data[i] = 0x6a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionMessage)))
		i += copy(data[i:], m.ConditionMessage)
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ResourceRequirements) > 0 {
		for _, msg := range m.ResourceRequirements {
			data[i] = 0x82
			i++
			data[i] = 0x1
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Metrics != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n43, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x92
			i++
			data[i] = 0x1
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReplicaSetCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReplicaSetCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *ReplicaSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReplicaSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n44, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.ReplicasDesired != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReplicasDesired))
	}
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Replicas != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Replicas))
	}
	if m.FullyLabeledReplicas != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.FullyLabeledReplicas))
	}
	if m.ReadyReplicas != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReadyReplicas))
	}
	if m.AvailableReplicas != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.AvailableReplicas))
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ResourceRequirements) > 0 {
		for _, msg := range m.ResourceRequirements {
			data[i] = 0x52
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Metrics != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n45, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x62
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *LabelSelectorRequirement) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LabelSelectorRequirement) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if len(m.Operator) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Operator)))
		i += copy(data[i:], m.Operator)
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Pod) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Pod) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n46, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if len(m.IP) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.IP)))
		i += copy(data[i:], m.IP)
	}
	if len(m.NominatedNodeName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.NominatedNodeName)))
		i += copy(data[i:], m.NominatedNodeName)
	}
	if len(m.NodeName) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.NodeName)))
		i += copy(data[i:], m.NodeName)
	}
	if len(m.Phase) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Phase)))
		i += copy(data[i:], m.Phase)
	}
	if m.RestartCount != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.RestartCount))
	}
	if len(m.ContainerStatuses) > 0 {
		for _, msg := range m.ContainerStatuses {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConditionMessage) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionMessage)))
		i += copy(data[i:], m.ConditionMessage)
	}
	if len(m.Status) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Host != nil {
		data[i] = 0x62
		i++
		i = encodeVarintAgent(data, i, uint64(m.Host.Size()))
		n47, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if len(m.ResourceRequirements) > 0 {
		for _, msg := range m.ResourceRequirements {
			data[i] = 0x6a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.InitContainerStatuses) > 0 {
		for _, msg := range m.InitContainerStatuses {
			data[i] = 0x72
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.QOSClass) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.QOSClass)))
		i += copy(data[i:], m.QOSClass)
	}
	if len(m.PriorityClass) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PriorityClass)))
		i += copy(data[i:], m.PriorityClass)
	}
	if m.Metrics != nil {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n48, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.StartTime != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.StartTime))
	}
	if m.ScheduledTime != 0 {
		data[i] = 0x98
		i++
		data[i] = 0x1
		i++
		i = encodeVarintAgent(data, i, uint64(m.ScheduledTime))
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0xa2
			i++
			data[i] = 0x1
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PodCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PodCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastProbeTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastProbeTime))
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *ContainerStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.ContainerID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerID)))
		i += copy(data[i:], m.ContainerID)
	}
	if m.Ready {
		data[i] = 0x18
		i++
		if m.Ready {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RestartCount != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.RestartCount))
	}
	if len(m.State) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.Message) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *Manifest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Manifest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Type))
	}
	if len(m.ResourceVersion) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceVersion)))
		i += copy(data[i:], m.ResourceVersion)
	}
	if len(m.Uid) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Uid)))
		i += copy(data[i:], m.Uid)
	}
	if len(m.Content) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Content)))
		i += copy(data[i:], m.Content)
	}
	if len(m.ContentType) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContentType)))
		i += copy(data[i:], m.ContentType)
	}
	if len(m.Version) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	return i, nil
}

func (m *NamespaceCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NamespaceCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *Namespace) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Namespace) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n49, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if len(m.ConditionMessage) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionMessage)))
		i += copy(data[i:], m.ConditionMessage)
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ResourceRequirements) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceRequirements) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, _ := range m.Limits {
			data[i] = 0xa
			i++
			v := m.Limits[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if len(m.Requests) > 0 {
		for k, _ := range m.Requests {
			data[i] = 0x12
			i++
			v := m.Requests[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Type != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ResourceMetrics) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceMetrics) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MetricValues) > 0 {
		for k, _ := range m.MetricValues {
			data[i] = 0xa
			i++
			v := m.MetricValues[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + 8
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x11
			i++
			i = encodeFixed64Agent(data, i, uint64(math.Float64bits(float64(v))))
		}
	}
	return i, nil
}

func (m *JobSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *JobSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Parallelism != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Parallelism))
	}
	if m.Completions != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Completions))
	}
	if m.ActiveDeadlineSeconds != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.ActiveDeadlineSeconds))
	}
	if m.BackoffLimit != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.BackoffLimit))
	}
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ManualSelector {
		data[i] = 0x30
		i++
		if m.ManualSelector {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.ResourceRequirements) > 0 {
		for _, msg := range m.ResourceRequirements {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *JobStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *JobStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConditionMessage) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionMessage)))
		i += copy(data[i:], m.ConditionMessage)
	}
	if m.StartTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.StartTime))
	}
	if m.CompletionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.CompletionTime))
	}
	if m.Active != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.Active))
	}
	if m.Succeeded != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Succeeded))
	}
	if m.Failed != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Failed))
	}
	return i, nil
}

func (m *JobCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *JobCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastProbeTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastProbeTime))
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *Job) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Job) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n50, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n51, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n52, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CronJobSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CronJobSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schedule) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Schedule)))
		i += copy(data[i:], m.Schedule)
	}
	if m.StartingDeadlineSeconds != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.StartingDeadlineSeconds))
	}
	if len(m.ConcurrencyPolicy) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConcurrencyPolicy)))
		i += copy(data[i:], m.ConcurrencyPolicy)
	}
	if m.Suspend {
		data[i] = 0x20
		i++
		if m.Suspend {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SuccessfulJobsHistoryLimit != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.SuccessfulJobsHistoryLimit))
	}
	if m.FailedJobsHistoryLimit != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.FailedJobsHistoryLimit))
	}
	if len(m.ResourceRequirements) > 0 {
		for _, msg := range m.ResourceRequirements {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CronJobStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CronJobStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Active) > 0 {
		for _, msg := range m.Active {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.LastScheduleTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastScheduleTime))
	}
	return i, nil
}

func (m *CronJob) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CronJob) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n53, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n54, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n55, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DaemonSetSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DaemonSetSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DeploymentStrategy) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.DeploymentStrategy)))
		i += copy(data[i:], m.DeploymentStrategy)
	}
	if len(m.MaxUnavailable) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.MaxUnavailable)))
		i += copy(data[i:], m.MaxUnavailable)
	}
	if m.MinReadySeconds != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.MinReadySeconds))
	}
	if m.RevisionHistoryLimit != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.RevisionHistoryLimit))
	}
	if len(m.ResourceRequirements) > 0 {
		for _, msg := range m.ResourceRequirements {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DaemonSetStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DaemonSetStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CurrentNumberScheduled != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.CurrentNumberScheduled))
	}
	if m.NumberMisscheduled != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumberMisscheduled))
	}
	if m.DesiredNumberScheduled != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.DesiredNumberScheduled))
	}
	if m.NumberReady != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumberReady))
	}
	if m.UpdatedNumberScheduled != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.UpdatedNumberScheduled))
	}
	if m.NumberAvailable != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumberAvailable))
	}
	if m.NumberUnavailable != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintAgent(data, i, uint64(m.NumberUnavailable))
	}
	return i, nil
}

func (m *DaemonSetCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DaemonSetCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *DaemonSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DaemonSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n56, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n57, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n58, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Metrics != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n59, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StatefulSetSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StatefulSetSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DesiredReplicas != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.DesiredReplicas))
	}
	if len(m.Selectors) > 0 {
		for _, msg := range m.Selectors {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ServiceName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ServiceName)))
		i += copy(data[i:], m.ServiceName)
	}
	if len(m.PodManagementPolicy) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PodManagementPolicy)))
		i += copy(data[i:], m.PodManagementPolicy)
	}
	if len(m.UpdateStrategy) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.UpdateStrategy)))
		i += copy(data[i:], m.UpdateStrategy)
	}
	if m.Partition != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintAgent(data, i, uint64(m.Partition))
	}
	if len(m.ResourceRequirements) > 0 {
		for _, msg := range m.ResourceRequirements {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *StatefulSetStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StatefulSetStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Replicas != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Replicas))
	}
	if m.ReadyReplicas != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.ReadyReplicas))
	}
	if m.CurrentReplicas != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.CurrentReplicas))
	}
	if m.UpdatedReplicas != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.UpdatedReplicas))
	}
	return i, nil
}

func (m *StatefulSetCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StatefulSetCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *StatefulSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *StatefulSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n60, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n61, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n62, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Metrics != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n63, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x3a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PersistentVolume) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolume) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n64, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n65, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n66, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *PersistentVolumeSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolumeSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Capacity) > 0 {
		for k, _ := range m.Capacity {
			data[i] = 0xa
			i++
			v := m.Capacity[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if len(m.PersistentVolumeType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PersistentVolumeType)))
		i += copy(data[i:], m.PersistentVolumeType)
	}
	if len(m.AccessModes) > 0 {
		for _, s := range m.AccessModes {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.ClaimRef != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.ClaimRef.Size()))
		n67, err := m.ClaimRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if len(m.PersistentVolumeReclaimPolicy) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PersistentVolumeReclaimPolicy)))
		i += copy(data[i:], m.PersistentVolumeReclaimPolicy)
	}
	if len(m.StorageClassName) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.StorageClassName)))
		i += copy(data[i:], m.StorageClassName)
	}
	if len(m.MountOptions) > 0 {
		for _, s := range m.MountOptions {
			data[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.VolumeMode) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.VolumeMode)))
		i += copy(data[i:], m.VolumeMode)
	}
	if len(m.NodeAffinity) > 0 {
		for _, msg := range m.NodeAffinity {
			data[i] = 0x4a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PersistentVolumeSource != nil {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(m.PersistentVolumeSource.Size()))
		n68, err := m.PersistentVolumeSource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *PersistentVolumeSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolumeSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GcePersistentDisk != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.GcePersistentDisk.Size()))
		n69, err := m.GcePersistentDisk.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.AwsElasticBlockStore != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.AwsElasticBlockStore.Size()))
		n70, err := m.AwsElasticBlockStore.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.AzureFile != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.AzureFile.Size()))
		n71, err := m.AzureFile.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	if m.AzureDisk != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.AzureDisk.Size()))
		n72, err := m.AzureDisk.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	if m.Csi != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Csi.Size()))
		n73, err := m.Csi.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	return i, nil
}

func (m *GCEPersistentDiskVolumeSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GCEPersistentDiskVolumeSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PdName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PdName)))
		i += copy(data[i:], m.PdName)
	}
	if len(m.FsType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.FsType)))
		i += copy(data[i:], m.FsType)
	}
	if m.Partition != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Partition))
	}
	if m.ReadOnly {
		data[i] = 0x20
		i++
		if m.ReadOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AWSElasticBlockStoreVolumeSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AWSElasticBlockStoreVolumeSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.VolumeID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.VolumeID)))
		i += copy(data[i:], m.VolumeID)
	}
	if len(m.FsType) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.FsType)))
		i += copy(data[i:], m.FsType)
	}
	if m.Partition != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Partition))
	}
	if m.ReadOnly {
		data[i] = 0x20
		i++
		if m.ReadOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AzureFilePersistentVolumeSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AzureFilePersistentVolumeSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecretName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.SecretName)))
		i += copy(data[i:], m.SecretName)
	}
	if len(m.ShareName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ShareName)))
		i += copy(data[i:], m.ShareName)
	}
	if m.ReadOnly {
		data[i] = 0x18
		i++
		if m.ReadOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.SecretNamespace) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.SecretNamespace)))
		i += copy(data[i:], m.SecretNamespace)
	}
	return i, nil
}

func (m *AzureDiskVolumeSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AzureDiskVolumeSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DiskName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.DiskName)))
		i += copy(data[i:], m.DiskName)
	}
	if len(m.DiskURI) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.DiskURI)))
		i += copy(data[i:], m.DiskURI)
	}
	if len(m.CachingMode) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.CachingMode)))
		i += copy(data[i:], m.CachingMode)
	}
	if len(m.FsType) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.FsType)))
		i += copy(data[i:], m.FsType)
	}
	if m.ReadOnly {
		data[i] = 0x28
		i++
		if m.ReadOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Kind) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	return i, nil
}

func (m *CSIVolumeSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CSIVolumeSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Driver) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Driver)))
		i += copy(data[i:], m.Driver)
	}
	if len(m.VolumeHandle) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.VolumeHandle)))
		i += copy(data[i:], m.VolumeHandle)
	}
	if m.ReadOnly {
		data[i] = 0x18
		i++
		if m.ReadOnly {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.FsType) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.FsType)))
		i += copy(data[i:], m.FsType)
	}
	if len(m.VolumeAttributes) > 0 {
		for k, _ := range m.VolumeAttributes {
			data[i] = 0x2a
			i++
			v := m.VolumeAttributes[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if m.ControllerPublishSecretRef != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.ControllerPublishSecretRef.Size()))
		n74, err := m.ControllerPublishSecretRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	if m.NodeStageSecretRef != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(m.NodeStageSecretRef.Size()))
		n75, err := m.NodeStageSecretRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.NodePublishSecretRef != nil {
		data[i] = 0x42
		i++
		i = encodeVarintAgent(data, i, uint64(m.NodePublishSecretRef.Size()))
		n76, err := m.NodePublishSecretRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	if m.ControllerExpandSecretRef != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintAgent(data, i, uint64(m.ControllerExpandSecretRef.Size()))
		n77, err := m.ControllerExpandSecretRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	if m.NodeExpandSecretRef != nil {
		data[i] = 0x52
		i++
		i = encodeVarintAgent(data, i, uint64(m.NodeExpandSecretRef.Size()))
		n78, err := m.NodeExpandSecretRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *SecretReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SecretReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	return i, nil
}

func (m *PersistentVolumeStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolumeStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Phase)))
		i += copy(data[i:], m.Phase)
	}
	if len(m.Message) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if len(m.Reason) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	return i, nil
}

func (m *NodeSelectorTerm) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodeSelectorTerm) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MatchExpressions) > 0 {
		for _, msg := range m.MatchExpressions {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MatchFields) > 0 {
		for _, msg := range m.MatchFields {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PersistentVolumeClaim) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolumeClaim) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n79, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n80, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n81, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *PersistentVolumeClaimStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolumeClaimStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Phase) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Phase)))
		i += copy(data[i:], m.Phase)
	}
	if len(m.AccessModes) > 0 {
		for _, s := range m.AccessModes {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Capacity) > 0 {
		for k, _ := range m.Capacity {
			data[i] = 0x1a
			i++
			v := m.Capacity[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintAgent(data, i, uint64(v))
		}
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x22
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PersistentVolumeClaimSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolumeClaimSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccessModes) > 0 {
		for _, s := range m.AccessModes {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Resources != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Resources.Size()))
		n82, err := m.Resources.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if len(m.VolumeName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.VolumeName)))
		i += copy(data[i:], m.VolumeName)
	}
	if len(m.Selector) > 0 {
		for _, msg := range m.Selector {
			data[i] = 0x22
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StorageClassName) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.StorageClassName)))
		i += copy(data[i:], m.StorageClassName)
	}
	if len(m.VolumeMode) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.VolumeMode)))
		i += copy(data[i:], m.VolumeMode)
	}
	if m.DataSource != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintAgent(data, i, uint64(m.DataSource.Size()))
		n83, err := m.DataSource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *TypedLocalObjectReference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TypedLocalObjectReference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ApiGroup) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ApiGroup)))
		i += copy(data[i:], m.ApiGroup)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *PersistentVolumeClaimCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PersistentVolumeClaimCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastProbeTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastProbeTime))
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *PolicyRule) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PolicyRule) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Verbs) > 0 {
		for _, s := range m.Verbs {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ApiGroups) > 0 {
		for _, s := range m.ApiGroups {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Resources) > 0 {
		for _, s := range m.Resources {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ResourceNames) > 0 {
		for _, s := range m.ResourceNames {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.NonResourceURLs) > 0 {
		for _, s := range m.NonResourceURLs {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Subject) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Subject) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.ApiGroup) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ApiGroup)))
		i += copy(data[i:], m.ApiGroup)
	}
	if len(m.Name) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Namespace) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Namespace)))
		i += copy(data[i:], m.Namespace)
	}
	return i, nil
}

func (m *Role) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Role) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n84, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *RoleBinding) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RoleBinding) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n85, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	if len(m.Subjects) > 0 {
		for _, msg := range m.Subjects {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RoleRef != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.RoleRef.Size()))
		n86, err := m.RoleRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *ClusterRole) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClusterRole) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n87, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AggregationRules) > 0 {
		for _, msg := range m.AggregationRules {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.Metrics != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metrics.Size()))
		n88, err := m.Metrics.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	return i, nil
}

func (m *ClusterRoleBinding) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClusterRoleBinding) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n89, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if len(m.Subjects) > 0 {
		for _, msg := range m.Subjects {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RoleRef != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.RoleRef.Size()))
		n90, err := m.RoleRef.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *ServiceAccount) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ServiceAccount) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n91, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if len(m.Secrets) > 0 {
		for _, msg := range m.Secrets {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, msg := range m.ImagePullSecrets {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AutomountServiceAccountToken {
		data[i] = 0x20
		i++
		if m.AutomountServiceAccountToken {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *IngressServiceBackend) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IngressServiceBackend) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServiceName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ServiceName)))
		i += copy(data[i:], m.ServiceName)
	}
	if len(m.PortName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PortName)))
		i += copy(data[i:], m.PortName)
	}
	if m.PortNumber != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.PortNumber))
	}
	return i, nil
}

func (m *IngressBackend) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IngressBackend) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Service != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Service.Size()))
		n92, err := m.Service.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.Resource != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Resource.Size()))
		n93, err := m.Resource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	return i, nil
}

func (m *IngressTLS) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IngressTLS) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.SecretName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.SecretName)))
		i += copy(data[i:], m.SecretName)
	}
	return i, nil
}

func (m *HTTPIngressPath) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HTTPIngressPath) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Backend != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Backend.Size()))
		n94, err := m.Backend.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	if len(m.PathType) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.PathType)))
		i += copy(data[i:], m.PathType)
	}
	return i, nil
}

func (m *IngressRule) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IngressRule) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Host)))
		i += copy(data[i:], m.Host)
	}
	if len(m.HttpPaths) > 0 {
		for _, msg := range m.HttpPaths {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IngressSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IngressSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DefaultBackend != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.DefaultBackend.Size()))
		n95, err := m.DefaultBackend.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n95
	}
	if len(m.Tls) > 0 {
		for _, msg := range m.Tls {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.IngressClassName) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.IngressClassName)))
		i += copy(data[i:], m.IngressClassName)
	}
	return i, nil
}

func (m *PortStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PortStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Port))
	}
	if len(m.Protocol) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Protocol)))
		i += copy(data[i:], m.Protocol)
	}
	if len(m.Error) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Error)))
		i += copy(data[i:], m.Error)
	}
	return i, nil
}

func (m *LoadBalancerIngress) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *LoadBalancerIngress) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Ip)))
		i += copy(data[i:], m.Ip)
	}
	if len(m.Hostname) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Hostname)))
		i += copy(data[i:], m.Hostname)
	}
	if len(m.Ports) > 0 {
		for _, msg := range m.Ports {
			data[i] = 0x22
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IngressStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IngressStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, msg := range m.Ingress {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Ingress) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Ingress) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n96, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n96
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n97, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n97
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n98, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n98
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *KafkaRequestHeader) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *KafkaRequestHeader) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RequestType != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.RequestType))
	}
	if m.RequestVersion != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.RequestVersion))
	}
	return i, nil
}

func (m *KafkaAggregation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *KafkaAggregation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Header != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Header.Size()))
		n99, err := m.Header.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n99
	}
	if len(m.Topic) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Topic)))
		i += copy(data[i:], m.Topic)
	}
	if m.Count != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *DataStreamsAggregations) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DataStreamsAggregations) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KafkaProduceAggregations != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.KafkaProduceAggregations.Size()))
		n100, err := m.KafkaProduceAggregations.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n100
	}
	if m.KafkaFetchAggregations != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.KafkaFetchAggregations.Size()))
		n101, err := m.KafkaFetchAggregations.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n101
	}
	if len(m.KafkaAggregations) > 0 {
		for _, msg := range m.KafkaAggregations {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataStreamsAggregations_TopicStats) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DataStreamsAggregations_TopicStats) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Topic) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Topic)))
		i += copy(data[i:], m.Topic)
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *DataStreamsAggregations_KafkaProduceAggregations) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DataStreamsAggregations_KafkaProduceAggregations) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DataStreamsAggregations_KafkaFetchAggregations) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DataStreamsAggregations_KafkaFetchAggregations) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, msg := range m.Stats {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HTTPAggregations) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HTTPAggregations) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EndpointAggregations) > 0 {
		for _, msg := range m.EndpointAggregations {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HTTP2Aggregations) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HTTP2Aggregations) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EndpointAggregations) > 0 {
		for _, msg := range m.EndpointAggregations {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HTTPStats) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HTTPStats) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StatsByResponseStatus) > 0 {
		for _, msg := range m.StatsByResponseStatus {
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.StatsByStatusCode) > 0 {
		for k, _ := range m.StatsByStatusCode {
			data[i] = 0x12
			i++
			v := m.StatsByStatusCode[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovAgent(uint64(msgSize))
			}
			mapSize := 1 + sovAgent(uint64(k)) + msgSize
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintAgent(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintAgent(data, i, uint64(v.Size()))
				n102, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n102
			}
		}
	}
	if len(m.Path) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if m.Method != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgent(data, i, uint64(m.Method))
	}
	if m.FullPath {
		data[i] = 0x30
		i++
		if m.FullPath {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *HTTPStats_Data) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HTTPStats_Data) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.Count))
	}
	if len(m.Latencies) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Latencies)))
		i += copy(data[i:], m.Latencies)
	}
	if m.FirstLatencySample != 0 {
		data[i] = 0x21
		i++
		i = encodeFixed64Agent(data, i, uint64(math.Float64bits(float64(m.FirstLatencySample))))
	}
	return i, nil
}

func (m *DNSDatabaseEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DNSDatabaseEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NameOffsets) > 0 {
		for _, num := range m.NameOffsets {
			data[i] = 0x8
			i++
			i = encodeVarintAgent(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *ResourceList) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceList) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MetricValues) > 0 {
		for k, _ := range m.MetricValues {
			data[i] = 0xa
			i++
			v := m.MetricValues[k]
			mapSize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + 8
			i = encodeVarintAgent(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgent(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x11
			i++
			i = encodeFixed64Agent(data, i, uint64(math.Float64bits(float64(v))))
		}
	}
	return i, nil
}

func (m *VerticalPodAutoscaler) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VerticalPodAutoscaler) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n103, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n103
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n104, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n104
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n105, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n105
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VerticalPodAutoscalerCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VerticalPodAutoscalerCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if len(m.Status) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *VerticalPodAutoscalerSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VerticalPodAutoscalerSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n106, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n106
	}
	if len(m.UpdateMode) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.UpdateMode)))
		i += copy(data[i:], m.UpdateMode)
	}
	if len(m.ResourcePolicies) > 0 {
		for _, msg := range m.ResourcePolicies {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *VerticalPodAutoscalerTarget) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VerticalPodAutoscalerTarget) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *ContainerResourcePolicy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerResourcePolicy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerName)))
		i += copy(data[i:], m.ContainerName)
	}
	if len(m.Mode) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Mode)))
		i += copy(data[i:], m.Mode)
	}
	if m.MinAllowed != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.MinAllowed.Size()))
		n107, err := m.MinAllowed.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n107
	}
	if m.MaxAllowed != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.MaxAllowed.Size()))
		n108, err := m.MaxAllowed.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n108
	}
	if len(m.ControlledResource) > 0 {
		for _, s := range m.ControlledResource {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ControlledValues) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ControlledValues)))
		i += copy(data[i:], m.ControlledValues)
	}
	return i, nil
}

func (m *VerticalPodAutoscalerStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VerticalPodAutoscalerStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastRecommendedDate != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastRecommendedDate))
	}
	if len(m.Recommendations) > 0 {
		for _, msg := range m.Recommendations {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ContainerRecommendation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerRecommendation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ContainerName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ContainerName)))
		i += copy(data[i:], m.ContainerName)
	}
	if m.Target != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n109, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n109
	}
	if m.LowerBound != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.LowerBound.Size()))
		n110, err := m.LowerBound.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n110
	}
	if m.UpperBound != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.UpperBound.Size()))
		n111, err := m.UpperBound.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n111
	}
	if m.UncappedTarget != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.UncappedTarget.Size()))
		n112, err := m.UncappedTarget.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n112
	}
	return i, nil
}

func (m *VPACondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VPACondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConditionType) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionType)))
		i += copy(data[i:], m.ConditionType)
	}
	if len(m.ConditionStatus) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionStatus)))
		i += copy(data[i:], m.ConditionStatus)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *HorizontalPodAutoscaler) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscaler) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metadata.Size()))
		n113, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n113
	}
	if m.Spec != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Spec.Size()))
		n114, err := m.Spec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n114
	}
	if m.Status != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Status.Size()))
		n115, err := m.Status.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n115
	}
	if len(m.Yaml) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Yaml)))
		i += copy(data[i:], m.Yaml)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Conditions) > 0 {
		for _, msg := range m.Conditions {
			data[i] = 0x32
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HorizontalPodAutoscalerSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscalerSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n116, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n116
	}
	if m.MinReplicas != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.MinReplicas))
	}
	if m.MaxReplicas != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.MaxReplicas))
	}
	if len(m.Metrics) > 0 {
		for _, msg := range m.Metrics {
			data[i] = 0x22
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Behavior != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Behavior.Size()))
		n117, err := m.Behavior.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n117
	}
	return i, nil
}

func (m *HorizontalPodAutoscalerTarget) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscalerTarget) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	return i, nil
}

func (m *HorizontalPodAutoscalerMetricSpec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscalerMetricSpec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Object != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Object.Size()))
		n118, err := m.Object.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n118
	}
	if m.Pods != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pods.Size()))
		n119, err := m.Pods.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n119
	}
	if m.Resource != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Resource.Size()))
		n120, err := m.Resource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n120
	}
	if m.ContainerResource != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerResource.Size()))
		n121, err := m.ContainerResource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n121
	}
	if m.External != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.External.Size()))
		n122, err := m.External.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n122
	}
	return i, nil
}

func (m *ObjectMetricSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ObjectMetricSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DescribedObject != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.DescribedObject.Size()))
		n123, err := m.DescribedObject.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n123
	}
	if m.Target != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n124, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n124
	}
	if m.Metric != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metric.Size()))
		n125, err := m.Metric.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n125
	}
	return i, nil
}

func (m *MetricTarget) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MetricTarget) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Value))
	}
	return i, nil
}

func (m *MetricIdentifier) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MetricIdentifier) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.LabelSelector) > 0 {
		for _, msg := range m.LabelSelector {
			data[i] = 0x12
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PodsMetricSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PodsMetricSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metric != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metric.Size()))
		n126, err := m.Metric.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n126
	}
	if m.Target != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n127, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n127
	}
	return i, nil
}

func (m *ResourceMetricSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceMetricSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceName)))
		i += copy(data[i:], m.ResourceName)
	}
	if m.Target != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n128, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n128
	}
	return i, nil
}

func (m *ContainerResourceMetricSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerResourceMetricSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceName)))
		i += copy(data[i:], m.ResourceName)
	}
	if m.Target != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n129, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n129
	}
	if len(m.Container) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Container)))
		i += copy(data[i:], m.Container)
	}
	return i, nil
}

func (m *ExternalMetricSource) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExternalMetricSource) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metric != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metric.Size()))
		n130, err := m.Metric.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n130
	}
	if m.Target != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Target.Size()))
		n131, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n131
	}
	return i, nil
}

func (m *HorizontalPodAutoscalerBehavior) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscalerBehavior) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ScaleUp != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.ScaleUp.Size()))
		n132, err := m.ScaleUp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n132
	}
	if m.ScaleDown != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.ScaleDown.Size()))
		n133, err := m.ScaleDown.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n133
	}
	return i, nil
}

func (m *HPAScalingRules) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HPAScalingRules) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StabilizationWindowSeconds != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.StabilizationWindowSeconds))
	}
	if len(m.SelectPolicy) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.SelectPolicy)))
		i += copy(data[i:], m.SelectPolicy)
	}
	if len(m.Policies) > 0 {
		for _, msg := range m.Policies {
			data[i] = 0x1a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HPAScalingPolicy) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HPAScalingPolicy) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Value != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Value))
	}
	if m.PeriodSeconds != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.PeriodSeconds))
	}
	return i, nil
}

func (m *HorizontalPodAutoscalerStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscalerStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObservedGeneration != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgent(data, i, uint64(m.ObservedGeneration))
	}
	if m.LastScaleTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastScaleTime))
	}
	if m.CurrentReplicas != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.CurrentReplicas))
	}
	if m.DesiredReplicas != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgent(data, i, uint64(m.DesiredReplicas))
	}
	if len(m.CurrentMetrics) > 0 {
		for _, msg := range m.CurrentMetrics {
			data[i] = 0x2a
			i++
			i = encodeVarintAgent(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HorizontalPodAutoscalerCondition) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscalerCondition) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ConditionType) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionType)))
		i += copy(data[i:], m.ConditionType)
	}
	if len(m.ConditionStatus) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ConditionStatus)))
		i += copy(data[i:], m.ConditionStatus)
	}
	if m.LastTransitionTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgent(data, i, uint64(m.LastTransitionTime))
	}
	if len(m.Reason) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Reason)))
		i += copy(data[i:], m.Reason)
	}
	if len(m.Message) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func (m *HorizontalPodAutoscalerMetricStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HorizontalPodAutoscalerMetricStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Object != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAgent(data, i, uint64(m.Object.Size()))
		n134, err := m.Object.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n134
	}
	if m.Pods != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Pods.Size()))
		n135, err := m.Pods.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n135
	}
	if m.Resource != nil {
		data[i] = 0x22
		i++
		i = encodeVarintAgent(data, i, uint64(m.Resource.Size()))
		n136, err := m.Resource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n136
	}
	if m.ContainerResource != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintAgent(data, i, uint64(m.ContainerResource.Size()))
		n137, err := m.ContainerResource.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n137
	}
	if m.External != nil {
		data[i] = 0x32
		i++
		i = encodeVarintAgent(data, i, uint64(m.External.Size()))
		n138, err := m.External.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n138
	}
	return i, nil
}

func (m *ObjectMetricStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ObjectMetricStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DescribedObject != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.DescribedObject.Size()))
		n139, err := m.DescribedObject.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n139
	}
	if m.Current != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Current))
	}
	if m.Metric != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metric.Size()))
		n140, err := m.Metric.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n140
	}
	return i, nil
}

func (m *PodsMetricStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PodsMetricStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metric != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metric.Size()))
		n141, err := m.Metric.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n141
	}
	if m.Current != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Current))
	}
	return i, nil
}

func (m *ResourceMetricStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceMetricStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceName)))
		i += copy(data[i:], m.ResourceName)
	}
	if m.Current != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Current))
	}
	return i, nil
}

func (m *ContainerResourceMetricStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ContainerResourceMetricStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ResourceName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.ResourceName)))
		i += copy(data[i:], m.ResourceName)
	}
	if m.Current != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Current))
	}
	if len(m.Container) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgent(data, i, uint64(len(m.Container)))
		i += copy(data[i:], m.Container)
	}
	return i, nil
}

func (m *ExternalMetricStatus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExternalMetricStatus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metric != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAgent(data, i, uint64(m.Metric.Size()))
		n142, err := m.Metric.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n142
	}
	if m.Current != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgent(data, i, uint64(m.Current))
	}
	return i, nil
}

func encodeFixed64Agent(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Agent(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAgent(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *ResCollector) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ResCollector_Header) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgent(uint64(m.Type))
	}
	return n
}

func (m *CollectorProc) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Processes) > 0 {
		for _, e := range m.Processes {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerHostType != 0 {
		n += 1 + sovAgent(uint64(m.ContainerHostType))
	}
	if m.Hints != nil {
		n += m.Hints.Size()
	}
	return n
}

func (m *CollectorProc_HintMask) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovAgent(uint64(m.HintMask))
	return n
}
func (m *CollectorProcDiscovery) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.ProcessDiscoveries) > 0 {
		for _, e := range m.ProcessDiscoveries {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorRealTime) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.HostId != 0 {
		n += 1 + sovAgent(uint64(m.HostId))
	}
	if m.OrgId != 0 {
		n += 1 + sovAgent(uint64(m.OrgId))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	if len(m.ContainerStats) > 0 {
		for _, e := range m.ContainerStats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.ContainerHostType != 0 {
		n += 1 + sovAgent(uint64(m.ContainerHostType))
	}
	return n
}

func (m *CollectorContainer) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Containers) > 0 {
		for _, e := range m.Containers {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerHostType != 0 {
		n += 1 + sovAgent(uint64(m.ContainerHostType))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorContainerRealTime) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	if m.HostId != 0 {
		n += 1 + sovAgent(uint64(m.HostId))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.ContainerHostType != 0 {
		n += 1 + sovAgent(uint64(m.ContainerHostType))
	}
	return n
}

func (m *CollectorReqStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorPod) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Pods) > 0 {
		for _, e := range m.Pods {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorReplicaSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.ReplicaSets) > 0 {
		for _, e := range m.ReplicaSets {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorDeployment) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Deployments) > 0 {
		for _, e := range m.Deployments {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorService) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Services) > 0 {
		for _, e := range m.Services {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.HostAliasMapping) > 0 {
		for k, v := range m.HostAliasMapping {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAgent(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CollectorCluster) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if m.Cluster != nil {
		l = m.Cluster.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorManifest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Manifests) > 0 {
		for _, e := range m.Manifests {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorManifestCRD) Size() (n int) {
	var l int
	_ = l
	if m.Manifest != nil {
		l = m.Manifest.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorManifestCR) Size() (n int) {
	var l int
	_ = l
	if m.Manifest != nil {
		l = m.Manifest.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CollectorNamespace) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Namespaces) > 0 {
		for _, e := range m.Namespaces {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorJob) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorCronJob) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.CronJobs) > 0 {
		for _, e := range m.CronJobs {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorDaemonSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.DaemonSets) > 0 {
		for _, e := range m.DaemonSets {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorStatefulSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.StatefulSets) > 0 {
		for _, e := range m.StatefulSets {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorPersistentVolume) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.PersistentVolumes) > 0 {
		for _, e := range m.PersistentVolumes {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorPersistentVolumeClaim) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.PersistentVolumeClaims) > 0 {
		for _, e := range m.PersistentVolumeClaims {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Roles) > 0 {
		for _, e := range m.Roles {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorRoleBinding) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.RoleBindings) > 0 {
		for _, e := range m.RoleBindings {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorClusterRole) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.ClusterRoles) > 0 {
		for _, e := range m.ClusterRoles {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorClusterRoleBinding) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.ClusterRoleBindings) > 0 {
		for _, e := range m.ClusterRoleBindings {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorServiceAccount) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.ServiceAccounts) > 0 {
		for _, e := range m.ServiceAccounts {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorIngress) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.Ingresses) > 0 {
		for _, e := range m.Ingresses {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorVerticalPodAutoscaler) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.VerticalPodAutoscalers) > 0 {
		for _, e := range m.VerticalPodAutoscalers {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorHorizontalPodAutoscaler) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.GroupId != 0 {
		n += 1 + sovAgent(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovAgent(uint64(m.GroupSize))
	}
	if len(m.HorizontalPodAutoscalers) > 0 {
		for _, e := range m.HorizontalPodAutoscalers {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CollectorStatus) Size() (n int) {
	var l int
	_ = l
	if m.ActiveClients != 0 {
		n += 1 + sovAgent(uint64(m.ActiveClients))
	}
	if m.Interval != 0 {
		n += 1 + sovAgent(uint64(m.Interval))
	}
	return n
}

func (m *Process) Size() (n int) {
	var l int
	_ = l
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAgent(uint64(m.CreateTime))
	}
	if m.Container != nil {
		l = m.Container.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovAgent(uint64(m.OpenFdCount))
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerKey != 0 {
		n += 1 + sovAgent(uint64(m.ContainerKey))
	}
	if m.VoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.InvoluntaryCtxSwitches))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.NsPid != 0 {
		n += 2 + sovAgent(uint64(m.NsPid))
	}
	if m.Networks != nil {
		l = m.Networks.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ProcessDiscovery) Size() (n int) {
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.NsPid != 0 {
		n += 1 + sovAgent(uint64(m.NsPid))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAgent(uint64(m.CreateTime))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Command) Size() (n int) {
	var l int
	_ = l
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.Cwd)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.OnDisk {
		n += 2
	}
	if m.Ppid != 0 {
		n += 1 + sovAgent(uint64(m.Ppid))
	}
	if m.Pgroup != 0 {
		n += 1 + sovAgent(uint64(m.Pgroup))
	}
	l = len(m.Exe)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Comm)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ProcessUser) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovAgent(uint64(m.Uid))
	}
	if m.Gid != 0 {
		n += 1 + sovAgent(uint64(m.Gid))
	}
	if m.Euid != 0 {
		n += 1 + sovAgent(uint64(m.Euid))
	}
	if m.Egid != 0 {
		n += 1 + sovAgent(uint64(m.Egid))
	}
	if m.Suid != 0 {
		n += 1 + sovAgent(uint64(m.Suid))
	}
	if m.Sgid != 0 {
		n += 1 + sovAgent(uint64(m.Sgid))
	}
	return n
}

func (m *ProcessNetworks) Size() (n int) {
	var l int
	_ = l
	if m.ConnectionRate != 0 {
		n += 5
	}
	if m.BytesRate != 0 {
		n += 5
	}
	return n
}

func (m *ContainerAddr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovAgent(uint64(m.Port))
	}
	if m.Protocol != 0 {
		n += 1 + sovAgent(uint64(m.Protocol))
	}
	return n
}

func (m *Container) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CpuLimit != 0 {
		n += 5
	}
	if m.MemoryLimit != 0 {
		n += 1 + sovAgent(uint64(m.MemoryLimit))
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.Health != 0 {
		n += 1 + sovAgent(uint64(m.Health))
	}
	if m.Created != 0 {
		n += 1 + sovAgent(uint64(m.Created))
	}
	if m.Rbps != 0 {
		n += 5
	}
	if m.Wbps != 0 {
		n += 5
	}
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	if m.NetRcvdPs != 0 {
		n += 5
	}
	if m.NetSentPs != 0 {
		n += 5
	}
	if m.NetRcvdBps != 0 {
		n += 6
	}
	if m.NetSentBps != 0 {
		n += 6
	}
	if m.UserPct != 0 {
		n += 6
	}
	if m.SystemPct != 0 {
		n += 6
	}
	if m.TotalPct != 0 {
		n += 6
	}
	if m.MemRss != 0 {
		n += 2 + sovAgent(uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		n += 2 + sovAgent(uint64(m.MemCache))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.Started != 0 {
		n += 2 + sovAgent(uint64(m.Started))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Addresses) > 0 {
		for _, e := range m.Addresses {
			l = e.Size()
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	if m.ThreadCount != 0 {
		n += 2 + sovAgent(uint64(m.ThreadCount))
	}
	if m.ThreadLimit != 0 {
		n += 2 + sovAgent(uint64(m.ThreadLimit))
	}
	if m.MemUsage != 0 {
		n += 2 + sovAgent(uint64(m.MemUsage))
	}
	if m.CpuUsageNs != 0 {
		n += 6
	}
	if m.MemAccounted != 0 {
		n += 2 + sovAgent(uint64(m.MemAccounted))
	}
	return n
}

func (m *ProcessStat) Size() (n int) {
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovAgent(uint64(m.Pid))
	}
	if m.CreateTime != 0 {
		n += 1 + sovAgent(uint64(m.CreateTime))
	}
	if m.Memory != nil {
		l = m.Memory.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cpu != nil {
		l = m.Cpu.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Nice != 0 {
		n += 1 + sovAgent(uint64(m.Nice))
	}
	if m.Threads != 0 {
		n += 1 + sovAgent(uint64(m.Threads))
	}
	if m.OpenFdCount != 0 {
		n += 1 + sovAgent(uint64(m.OpenFdCount))
	}
	if m.Key != 0 {
		n += 1 + sovAgent(uint64(m.Key))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerState != 0 {
		n += 1 + sovAgent(uint64(m.ContainerState))
	}
	if m.ProcessState != 0 {
		n += 1 + sovAgent(uint64(m.ProcessState))
	}
	if m.ContainerHealth != 0 {
		n += 1 + sovAgent(uint64(m.ContainerHealth))
	}
	if m.ContainerRbps != 0 {
		n += 6
	}
	if m.ContainerWbps != 0 {
		n += 6
	}
	if m.ContainerKey != 0 {
		n += 2 + sovAgent(uint64(m.ContainerKey))
	}
	if m.IoStat != nil {
		l = m.IoStat.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.ContainerNetRcvdPs != 0 {
		n += 6
	}
	if m.ContainerNetSentPs != 0 {
		n += 6
	}
	if m.ContainerNetRcvdBps != 0 {
		n += 6
	}
	if m.ContainerNetSentBps != 0 {
		n += 6
	}
	if m.VoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.VoluntaryCtxSwitches))
	}
	if m.InvoluntaryCtxSwitches != 0 {
		n += 2 + sovAgent(uint64(m.InvoluntaryCtxSwitches))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.Networks != nil {
		l = m.Networks.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ProcStatsWithPerm) Size() (n int) {
	var l int
	_ = l
	if m.OpenFDCount != 0 {
		n += 1 + sovAgent(uint64(m.OpenFDCount))
	}
	if m.ReadCount != 0 {
		n += 1 + sovAgent(uint64(m.ReadCount))
	}
	if m.WriteCount != 0 {
		n += 1 + sovAgent(uint64(m.WriteCount))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovAgent(uint64(m.ReadBytes))
	}
	if m.WriteBytes != 0 {
		n += 1 + sovAgent(uint64(m.WriteBytes))
	}
	return n
}

func (m *ProcStatsWithPermByPID) Size() (n int) {
	var l int
	_ = l
	if len(m.StatsByPID) > 0 {
		for k, v := range m.StatsByPID {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAgent(uint64(l))
			}
			mapEntrySize := 1 + sovAgent(uint64(k)) + l
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ContainerStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.UserPct != 0 {
		n += 5
	}
	if m.SystemPct != 0 {
		n += 5
	}
	if m.TotalPct != 0 {
		n += 5
	}
	if m.CpuLimit != 0 {
		n += 5
	}
	if m.MemRss != 0 {
		n += 1 + sovAgent(uint64(m.MemRss))
	}
	if m.MemCache != 0 {
		n += 1 + sovAgent(uint64(m.MemCache))
	}
	if m.MemLimit != 0 {
		n += 1 + sovAgent(uint64(m.MemLimit))
	}
	if m.Rbps != 0 {
		n += 5
	}
	if m.Wbps != 0 {
		n += 5
	}
	if m.NetRcvdPs != 0 {
		n += 5
	}
	if m.NetSentPs != 0 {
		n += 5
	}
	if m.NetRcvdBps != 0 {
		n += 5
	}
	if m.NetSentBps != 0 {
		n += 5
	}
	if m.State != 0 {
		n += 1 + sovAgent(uint64(m.State))
	}
	if m.Health != 0 {
		n += 2 + sovAgent(uint64(m.Health))
	}
	if m.Key != 0 {
		n += 2 + sovAgent(uint64(m.Key))
	}
	if m.Started != 0 {
		n += 2 + sovAgent(uint64(m.Started))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.ThreadCount != 0 {
		n += 2 + sovAgent(uint64(m.ThreadCount))
	}
	if m.ThreadLimit != 0 {
		n += 2 + sovAgent(uint64(m.ThreadLimit))
	}
	if m.MemUsage != 0 {
		n += 2 + sovAgent(uint64(m.MemUsage))
	}
	if m.CpuUsageNs != 0 {
		n += 6
	}
	if m.MemAccounted != 0 {
		n += 2 + sovAgent(uint64(m.MemAccounted))
	}
	return n
}

func (m *SystemInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	return n
}

func (m *OSInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *IOStat) Size() (n int) {
	var l int
	_ = l
	if m.ReadRate != 0 {
		n += 5
	}
	if m.WriteRate != 0 {
		n += 5
	}
	if m.ReadBytesRate != 0 {
		n += 5
	}
	if m.WriteBytesRate != 0 {
		n += 5
	}
	return n
}

func (m *MemoryStat) Size() (n int) {
	var l int
	_ = l
	if m.Rss != 0 {
		n += 1 + sovAgent(uint64(m.Rss))
	}
	if m.Vms != 0 {
		n += 1 + sovAgent(uint64(m.Vms))
	}
	if m.Swap != 0 {
		n += 1 + sovAgent(uint64(m.Swap))
	}
	if m.Shared != 0 {
		n += 1 + sovAgent(uint64(m.Shared))
	}
	if m.Text != 0 {
		n += 1 + sovAgent(uint64(m.Text))
	}
	if m.Lib != 0 {
		n += 1 + sovAgent(uint64(m.Lib))
	}
	if m.Data != 0 {
		n += 1 + sovAgent(uint64(m.Data))
	}
	if m.Dirty != 0 {
		n += 1 + sovAgent(uint64(m.Dirty))
	}
	return n
}

func (m *CPUStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.LastCpu)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	if m.UserPct != 0 {
		n += 5
	}
	if m.SystemPct != 0 {
		n += 5
	}
	if m.NumThreads != 0 {
		n += 1 + sovAgent(uint64(m.NumThreads))
	}
	if len(m.Cpus) > 0 {
		for _, e := range m.Cpus {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Nice != 0 {
		n += 1 + sovAgent(uint64(m.Nice))
	}
	if m.UserTime != 0 {
		n += 1 + sovAgent(uint64(m.UserTime))
	}
	if m.SystemTime != 0 {
		n += 1 + sovAgent(uint64(m.SystemTime))
	}
	return n
}

func (m *SingleCPUStat) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.TotalPct != 0 {
		n += 5
	}
	return n
}

func (m *CPUInfo) Size() (n int) {
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovAgent(uint64(m.Number))
	}
	l = len(m.Vendor)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Family)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PhysicalId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.CoreId)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Cores != 0 {
		n += 1 + sovAgent(uint64(m.Cores))
	}
	if m.Mhz != 0 {
		n += 1 + sovAgent(uint64(m.Mhz))
	}
	if m.CacheSize != 0 {
		n += 1 + sovAgent(uint64(m.CacheSize))
	}
	return n
}

func (m *Host) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovAgent(uint64(m.Id))
	}
	if m.OrgId != 0 {
		n += 1 + sovAgent(uint64(m.OrgId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.AllTags) > 0 {
		for _, s := range m.AllTags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.NumCpus != 0 {
		n += 1 + sovAgent(uint64(m.NumCpus))
	}
	if m.TotalMemory != 0 {
		n += 1 + sovAgent(uint64(m.TotalMemory))
	}
	if m.TagIndex != 0 {
		n += 1 + sovAgent(uint64(m.TagIndex))
	}
	if m.TagsModified != 0 {
		n += 1 + sovAgent(uint64(m.TagsModified))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	var l int
	_ = l
	if m.NodeCount != 0 {
		n += 1 + sovAgent(uint64(m.NodeCount))
	}
	if len(m.KubeletVersions) > 0 {
		for k, v := range m.KubeletVersions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if len(m.ApiServerVersions) > 0 {
		for k, v := range m.ApiServerVersions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if m.PodCapacity != 0 {
		n += 1 + sovAgent(uint64(m.PodCapacity))
	}
	if m.PodAllocatable != 0 {
		n += 1 + sovAgent(uint64(m.PodAllocatable))
	}
	if m.MemoryAllocatable != 0 {
		n += 1 + sovAgent(uint64(m.MemoryAllocatable))
	}
	if m.MemoryCapacity != 0 {
		n += 1 + sovAgent(uint64(m.MemoryCapacity))
	}
	if m.CpuAllocatable != 0 {
		n += 1 + sovAgent(uint64(m.CpuAllocatable))
	}
	if m.CpuCapacity != 0 {
		n += 1 + sovAgent(uint64(m.CpuCapacity))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CreationTimestamp != 0 {
		n += 1 + sovAgent(uint64(m.CreationTimestamp))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Metadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.CreationTimestamp != 0 {
		n += 1 + sovAgent(uint64(m.CreationTimestamp))
	}
	if m.DeletionTimestamp != 0 {
		n += 1 + sovAgent(uint64(m.DeletionTimestamp))
	}
	if len(m.Labels) > 0 {
		for _, s := range m.Labels {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Annotations) > 0 {
		for _, s := range m.Annotations {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.OwnerReferences) > 0 {
		for _, e := range m.OwnerReferences {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *OwnerReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ObjectReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.FieldPath)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ServicePort) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovAgent(uint64(m.Port))
	}
	l = len(m.TargetPort)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.NodePort != 0 {
		n += 1 + sovAgent(uint64(m.NodePort))
	}
	return n
}

func (m *ServiceSessionAffinityConfig) Size() (n int) {
	var l int
	_ = l
	if m.ClientIPTimeoutSeconds != 0 {
		n += 1 + sovAgent(uint64(m.ClientIPTimeoutSeconds))
	}
	return n
}

func (m *Node) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PodCIDR)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.PodCIDRs) > 0 {
		for _, s := range m.PodCIDRs {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Unschedulable {
		n += 2
	}
	if len(m.Taints) > 0 {
		for _, e := range m.Taints {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.ProviderID)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *NodeStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Capacity) > 0 {
		for k, v := range m.Capacity {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if len(m.Allocatable) > 0 {
		for k, v := range m.Allocatable {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if len(m.NodeAddresses) > 0 {
		for k, v := range m.NodeAddresses {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.KubeletVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Images) > 0 {
		for _, e := range m.Images {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.KubeProxyVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.OperatingSystem)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.OsImage)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerRuntimeVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *NodeCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ContainerImage) Size() (n int) {
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.SizeBytes != 0 {
		n += 1 + sovAgent(uint64(m.SizeBytes))
	}
	return n
}

func (m *Taint) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Effect)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.TimeAdded != 0 {
		n += 1 + sovAgent(uint64(m.TimeAdded))
	}
	return n
}

func (m *ServiceSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.ClusterIP)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.ExternalIPs) > 0 {
		for _, s := range m.ExternalIPs {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.SessionAffinity)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.LoadBalancerIP)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.LoadBalancerSourceRanges) > 0 {
		for _, s := range m.LoadBalancerSourceRanges {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.ExternalName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ExternalTrafficPolicy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.HealthCheckNodePort != 0 {
		n += 1 + sovAgent(uint64(m.HealthCheckNodePort))
	}
	if m.PublishNotReadyAddresses {
		n += 2
	}
	if m.SessionAffinityConfig != nil {
		l = m.SessionAffinityConfig.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.IpFamily)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ServiceStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.LoadBalancerIngress) > 0 {
		for _, s := range m.LoadBalancerIngress {
			l = len(s)
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *Service) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *DeploymentCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovAgent(uint64(m.LastUpdateTime))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	return n
}

func (m *Deployment) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ReplicasDesired != 0 {
		n += 1 + sovAgent(uint64(m.ReplicasDesired))
	}
	l = len(m.DeploymentStrategy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.MaxUnavailable)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.MaxSurge)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Paused {
		n += 2
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Replicas != 0 {
		n += 1 + sovAgent(uint64(m.Replicas))
	}
	if m.UpdatedReplicas != 0 {
		n += 1 + sovAgent(uint64(m.UpdatedReplicas))
	}
	if m.ReadyReplicas != 0 {
		n += 1 + sovAgent(uint64(m.ReadyReplicas))
	}
	if m.AvailableReplicas != 0 {
		n += 1 + sovAgent(uint64(m.AvailableReplicas))
	}
	if m.UnavailableReplicas != 0 {
		n += 1 + sovAgent(uint64(m.UnavailableReplicas))
	}
	l = len(m.ConditionMessage)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.ResourceRequirements) > 0 {
		for _, e := range m.ResourceRequirements {
			l = e.Size()
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *ReplicaSetCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ReplicaSet) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ReplicasDesired != 0 {
		n += 1 + sovAgent(uint64(m.ReplicasDesired))
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Replicas != 0 {
		n += 1 + sovAgent(uint64(m.Replicas))
	}
	if m.FullyLabeledReplicas != 0 {
		n += 1 + sovAgent(uint64(m.FullyLabeledReplicas))
	}
	if m.ReadyReplicas != 0 {
		n += 1 + sovAgent(uint64(m.ReadyReplicas))
	}
	if m.AvailableReplicas != 0 {
		n += 1 + sovAgent(uint64(m.AvailableReplicas))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.ResourceRequirements) > 0 {
		for _, e := range m.ResourceRequirements {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *LabelSelectorRequirement) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Operator)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *Pod) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.NominatedNodeName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.RestartCount != 0 {
		n += 1 + sovAgent(uint64(m.RestartCount))
	}
	if len(m.ContainerStatuses) > 0 {
		for _, e := range m.ContainerStatuses {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.ConditionMessage)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.ResourceRequirements) > 0 {
		for _, e := range m.ResourceRequirements {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.InitContainerStatuses) > 0 {
		for _, e := range m.InitContainerStatuses {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.QOSClass)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PriorityClass)
	if l > 0 {
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 2 + l + sovAgent(uint64(l))
	}
	if m.StartTime != 0 {
		n += 2 + sovAgent(uint64(m.StartTime))
	}
	if m.ScheduledTime != 0 {
		n += 2 + sovAgent(uint64(m.ScheduledTime))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 2 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *PodCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastProbeTime != 0 {
		n += 1 + sovAgent(uint64(m.LastProbeTime))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ContainerStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ContainerID)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Ready {
		n += 2
	}
	if m.RestartCount != 0 {
		n += 1 + sovAgent(uint64(m.RestartCount))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Manifest) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgent(uint64(m.Type))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *NamespaceCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Namespace) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ConditionMessage)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *ResourceRequirements) Size() (n int) {
	var l int
	_ = l
	if len(m.Limits) > 0 {
		for k, v := range m.Limits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if len(m.Requests) > 0 {
		for k, v := range m.Requests {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovAgent(uint64(m.Type))
	}
	return n
}

func (m *ResourceMetrics) Size() (n int) {
	var l int
	_ = l
	if len(m.MetricValues) > 0 {
		for k, v := range m.MetricValues {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *JobSpec) Size() (n int) {
	var l int
	_ = l
	if m.Parallelism != 0 {
		n += 1 + sovAgent(uint64(m.Parallelism))
	}
	if m.Completions != 0 {
		n += 1 + sovAgent(uint64(m.Completions))
	}
	if m.ActiveDeadlineSeconds != 0 {
		n += 1 + sovAgent(uint64(m.ActiveDeadlineSeconds))
	}
	if m.BackoffLimit != 0 {
		n += 1 + sovAgent(uint64(m.BackoffLimit))
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.ManualSelector {
		n += 2
	}
	if len(m.ResourceRequirements) > 0 {
		for _, e := range m.ResourceRequirements {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *JobStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.ConditionMessage)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.StartTime != 0 {
		n += 1 + sovAgent(uint64(m.StartTime))
	}
	if m.CompletionTime != 0 {
		n += 1 + sovAgent(uint64(m.CompletionTime))
	}
	if m.Active != 0 {
		n += 1 + sovAgent(uint64(m.Active))
	}
	if m.Succeeded != 0 {
		n += 1 + sovAgent(uint64(m.Succeeded))
	}
	if m.Failed != 0 {
		n += 1 + sovAgent(uint64(m.Failed))
	}
	return n
}

func (m *JobCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastProbeTime != 0 {
		n += 1 + sovAgent(uint64(m.LastProbeTime))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Job) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CronJobSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Schedule)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.StartingDeadlineSeconds != 0 {
		n += 1 + sovAgent(uint64(m.StartingDeadlineSeconds))
	}
	l = len(m.ConcurrencyPolicy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Suspend {
		n += 2
	}
	if m.SuccessfulJobsHistoryLimit != 0 {
		n += 1 + sovAgent(uint64(m.SuccessfulJobsHistoryLimit))
	}
	if m.FailedJobsHistoryLimit != 0 {
		n += 1 + sovAgent(uint64(m.FailedJobsHistoryLimit))
	}
	if len(m.ResourceRequirements) > 0 {
		for _, e := range m.ResourceRequirements {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *CronJobStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Active) > 0 {
		for _, e := range m.Active {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.LastScheduleTime != 0 {
		n += 1 + sovAgent(uint64(m.LastScheduleTime))
	}
	return n
}

func (m *CronJob) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *DaemonSetSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.DeploymentStrategy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.MaxUnavailable)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.MinReadySeconds != 0 {
		n += 1 + sovAgent(uint64(m.MinReadySeconds))
	}
	if m.RevisionHistoryLimit != 0 {
		n += 1 + sovAgent(uint64(m.RevisionHistoryLimit))
	}
	if len(m.ResourceRequirements) > 0 {
		for _, e := range m.ResourceRequirements {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *DaemonSetStatus) Size() (n int) {
	var l int
	_ = l
	if m.CurrentNumberScheduled != 0 {
		n += 1 + sovAgent(uint64(m.CurrentNumberScheduled))
	}
	if m.NumberMisscheduled != 0 {
		n += 1 + sovAgent(uint64(m.NumberMisscheduled))
	}
	if m.DesiredNumberScheduled != 0 {
		n += 1 + sovAgent(uint64(m.DesiredNumberScheduled))
	}
	if m.NumberReady != 0 {
		n += 1 + sovAgent(uint64(m.NumberReady))
	}
	if m.UpdatedNumberScheduled != 0 {
		n += 1 + sovAgent(uint64(m.UpdatedNumberScheduled))
	}
	if m.NumberAvailable != 0 {
		n += 1 + sovAgent(uint64(m.NumberAvailable))
	}
	if m.NumberUnavailable != 0 {
		n += 1 + sovAgent(uint64(m.NumberUnavailable))
	}
	return n
}

func (m *DaemonSetCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *DaemonSet) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *StatefulSetSpec) Size() (n int) {
	var l int
	_ = l
	if m.DesiredReplicas != 0 {
		n += 1 + sovAgent(uint64(m.DesiredReplicas))
	}
	if len(m.Selectors) > 0 {
		for _, e := range m.Selectors {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PodManagementPolicy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.UpdateStrategy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovAgent(uint64(m.Partition))
	}
	if len(m.ResourceRequirements) > 0 {
		for _, e := range m.ResourceRequirements {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *StatefulSetStatus) Size() (n int) {
	var l int
	_ = l
	if m.Replicas != 0 {
		n += 1 + sovAgent(uint64(m.Replicas))
	}
	if m.ReadyReplicas != 0 {
		n += 1 + sovAgent(uint64(m.ReadyReplicas))
	}
	if m.CurrentReplicas != 0 {
		n += 1 + sovAgent(uint64(m.CurrentReplicas))
	}
	if m.UpdatedReplicas != 0 {
		n += 1 + sovAgent(uint64(m.UpdatedReplicas))
	}
	return n
}

func (m *StatefulSetCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *StatefulSet) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *PersistentVolume) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *PersistentVolumeSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.Capacity) > 0 {
		for k, v := range m.Capacity {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	l = len(m.PersistentVolumeType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.AccessModes) > 0 {
		for _, s := range m.AccessModes {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.ClaimRef != nil {
		l = m.ClaimRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PersistentVolumeReclaimPolicy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.StorageClassName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.MountOptions) > 0 {
		for _, s := range m.MountOptions {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.VolumeMode)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.NodeAffinity) > 0 {
		for _, e := range m.NodeAffinity {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.PersistentVolumeSource != nil {
		l = m.PersistentVolumeSource.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *PersistentVolumeSource) Size() (n int) {
	var l int
	_ = l
	if m.GcePersistentDisk != nil {
		l = m.GcePersistentDisk.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.AwsElasticBlockStore != nil {
		l = m.AwsElasticBlockStore.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.AzureFile != nil {
		l = m.AzureFile.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.AzureDisk != nil {
		l = m.AzureDisk.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Csi != nil {
		l = m.Csi.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *GCEPersistentDiskVolumeSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.PdName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovAgent(uint64(m.Partition))
	}
	if m.ReadOnly {
		n += 2
	}
	return n
}

func (m *AWSElasticBlockStoreVolumeSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.VolumeID)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Partition != 0 {
		n += 1 + sovAgent(uint64(m.Partition))
	}
	if m.ReadOnly {
		n += 2
	}
	return n
}

func (m *AzureFilePersistentVolumeSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.SecretName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ShareName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.SecretNamespace)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *AzureDiskVolumeSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.DiskName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.DiskURI)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.CachingMode)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *CSIVolumeSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.Driver)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.VolumeHandle)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ReadOnly {
		n += 2
	}
	l = len(m.FsType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.VolumeAttributes) > 0 {
		for k, v := range m.VolumeAttributes {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + len(v) + sovAgent(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if m.ControllerPublishSecretRef != nil {
		l = m.ControllerPublishSecretRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.NodeStageSecretRef != nil {
		l = m.NodeStageSecretRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.NodePublishSecretRef != nil {
		l = m.NodePublishSecretRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ControllerExpandSecretRef != nil {
		l = m.ControllerExpandSecretRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.NodeExpandSecretRef != nil {
		l = m.NodeExpandSecretRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *SecretReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *PersistentVolumeStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *NodeSelectorTerm) Size() (n int) {
	var l int
	_ = l
	if len(m.MatchExpressions) > 0 {
		for _, e := range m.MatchExpressions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.MatchFields) > 0 {
		for _, e := range m.MatchFields {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *PersistentVolumeClaim) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *PersistentVolumeClaimStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Phase)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.AccessModes) > 0 {
		for _, s := range m.AccessModes {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Capacity) > 0 {
		for k, v := range m.Capacity {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + sovAgent(uint64(v))
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *PersistentVolumeClaimSpec) Size() (n int) {
	var l int
	_ = l
	if len(m.AccessModes) > 0 {
		for _, s := range m.AccessModes {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Resources != nil {
		l = m.Resources.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.VolumeName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Selector) > 0 {
		for _, e := range m.Selector {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.StorageClassName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.VolumeMode)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.DataSource != nil {
		l = m.DataSource.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *TypedLocalObjectReference) Size() (n int) {
	var l int
	_ = l
	l = len(m.ApiGroup)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *PersistentVolumeClaimCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastProbeTime != 0 {
		n += 1 + sovAgent(uint64(m.LastProbeTime))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *PolicyRule) Size() (n int) {
	var l int
	_ = l
	if len(m.Verbs) > 0 {
		for _, s := range m.Verbs {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.ApiGroups) > 0 {
		for _, s := range m.ApiGroups {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Resources) > 0 {
		for _, s := range m.Resources {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.ResourceNames) > 0 {
		for _, s := range m.ResourceNames {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.NonResourceURLs) > 0 {
		for _, s := range m.NonResourceURLs {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *Subject) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ApiGroup)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *Role) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *RoleBinding) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Subjects) > 0 {
		for _, e := range m.Subjects {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.RoleRef != nil {
		l = m.RoleRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *ClusterRole) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.AggregationRules) > 0 {
		for _, e := range m.AggregationRules {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Metrics != nil {
		l = m.Metrics.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ClusterRoleBinding) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Subjects) > 0 {
		for _, e := range m.Subjects {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.RoleRef != nil {
		l = m.RoleRef.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *ServiceAccount) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, e := range m.ImagePullSecrets {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.AutomountServiceAccountToken {
		n += 2
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *IngressServiceBackend) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServiceName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PortName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.PortNumber != 0 {
		n += 1 + sovAgent(uint64(m.PortNumber))
	}
	return n
}

func (m *IngressBackend) Size() (n int) {
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *IngressTLS) Size() (n int) {
	var l int
	_ = l
	if len(m.Hosts) > 0 {
		for _, s := range m.Hosts {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.SecretName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HTTPIngressPath) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Backend != nil {
		l = m.Backend.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.PathType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *IngressRule) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.HttpPaths) > 0 {
		for _, e := range m.HttpPaths {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *IngressSpec) Size() (n int) {
	var l int
	_ = l
	if m.DefaultBackend != nil {
		l = m.DefaultBackend.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tls) > 0 {
		for _, e := range m.Tls {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.IngressClassName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *PortStatus) Size() (n int) {
	var l int
	_ = l
	if m.Port != 0 {
		n += 1 + sovAgent(uint64(m.Port))
	}
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *LoadBalancerIngress) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Ports) > 0 {
		for _, e := range m.Ports {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *IngressStatus) Size() (n int) {
	var l int
	_ = l
	if len(m.Ingress) > 0 {
		for _, e := range m.Ingress {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *Ingress) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *KafkaRequestHeader) Size() (n int) {
	var l int
	_ = l
	if m.RequestType != 0 {
		n += 1 + sovAgent(uint64(m.RequestType))
	}
	if m.RequestVersion != 0 {
		n += 1 + sovAgent(uint64(m.RequestVersion))
	}
	return n
}

func (m *KafkaAggregation) Size() (n int) {
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovAgent(uint64(m.Count))
	}
	return n
}

func (m *DataStreamsAggregations) Size() (n int) {
	var l int
	_ = l
	if m.KafkaProduceAggregations != nil {
		l = m.KafkaProduceAggregations.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.KafkaFetchAggregations != nil {
		l = m.KafkaFetchAggregations.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.KafkaAggregations) > 0 {
		for _, e := range m.KafkaAggregations {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *DataStreamsAggregations_TopicStats) Size() (n int) {
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovAgent(uint64(m.Count))
	}
	return n
}

func (m *DataStreamsAggregations_KafkaProduceAggregations) Size() (n int) {
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *DataStreamsAggregations_KafkaFetchAggregations) Size() (n int) {
	var l int
	_ = l
	if len(m.Stats) > 0 {
		for _, e := range m.Stats {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *HTTPAggregations) Size() (n int) {
	var l int
	_ = l
	if len(m.EndpointAggregations) > 0 {
		for _, e := range m.EndpointAggregations {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *HTTP2Aggregations) Size() (n int) {
	var l int
	_ = l
	if len(m.EndpointAggregations) > 0 {
		for _, e := range m.EndpointAggregations {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *HTTPStats) Size() (n int) {
	var l int
	_ = l
	if len(m.StatsByResponseStatus) > 0 {
		for _, e := range m.StatsByResponseStatus {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.StatsByStatusCode) > 0 {
		for k, v := range m.StatsByStatusCode {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovAgent(uint64(l))
			}
			mapEntrySize := 1 + sovAgent(uint64(k)) + l
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovAgent(uint64(m.Method))
	}
	if m.FullPath {
		n += 2
	}
	return n
}

func (m *HTTPStats_Data) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovAgent(uint64(m.Count))
	}
	l = len(m.Latencies)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.FirstLatencySample != 0 {
		n += 9
	}
	return n
}

func (m *DNSDatabaseEntry) Size() (n int) {
	var l int
	_ = l
	if len(m.NameOffsets) > 0 {
		for _, e := range m.NameOffsets {
			n += 1 + sovAgent(uint64(e))
		}
	}
	return n
}

func (m *ResourceList) Size() (n int) {
	var l int
	_ = l
	if len(m.MetricValues) > 0 {
		for k, v := range m.MetricValues {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgent(uint64(len(k))) + 1 + 8
			n += mapEntrySize + 1 + sovAgent(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *VerticalPodAutoscaler) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *VerticalPodAutoscalerCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *VerticalPodAutoscalerSpec) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.UpdateMode)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.ResourcePolicies) > 0 {
		for _, e := range m.ResourcePolicies {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *VerticalPodAutoscalerTarget) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ContainerResourcePolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.ContainerName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Mode)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.MinAllowed != nil {
		l = m.MinAllowed.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.MaxAllowed != nil {
		l = m.MaxAllowed.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.ControlledResource) > 0 {
		for _, s := range m.ControlledResource {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	l = len(m.ControlledValues)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *VerticalPodAutoscalerStatus) Size() (n int) {
	var l int
	_ = l
	if m.LastRecommendedDate != 0 {
		n += 1 + sovAgent(uint64(m.LastRecommendedDate))
	}
	if len(m.Recommendations) > 0 {
		for _, e := range m.Recommendations {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *ContainerRecommendation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ContainerName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LowerBound != nil {
		l = m.LowerBound.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.UpperBound != nil {
		l = m.UpperBound.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.UncappedTarget != nil {
		l = m.UncappedTarget.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *VPACondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.ConditionType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ConditionStatus)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HorizontalPodAutoscaler) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Spec != nil {
		l = m.Spec.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Yaml)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *HorizontalPodAutoscalerSpec) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.MinReplicas != 0 {
		n += 1 + sovAgent(uint64(m.MinReplicas))
	}
	if m.MaxReplicas != 0 {
		n += 1 + sovAgent(uint64(m.MaxReplicas))
	}
	if len(m.Metrics) > 0 {
		for _, e := range m.Metrics {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	if m.Behavior != nil {
		l = m.Behavior.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HorizontalPodAutoscalerTarget) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HorizontalPodAutoscalerMetricSpec) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Pods != nil {
		l = m.Pods.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerResource != nil {
		l = m.ContainerResource.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.External != nil {
		l = m.External.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ObjectMetricSource) Size() (n int) {
	var l int
	_ = l
	if m.DescribedObject != nil {
		l = m.DescribedObject.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *MetricTarget) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovAgent(uint64(m.Value))
	}
	return n
}

func (m *MetricIdentifier) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.LabelSelector) > 0 {
		for _, e := range m.LabelSelector {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *PodsMetricSource) Size() (n int) {
	var l int
	_ = l
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ResourceMetricSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ContainerResourceMetricSource) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ExternalMetricSource) Size() (n int) {
	var l int
	_ = l
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HorizontalPodAutoscalerBehavior) Size() (n int) {
	var l int
	_ = l
	if m.ScaleUp != nil {
		l = m.ScaleUp.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ScaleDown != nil {
		l = m.ScaleDown.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HPAScalingRules) Size() (n int) {
	var l int
	_ = l
	if m.StabilizationWindowSeconds != 0 {
		n += 1 + sovAgent(uint64(m.StabilizationWindowSeconds))
	}
	l = len(m.SelectPolicy)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if len(m.Policies) > 0 {
		for _, e := range m.Policies {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *HPAScalingPolicy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovAgent(uint64(m.Value))
	}
	if m.PeriodSeconds != 0 {
		n += 1 + sovAgent(uint64(m.PeriodSeconds))
	}
	return n
}

func (m *HorizontalPodAutoscalerStatus) Size() (n int) {
	var l int
	_ = l
	if m.ObservedGeneration != 0 {
		n += 1 + sovAgent(uint64(m.ObservedGeneration))
	}
	if m.LastScaleTime != 0 {
		n += 1 + sovAgent(uint64(m.LastScaleTime))
	}
	if m.CurrentReplicas != 0 {
		n += 1 + sovAgent(uint64(m.CurrentReplicas))
	}
	if m.DesiredReplicas != 0 {
		n += 1 + sovAgent(uint64(m.DesiredReplicas))
	}
	if len(m.CurrentMetrics) > 0 {
		for _, e := range m.CurrentMetrics {
			l = e.Size()
			n += 1 + l + sovAgent(uint64(l))
		}
	}
	return n
}

func (m *HorizontalPodAutoscalerCondition) Size() (n int) {
	var l int
	_ = l
	l = len(m.ConditionType)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.ConditionStatus)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.LastTransitionTime != 0 {
		n += 1 + sovAgent(uint64(m.LastTransitionTime))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *HorizontalPodAutoscalerMetricStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Object != nil {
		l = m.Object.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Pods != nil {
		l = m.Pods.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Resource != nil {
		l = m.Resource.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.ContainerResource != nil {
		l = m.ContainerResource.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.External != nil {
		l = m.External.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ObjectMetricStatus) Size() (n int) {
	var l int
	_ = l
	if m.DescribedObject != nil {
		l = m.DescribedObject.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Current != 0 {
		n += 1 + sovAgent(uint64(m.Current))
	}
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *PodsMetricStatus) Size() (n int) {
	var l int
	_ = l
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Current != 0 {
		n += 1 + sovAgent(uint64(m.Current))
	}
	return n
}

func (m *ResourceMetricStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Current != 0 {
		n += 1 + sovAgent(uint64(m.Current))
	}
	return n
}

func (m *ContainerResourceMetricStatus) Size() (n int) {
	var l int
	_ = l
	l = len(m.ResourceName)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Current != 0 {
		n += 1 + sovAgent(uint64(m.Current))
	}
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovAgent(uint64(l))
	}
	return n
}

func (m *ExternalMetricStatus) Size() (n int) {
	var l int
	_ = l
	if m.Metric != nil {
		l = m.Metric.Size()
		n += 1 + l + sovAgent(uint64(l))
	}
	if m.Current != 0 {
		n += 1 + sovAgent(uint64(m.Current))
	}
	return n
}

func sovAgent(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAgent(x uint64) (n int) {
	return sovAgent(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResCollector) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResCollector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResCollector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResCollector_Header{}
			}
			if err := m.Header.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CollectorStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResCollector_Header) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Header: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Header: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorProc) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorProc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorProc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Processes = append(m.Processes, &Process{})
			if err := m.Processes[len(m.Processes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SystemInfo{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHostType", wireType)
			}
			m.ContainerHostType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHostType |= (ContainerHostType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HintMask", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Hints = &CollectorProc_HintMask{v}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorProcDiscovery) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorProcDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorProcDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessDiscoveries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessDiscoveries = append(m.ProcessDiscoveries, &ProcessDiscovery{})
			if err := m.ProcessDiscoveries[len(m.ProcessDiscoveries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorRealTime) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorRealTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorRealTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &ProcessStat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			m.HostId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HostId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumCpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerStats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerStats = append(m.ContainerStats, &ContainerStat{})
			if err := m.ContainerStats[len(m.ContainerStats)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHostType", wireType)
			}
			m.ContainerHostType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHostType |= (ContainerHostType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorContainer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorContainer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorContainer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SystemInfo{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, &Container{})
			if err := m.Containers[len(m.Containers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHostType", wireType)
			}
			m.ContainerHostType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHostType |= (ContainerHostType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorContainerRealTime) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorContainerRealTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorContainerRealTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &ContainerStat{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumCpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostId", wireType)
			}
			m.HostId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HostId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHostType", wireType)
			}
			m.ContainerHostType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHostType |= (ContainerHostType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorReqStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorReqStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorReqStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorPod) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorPod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorPod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pods = append(m.Pods, &Pod{})
			if err := m.Pods[len(m.Pods)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorReplicaSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorReplicaSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorReplicaSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplicaSets = append(m.ReplicaSets, &ReplicaSet{})
			if err := m.ReplicaSets[len(m.ReplicaSets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorDeployment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorDeployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorDeployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deployments", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deployments = append(m.Deployments, &Deployment{})
			if err := m.Deployments[len(m.Deployments)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorService) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorService: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorService: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Services", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Services = append(m.Services, &Service{})
			if err := m.Services[len(m.Services)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorNode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostAliasMapping", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.HostAliasMapping == nil {
				m.HostAliasMapping = make(map[string]*Host)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthAgent
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthAgent
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Host{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.HostAliasMapping[mapkey] = mapvalue
			} else {
				var mapvalue *Host
				m.HostAliasMapping[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorCluster) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cluster == nil {
				m.Cluster = &Cluster{}
			}
			if err := m.Cluster.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorManifest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manifests = append(m.Manifests, &Manifest{})
			if err := m.Manifests[len(m.Manifests)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorManifestCRD) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorManifestCRD: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorManifestCRD: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Manifest == nil {
				m.Manifest = &CollectorManifest{}
			}
			if err := m.Manifest.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorManifestCR) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorManifestCR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorManifestCR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manifest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Manifest == nil {
				m.Manifest = &CollectorManifest{}
			}
			if err := m.Manifest.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorNamespace) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorNamespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorNamespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespaces", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespaces = append(m.Namespaces, &Namespace{})
			if err := m.Namespaces[len(m.Namespaces)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorJob) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &Job{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorCronJob) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorCronJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorCronJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronJobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronJobs = append(m.CronJobs, &CronJob{})
			if err := m.CronJobs[len(m.CronJobs)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorDaemonSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorDaemonSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorDaemonSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DaemonSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DaemonSets = append(m.DaemonSets, &DaemonSet{})
			if err := m.DaemonSets[len(m.DaemonSets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorStatefulSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStatefulSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStatefulSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatefulSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatefulSets = append(m.StatefulSets, &StatefulSet{})
			if err := m.StatefulSets[len(m.StatefulSets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorPersistentVolume) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorPersistentVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorPersistentVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolumes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistentVolumes = append(m.PersistentVolumes, &PersistentVolume{})
			if err := m.PersistentVolumes[len(m.PersistentVolumes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorPersistentVolumeClaim) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorPersistentVolumeClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorPersistentVolumeClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolumeClaims", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistentVolumeClaims = append(m.PersistentVolumeClaims, &PersistentVolumeClaim{})
			if err := m.PersistentVolumeClaims[len(m.PersistentVolumeClaims)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorRole) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, &Role{})
			if err := m.Roles[len(m.Roles)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorRoleBinding) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorRoleBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorRoleBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RoleBindings = append(m.RoleBindings, &RoleBinding{})
			if err := m.RoleBindings[len(m.RoleBindings)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorClusterRole) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorClusterRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorClusterRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterRoles", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterRoles = append(m.ClusterRoles, &ClusterRole{})
			if err := m.ClusterRoles[len(m.ClusterRoles)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorClusterRoleBinding) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorClusterRoleBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorClusterRoleBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterRoleBindings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterRoleBindings = append(m.ClusterRoleBindings, &ClusterRoleBinding{})
			if err := m.ClusterRoleBindings[len(m.ClusterRoleBindings)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorServiceAccount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorServiceAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorServiceAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceAccounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceAccounts = append(m.ServiceAccounts, &ServiceAccount{})
			if err := m.ServiceAccounts[len(m.ServiceAccounts)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorIngress) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorIngress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorIngress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingresses = append(m.Ingresses, &Ingress{})
			if err := m.Ingresses[len(m.Ingresses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorVerticalPodAutoscaler) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorVerticalPodAutoscaler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorVerticalPodAutoscaler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerticalPodAutoscalers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerticalPodAutoscalers = append(m.VerticalPodAutoscalers, &VerticalPodAutoscaler{})
			if err := m.VerticalPodAutoscalers[len(m.VerticalPodAutoscalers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorHorizontalPodAutoscaler) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorHorizontalPodAutoscaler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorHorizontalPodAutoscaler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HorizontalPodAutoscalers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HorizontalPodAutoscalers = append(m.HorizontalPodAutoscalers, &HorizontalPodAutoscaler{})
			if err := m.HorizontalPodAutoscalers[len(m.HorizontalPodAutoscalers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveClients", wireType)
			}
			m.ActiveClients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActiveClients |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Interval |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &ProcessUser{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Container == nil {
				m.Container = &Container{}
			}
			if err := m.Container.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OpenFdCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ProcessState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerKey", wireType)
			}
			m.ContainerKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerKey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoluntaryCtxSwitches", wireType)
			}
			m.VoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoluntaryCtxSwitches", wireType)
			}
			m.InvoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InvoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerByteKey = append(m.ContainerByteKey[:0], data[iNdEx:postIndex]...)
			if m.ContainerByteKey == nil {
				m.ContainerByteKey = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsPid", wireType)
			}
			m.NsPid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NsPid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Networks == nil {
				m.Networks = &ProcessNetworks{}
			}
			if err := m.Networks.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessDiscovery) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessDiscovery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessDiscovery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NsPid", wireType)
			}
			m.NsPid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NsPid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &ProcessUser{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Command) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Command: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Command: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cwd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cwd = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDisk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnDisk = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ppid", wireType)
			}
			m.Ppid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ppid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pgroup", wireType)
			}
			m.Pgroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pgroup |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exe", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exe = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comm", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Comm = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessUser) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Uid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Gid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Euid", wireType)
			}
			m.Euid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Euid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egid", wireType)
			}
			m.Egid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Egid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suid", wireType)
			}
			m.Suid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Suid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sgid", wireType)
			}
			m.Sgid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Sgid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessNetworks) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessNetworks: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessNetworks: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ConnectionRate = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.BytesRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerAddr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Protocol |= (ConnectionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Container) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Container: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Container: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CpuLimit = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryLimit", wireType)
			}
			m.MemoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemoryLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Health |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Rbps = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Wbps = float32(math.Float32frombits(v))
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdPs = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentPs = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdBps = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentBps = float32(math.Float32frombits(v))
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.UserPct = float32(math.Float32frombits(v))
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.SystemPct = float32(math.Float32frombits(v))
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRss", wireType)
			}
			m.MemRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCache", wireType)
			}
			m.MemCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemCache |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			m.Started = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Started |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addresses = append(m.Addresses, &ContainerAddr{})
			if err := m.Addresses[len(m.Addresses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadCount", wireType)
			}
			m.ThreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ThreadCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadLimit", wireType)
			}
			m.ThreadLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ThreadLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsage", wireType)
			}
			m.MemUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemUsage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsageNs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CpuUsageNs = float32(math.Float32frombits(v))
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemAccounted", wireType)
			}
			m.MemAccounted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemAccounted |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memory == nil {
				m.Memory = &MemoryStat{}
			}
			if err := m.Memory.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cpu == nil {
				m.Cpu = &CPUStat{}
			}
			if err := m.Cpu.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threads", wireType)
			}
			m.Threads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Threads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFdCount", wireType)
			}
			m.OpenFdCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OpenFdCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerState", wireType)
			}
			m.ContainerState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerState |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessState", wireType)
			}
			m.ProcessState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ProcessState |= (ProcessState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHealth", wireType)
			}
			m.ContainerHealth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHealth |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerRbps = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerWbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerWbps = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerKey", wireType)
			}
			m.ContainerKey = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerKey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IoStat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IoStat == nil {
				m.IoStat = &IOStat{}
			}
			if err := m.IoStat.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetRcvdPs = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetSentPs = float32(math.Float32frombits(v))
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetRcvdBps = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerNetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ContainerNetSentBps = float32(math.Float32frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoluntaryCtxSwitches", wireType)
			}
			m.VoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoluntaryCtxSwitches", wireType)
			}
			m.InvoluntaryCtxSwitches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.InvoluntaryCtxSwitches |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerByteKey = append(m.ContainerByteKey[:0], data[iNdEx:postIndex]...)
			if m.ContainerByteKey == nil {
				m.ContainerByteKey = []byte{}
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Networks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Networks == nil {
				m.Networks = &ProcessNetworks{}
			}
			if err := m.Networks.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcStatsWithPerm) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcStatsWithPerm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcStatsWithPerm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenFDCount", wireType)
			}
			m.OpenFDCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OpenFDCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadCount", wireType)
			}
			m.ReadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReadCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteCount", wireType)
			}
			m.WriteCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WriteCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReadBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytes", wireType)
			}
			m.WriteBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.WriteBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcStatsWithPermByPID) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcStatsWithPermByPID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcStatsWithPermByPID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsByPID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.StatsByPID == nil {
				m.StatsByPID = make(map[int32]*ProcStatsWithPerm)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthAgent
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthAgent
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &ProcStatsWithPerm{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.StatsByPID[mapkey] = mapvalue
			} else {
				var mapvalue *ProcStatsWithPerm
				m.StatsByPID[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.UserPct = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.SystemPct = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CpuLimit = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemRss", wireType)
			}
			m.MemRss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemRss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemCache", wireType)
			}
			m.MemCache = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemCache |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemLimit", wireType)
			}
			m.MemLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Rbps = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wbps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.Wbps = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdPs = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentPs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentPs = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetRcvdBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetRcvdBps = float32(math.Float32frombits(v))
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetSentBps", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.NetSentBps = float32(math.Float32frombits(v))
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (ContainerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			m.Health = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Health |= (ContainerHealth(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			m.Started = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Started |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadCount", wireType)
			}
			m.ThreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ThreadCount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadLimit", wireType)
			}
			m.ThreadLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ThreadLimit |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemUsage", wireType)
			}
			m.MemUsage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemUsage |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsageNs", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.CpuUsageNs = float32(math.Float32frombits(v))
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemAccounted", wireType)
			}
			m.MemAccounted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemAccounted |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SystemInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SystemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SystemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &OSInfo{}
			}
			if err := m.Os.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &CPUInfo{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OSInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IOStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IOStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IOStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ReadRate = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.WriteRate = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytesRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.ReadBytesRate = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteBytesRate", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.WriteBytesRate = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rss", wireType)
			}
			m.Rss = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rss |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vms", wireType)
			}
			m.Vms = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Vms |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Swap", wireType)
			}
			m.Swap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Swap |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shared", wireType)
			}
			m.Shared = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Shared |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			m.Text = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Text |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lib", wireType)
			}
			m.Lib = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Lib |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			m.Data = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Data |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dirty", wireType)
			}
			m.Dirty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Dirty |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCpu", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastCpu = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.UserPct = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.SystemPct = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumThreads", wireType)
			}
			m.NumThreads = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumThreads |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cpus = append(m.Cpus, &SingleCPUStat{})
			if err := m.Cpus[len(m.Cpus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nice", wireType)
			}
			m.Nice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Nice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserTime", wireType)
			}
			m.UserTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UserTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemTime", wireType)
			}
			m.SystemTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SystemTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SingleCPUStat) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SingleCPUStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SingleCPUStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPct", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(data[iNdEx-4])
			v |= uint32(data[iNdEx-3]) << 8
			v |= uint32(data[iNdEx-2]) << 16
			v |= uint32(data[iNdEx-1]) << 24
			m.TotalPct = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CPUInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CPUInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CPUInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Number |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vendor = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Family = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhysicalId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoreId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoreId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cores", wireType)
			}
			m.Cores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cores |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mhz", wireType)
			}
			m.Mhz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Mhz |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CacheSize", wireType)
			}
			m.CacheSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CacheSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Host) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Host: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Host: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			m.OrgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrgId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllTags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllTags = append(m.AllTags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumCpus", wireType)
			}
			m.NumCpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumCpus |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemory", wireType)
			}
			m.TotalMemory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalMemory |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagIndex", wireType)
			}
			m.TagIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsModified", wireType)
			}
			m.TagsModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagsModified |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeCount", wireType)
			}
			m.NodeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeletVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.KubeletVersions == nil {
				m.KubeletVersions = make(map[string]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.KubeletVersions[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.KubeletVersions[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiServerVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ApiServerVersions == nil {
				m.ApiServerVersions = make(map[string]int32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ApiServerVersions[mapkey] = mapvalue
			} else {
				var mapvalue int32
				m.ApiServerVersions[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodCapacity", wireType)
			}
			m.PodCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PodCapacity |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodAllocatable", wireType)
			}
			m.PodAllocatable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PodAllocatable |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryAllocatable", wireType)
			}
			m.MemoryAllocatable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemoryAllocatable |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryCapacity", wireType)
			}
			m.MemoryCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MemoryCapacity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuAllocatable", wireType)
			}
			m.CpuAllocatable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CpuAllocatable |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCapacity", wireType)
			}
			m.CpuCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CpuCapacity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			m.CreationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreationTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			m.CreationTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreationTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			m.DeletionTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DeletionTimestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Annotations = append(m.Annotations, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerReferences = append(m.OwnerReferences, &OwnerReference{})
			if err := m.OwnerReferences[len(m.OwnerReferences)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FieldPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServicePort) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServicePort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServicePort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPort", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetPort = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePort", wireType)
			}
			m.NodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodePort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceSessionAffinityConfig) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceSessionAffinityConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceSessionAffinityConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIPTimeoutSeconds", wireType)
			}
			m.ClientIPTimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ClientIPTimeoutSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodCIDR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodCIDR = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodCIDRs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodCIDRs = append(m.PodCIDRs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unschedulable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unschedulable = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Taints = append(m.Taints, &Taint{})
			if err := m.Taints[len(m.Taints)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &NodeStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Capacity == nil {
				m.Capacity = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Capacity[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Capacity[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocatable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Allocatable == nil {
				m.Allocatable = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Allocatable[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Allocatable[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.NodeAddresses == nil {
				m.NodeAddresses = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthAgent
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.NodeAddresses[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.NodeAddresses[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeletVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeletVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &NodeCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, &ContainerImage{})
			if err := m.Images[len(m.Images)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeProxyVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeProxyVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatingSystem", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatingSystem = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OsImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OsImage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerRuntimeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerRuntimeVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerImage) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SizeBytes |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Taint) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Taint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Taint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effect = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeAdded", wireType)
			}
			m.TimeAdded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TimeAdded |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &ServicePort{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &LabelSelectorRequirement{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterIP = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalIPs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalIPs = append(m.ExternalIPs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionAffinity = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIP = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerSourceRanges", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerSourceRanges = append(m.LoadBalancerSourceRanges, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalTrafficPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalTrafficPolicy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthCheckNodePort", wireType)
			}
			m.HealthCheckNodePort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HealthCheckNodePort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublishNotReadyAddresses", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PublishNotReadyAddresses = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionAffinityConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SessionAffinityConfig == nil {
				m.SessionAffinityConfig = &ServiceSessionAffinityConfig{}
			}
			if err := m.SessionAffinityConfig.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpFamily = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadBalancerIngress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadBalancerIngress = append(m.LoadBalancerIngress, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &ServiceSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &ServiceStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeploymentCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeploymentCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeploymentCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastUpdateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deployment) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deployment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deployment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasDesired", wireType)
			}
			m.ReplicasDesired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReplicasDesired |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentStrategy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnavailable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxUnavailable = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSurge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxSurge = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &LabelSelectorRequirement{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedReplicas", wireType)
			}
			m.UpdatedReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdatedReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyReplicas", wireType)
			}
			m.ReadyReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReadyReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableReplicas", wireType)
			}
			m.AvailableReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AvailableReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnavailableReplicas", wireType)
			}
			m.UnavailableReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UnavailableReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionMessage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceRequirements = append(m.ResourceRequirements, &ResourceRequirements{})
			if err := m.ResourceRequirements[len(m.ResourceRequirements)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &DeploymentCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaSetCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaSetCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaSetCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicasDesired", wireType)
			}
			m.ReplicasDesired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReplicasDesired |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &LabelSelectorRequirement{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullyLabeledReplicas", wireType)
			}
			m.FullyLabeledReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FullyLabeledReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyReplicas", wireType)
			}
			m.ReadyReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReadyReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableReplicas", wireType)
			}
			m.AvailableReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AvailableReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceRequirements = append(m.ResourceRequirements, &ResourceRequirements{})
			if err := m.ResourceRequirements[len(m.ResourceRequirements)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &ReplicaSetCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelSelectorRequirement) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelSelectorRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelSelectorRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operator = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pod) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pod: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pod: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NominatedNodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NominatedNodeName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartCount", wireType)
			}
			m.RestartCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RestartCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerStatuses = append(m.ContainerStatuses, &ContainerStatus{})
			if err := m.ContainerStatuses[len(m.ContainerStatuses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionMessage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceRequirements = append(m.ResourceRequirements, &ResourceRequirements{})
			if err := m.ResourceRequirements[len(m.ResourceRequirements)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitContainerStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitContainerStatuses = append(m.InitContainerStatuses, &ContainerStatus{})
			if err := m.InitContainerStatuses[len(m.InitContainerStatuses)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QOSClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QOSClass = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClass", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClass = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduledTime", wireType)
			}
			m.ScheduledTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ScheduledTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PodCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProbeTime", wireType)
			}
			m.LastProbeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastProbeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ready = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestartCount", wireType)
			}
			m.RestartCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RestartCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Manifest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Manifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Manifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], data[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NamespaceCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NamespaceCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NamespaceCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Namespace) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Namespace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Namespace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionMessage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &NamespaceCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceRequirements) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceRequirements: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceRequirements: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Limits == nil {
				m.Limits = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Limits[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Limits[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Requests == nil {
				m.Requests = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Requests[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Requests[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (ResourceRequirementsType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceMetrics) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.MetricValues == nil {
				m.MetricValues = make(map[string]float64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				mapvaluetemp = uint64(data[iNdEx-8])
				mapvaluetemp |= uint64(data[iNdEx-7]) << 8
				mapvaluetemp |= uint64(data[iNdEx-6]) << 16
				mapvaluetemp |= uint64(data[iNdEx-5]) << 24
				mapvaluetemp |= uint64(data[iNdEx-4]) << 32
				mapvaluetemp |= uint64(data[iNdEx-3]) << 40
				mapvaluetemp |= uint64(data[iNdEx-2]) << 48
				mapvaluetemp |= uint64(data[iNdEx-1]) << 56
				mapvalue := math.Float64frombits(mapvaluetemp)
				m.MetricValues[mapkey] = mapvalue
			} else {
				var mapvalue float64
				m.MetricValues[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelism", wireType)
			}
			m.Parallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Parallelism |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completions", wireType)
			}
			m.Completions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Completions |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveDeadlineSeconds", wireType)
			}
			m.ActiveDeadlineSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActiveDeadlineSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackoffLimit", wireType)
			}
			m.BackoffLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.BackoffLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &LabelSelectorRequirement{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManualSelector", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ManualSelector = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceRequirements = append(m.ResourceRequirements, &ResourceRequirements{})
			if err := m.ResourceRequirements[len(m.ResourceRequirements)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionMessage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			m.CompletionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CompletionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			m.Active = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Active |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Succeeded", wireType)
			}
			m.Succeeded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Succeeded |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			m.Failed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Failed |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProbeTime", wireType)
			}
			m.LastProbeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastProbeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &JobSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &JobStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &JobCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronJobSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronJobSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronJobSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schedule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schedule = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingDeadlineSeconds", wireType)
			}
			m.StartingDeadlineSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartingDeadlineSeconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrencyPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConcurrencyPolicy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Suspend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Suspend = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SuccessfulJobsHistoryLimit", wireType)
			}
			m.SuccessfulJobsHistoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SuccessfulJobsHistoryLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailedJobsHistoryLimit", wireType)
			}
			m.FailedJobsHistoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FailedJobsHistoryLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceRequirements = append(m.ResourceRequirements, &ResourceRequirements{})
			if err := m.ResourceRequirements[len(m.ResourceRequirements)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronJobStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronJobStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronJobStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Active = append(m.Active, &ObjectReference{})
			if err := m.Active[len(m.Active)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastScheduleTime", wireType)
			}
			m.LastScheduleTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastScheduleTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronJob) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &CronJobSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &CronJobStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonSetSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonSetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonSetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &LabelSelectorRequirement{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeploymentStrategy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnavailable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxUnavailable = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinReadySeconds", wireType)
			}
			m.MinReadySeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MinReadySeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevisionHistoryLimit", wireType)
			}
			m.RevisionHistoryLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RevisionHistoryLimit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceRequirements = append(m.ResourceRequirements, &ResourceRequirements{})
			if err := m.ResourceRequirements[len(m.ResourceRequirements)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonSetStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonSetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonSetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentNumberScheduled", wireType)
			}
			m.CurrentNumberScheduled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurrentNumberScheduled |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberMisscheduled", wireType)
			}
			m.NumberMisscheduled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumberMisscheduled |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredNumberScheduled", wireType)
			}
			m.DesiredNumberScheduled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DesiredNumberScheduled |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberReady", wireType)
			}
			m.NumberReady = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumberReady |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedNumberScheduled", wireType)
			}
			m.UpdatedNumberScheduled = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdatedNumberScheduled |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberAvailable", wireType)
			}
			m.NumberAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumberAvailable |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberUnavailable", wireType)
			}
			m.NumberUnavailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NumberUnavailable |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonSetCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonSetCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonSetCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DaemonSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DaemonSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DaemonSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &DaemonSetSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &DaemonSetStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &DaemonSetCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulSetSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulSetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulSetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredReplicas", wireType)
			}
			m.DesiredReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DesiredReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selectors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selectors = append(m.Selectors, &LabelSelectorRequirement{})
			if err := m.Selectors[len(m.Selectors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodManagementPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodManagementPolicy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStrategy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateStrategy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Partition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequirements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceRequirements = append(m.ResourceRequirements, &ResourceRequirements{})
			if err := m.ResourceRequirements[len(m.ResourceRequirements)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulSetStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulSetStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulSetStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			m.Replicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Replicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadyReplicas", wireType)
			}
			m.ReadyReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReadyReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReplicas", wireType)
			}
			m.CurrentReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurrentReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedReplicas", wireType)
			}
			m.UpdatedReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdatedReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulSetCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulSetCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulSetCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &StatefulSetSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &StatefulSetStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &StatefulSetCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolume) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PersistentVolumeSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PersistentVolumeStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Capacity == nil {
				m.Capacity = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Capacity[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Capacity[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolumeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistentVolumeType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessModes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessModes = append(m.AccessModes, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimRef == nil {
				m.ClaimRef = &ObjectReference{}
			}
			if err := m.ClaimRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolumeReclaimPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PersistentVolumeReclaimPolicy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClassName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountOptions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountOptions = append(m.MountOptions, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeMode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAffinity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAffinity = append(m.NodeAffinity, &NodeSelectorTerm{})
			if err := m.NodeAffinity[len(m.NodeAffinity)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistentVolumeSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PersistentVolumeSource == nil {
				m.PersistentVolumeSource = &PersistentVolumeSource{}
			}
			if err := m.PersistentVolumeSource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GcePersistentDisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GcePersistentDisk == nil {
				m.GcePersistentDisk = &GCEPersistentDiskVolumeSource{}
			}
			if err := m.GcePersistentDisk.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AwsElasticBlockStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AwsElasticBlockStore == nil {
				m.AwsElasticBlockStore = &AWSElasticBlockStoreVolumeSource{}
			}
			if err := m.AwsElasticBlockStore.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AzureFile == nil {
				m.AzureFile = &AzureFilePersistentVolumeSource{}
			}
			if err := m.AzureFile.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AzureDisk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AzureDisk == nil {
				m.AzureDisk = &AzureDiskVolumeSource{}
			}
			if err := m.AzureDisk.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Csi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Csi == nil {
				m.Csi = &CSIVolumeSource{}
			}
			if err := m.Csi.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GCEPersistentDiskVolumeSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GCEPersistentDiskVolumeSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GCEPersistentDiskVolumeSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PdName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PdName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Partition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AWSElasticBlockStoreVolumeSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AWSElasticBlockStoreVolumeSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AWSElasticBlockStoreVolumeSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partition", wireType)
			}
			m.Partition = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Partition |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureFilePersistentVolumeSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureFilePersistentVolumeSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureFilePersistentVolumeSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShareName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretNamespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretNamespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AzureDiskVolumeSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AzureDiskVolumeSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AzureDiskVolumeSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskURI", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiskURI = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CachingMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CachingMode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CSIVolumeSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CSIVolumeSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CSIVolumeSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Driver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Driver = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeHandle", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeHandle = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadOnly = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FsType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FsType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.VolumeAttributes == nil {
				m.VolumeAttributes = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthAgent
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.VolumeAttributes[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.VolumeAttributes[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerPublishSecretRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControllerPublishSecretRef == nil {
				m.ControllerPublishSecretRef = &SecretReference{}
			}
			if err := m.ControllerPublishSecretRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeStageSecretRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeStageSecretRef == nil {
				m.NodeStageSecretRef = &SecretReference{}
			}
			if err := m.NodeStageSecretRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodePublishSecretRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodePublishSecretRef == nil {
				m.NodePublishSecretRef = &SecretReference{}
			}
			if err := m.NodePublishSecretRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControllerExpandSecretRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ControllerExpandSecretRef == nil {
				m.ControllerExpandSecretRef = &SecretReference{}
			}
			if err := m.ControllerExpandSecretRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeExpandSecretRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeExpandSecretRef == nil {
				m.NodeExpandSecretRef = &SecretReference{}
			}
			if err := m.NodeExpandSecretRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeSelectorTerm) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeSelectorTerm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeSelectorTerm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchExpressions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchExpressions = append(m.MatchExpressions, &LabelSelectorRequirement{})
			if err := m.MatchExpressions[len(m.MatchExpressions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MatchFields = append(m.MatchFields, &LabelSelectorRequirement{})
			if err := m.MatchFields[len(m.MatchFields)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeClaim) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeClaim: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeClaim: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &PersistentVolumeClaimSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &PersistentVolumeClaimStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeClaimStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeClaimStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeClaimStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phase = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessModes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessModes = append(m.AccessModes, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Capacity == nil {
				m.Capacity = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Capacity[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.Capacity[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &PersistentVolumeClaimCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeClaimSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeClaimSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeClaimSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessModes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccessModes = append(m.AccessModes, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resources == nil {
				m.Resources = &ResourceRequirements{}
			}
			if err := m.Resources.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Selector = append(m.Selector, &LabelSelectorRequirement{})
			if err := m.Selector[len(m.Selector)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageClassName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VolumeMode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataSource == nil {
				m.DataSource = &TypedLocalObjectReference{}
			}
			if err := m.DataSource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypedLocalObjectReference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypedLocalObjectReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypedLocalObjectReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiGroup = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PersistentVolumeClaimCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PersistentVolumeClaimCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PersistentVolumeClaimCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProbeTime", wireType)
			}
			m.LastProbeTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastProbeTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PolicyRule) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PolicyRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PolicyRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verbs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Verbs = append(m.Verbs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiGroups = append(m.ApiGroups, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceNames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceNames = append(m.ResourceNames, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonResourceURLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NonResourceURLs = append(m.NonResourceURLs, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiGroup = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Role) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Role: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Role: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &PolicyRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleBinding) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subjects = append(m.Subjects, &Subject{})
			if err := m.Subjects[len(m.Subjects)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoleRef == nil {
				m.RoleRef = &TypedLocalObjectReference{}
			}
			if err := m.RoleRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterRole) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterRole: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterRole: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &PolicyRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AggregationRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AggregationRules = append(m.AggregationRules, &LabelSelectorRequirement{})
			if err := m.AggregationRules[len(m.AggregationRules)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metrics == nil {
				m.Metrics = &ResourceMetrics{}
			}
			if err := m.Metrics.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterRoleBinding) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterRoleBinding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterRoleBinding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subjects = append(m.Subjects, &Subject{})
			if err := m.Subjects[len(m.Subjects)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoleRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RoleRef == nil {
				m.RoleRef = &TypedLocalObjectReference{}
			}
			if err := m.RoleRef.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceAccount) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &ObjectReference{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, &TypedLocalObjectReference{})
			if err := m.ImagePullSecrets[len(m.ImagePullSecrets)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutomountServiceAccountToken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AutomountServiceAccountToken = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressServiceBackend) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressServiceBackend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressServiceBackend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PortName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortNumber", wireType)
			}
			m.PortNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PortNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressBackend) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressBackend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressBackend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &IngressServiceBackend{}
			}
			if err := m.Service.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &TypedLocalObjectReference{}
			}
			if err := m.Resource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressTLS) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressTLS: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressTLS: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hosts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hosts = append(m.Hosts, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPIngressPath) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPIngressPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPIngressPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Backend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Backend == nil {
				m.Backend = &IngressBackend{}
			}
			if err := m.Backend.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PathType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressRule) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpPaths", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpPaths = append(m.HttpPaths, &HTTPIngressPath{})
			if err := m.HttpPaths[len(m.HttpPaths)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultBackend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefaultBackend == nil {
				m.DefaultBackend = &IngressBackend{}
			}
			if err := m.DefaultBackend.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tls = append(m.Tls, &IngressTLS{})
			if err := m.Tls[len(m.Tls)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &IngressRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IngressClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IngressClassName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PortStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PortStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PortStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBalancerIngress) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBalancerIngress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBalancerIngress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ports = append(m.Ports, &PortStatus{})
			if err := m.Ports[len(m.Ports)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IngressStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IngressStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IngressStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ingress = append(m.Ingress, &LoadBalancerIngress{})
			if err := m.Ingress[len(m.Ingress)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ingress) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ingress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ingress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &IngressSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &IngressStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KafkaRequestHeader) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KafkaRequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KafkaRequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			m.RequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RequestType |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestVersion", wireType)
			}
			m.RequestVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RequestVersion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KafkaAggregation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KafkaAggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KafkaAggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &KafkaRequestHeader{}
			}
			if err := m.Header.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStreamsAggregations) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataStreamsAggregations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataStreamsAggregations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaProduceAggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KafkaProduceAggregations == nil {
				m.KafkaProduceAggregations = &DataStreamsAggregations_KafkaProduceAggregations{}
			}
			if err := m.KafkaProduceAggregations.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaFetchAggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KafkaFetchAggregations == nil {
				m.KafkaFetchAggregations = &DataStreamsAggregations_KafkaFetchAggregations{}
			}
			if err := m.KafkaFetchAggregations.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KafkaAggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KafkaAggregations = append(m.KafkaAggregations, &KafkaAggregation{})
			if err := m.KafkaAggregations[len(m.KafkaAggregations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStreamsAggregations_TopicStats) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStreamsAggregations_KafkaProduceAggregations) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KafkaProduceAggregations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KafkaProduceAggregations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &DataStreamsAggregations_TopicStats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataStreamsAggregations_KafkaFetchAggregations) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KafkaFetchAggregations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KafkaFetchAggregations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stats = append(m.Stats, &DataStreamsAggregations_TopicStats{})
			if err := m.Stats[len(m.Stats)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPAggregations) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPAggregations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPAggregations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointAggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAggregations = append(m.EndpointAggregations, &HTTPStats{})
			if err := m.EndpointAggregations[len(m.EndpointAggregations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTP2Aggregations) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTP2Aggregations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTP2Aggregations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndpointAggregations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndpointAggregations = append(m.EndpointAggregations, &HTTPStats{})
			if err := m.EndpointAggregations[len(m.EndpointAggregations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPStats) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsByResponseStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatsByResponseStatus = append(m.StatsByResponseStatus, &HTTPStats_Data{})
			if err := m.StatsByResponseStatus[len(m.StatsByResponseStatus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatsByStatusCode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.StatsByStatusCode == nil {
				m.StatsByStatusCode = make(map[int32]*HTTPStats_Data)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthAgent
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthAgent
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &HTTPStats_Data{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.StatsByStatusCode[mapkey] = mapvalue
			} else {
				var mapvalue *HTTPStats_Data
				m.StatsByStatusCode[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Method |= (HTTPMethod(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullPath", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FullPath = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPStats_Data) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latencies", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Latencies = append(m.Latencies[:0], data[iNdEx:postIndex]...)
			if m.Latencies == nil {
				m.Latencies = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstLatencySample", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.FirstLatencySample = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSDatabaseEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSDatabaseEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSDatabaseEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameOffsets", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NameOffsets = append(m.NameOffsets, v)
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceList) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetricValues", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgent
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.MetricValues == nil {
				m.MetricValues = make(map[string]float64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvaluetemp uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				mapvaluetemp = uint64(data[iNdEx-8])
				mapvaluetemp |= uint64(data[iNdEx-7]) << 8
				mapvaluetemp |= uint64(data[iNdEx-6]) << 16
				mapvaluetemp |= uint64(data[iNdEx-5]) << 24
				mapvaluetemp |= uint64(data[iNdEx-4]) << 32
				mapvaluetemp |= uint64(data[iNdEx-3]) << 40
				mapvaluetemp |= uint64(data[iNdEx-2]) << 48
				mapvaluetemp |= uint64(data[iNdEx-1]) << 56
				mapvalue := math.Float64frombits(mapvaluetemp)
				m.MetricValues[mapkey] = mapvalue
			} else {
				var mapvalue float64
				m.MetricValues[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerticalPodAutoscaler) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerticalPodAutoscaler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerticalPodAutoscaler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &VerticalPodAutoscalerSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &VerticalPodAutoscalerStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &VerticalPodAutoscalerCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerticalPodAutoscalerCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerticalPodAutoscalerCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerticalPodAutoscalerCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerticalPodAutoscalerSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerticalPodAutoscalerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerticalPodAutoscalerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VerticalPodAutoscalerTarget{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateMode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourcePolicies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourcePolicies = append(m.ResourcePolicies, &ContainerResourcePolicy{})
			if err := m.ResourcePolicies[len(m.ResourcePolicies)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerticalPodAutoscalerTarget) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerticalPodAutoscalerTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerticalPodAutoscalerTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerResourcePolicy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerResourcePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerResourcePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAllowed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MinAllowed == nil {
				m.MinAllowed = &ResourceList{}
			}
			if err := m.MinAllowed.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAllowed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxAllowed == nil {
				m.MaxAllowed = &ResourceList{}
			}
			if err := m.MaxAllowed.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlledResource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlledResource = append(m.ControlledResource, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlledValues", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ControlledValues = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerticalPodAutoscalerStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerticalPodAutoscalerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerticalPodAutoscalerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRecommendedDate", wireType)
			}
			m.LastRecommendedDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastRecommendedDate |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recommendations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recommendations = append(m.Recommendations, &ContainerRecommendation{})
			if err := m.Recommendations[len(m.Recommendations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &VPACondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerRecommendation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerRecommendation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerRecommendation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &ResourceList{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LowerBound == nil {
				m.LowerBound = &ResourceList{}
			}
			if err := m.LowerBound.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperBound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpperBound == nil {
				m.UpperBound = &ResourceList{}
			}
			if err := m.UpperBound.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncappedTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UncappedTarget == nil {
				m.UncappedTarget = &ResourceList{}
			}
			if err := m.UncappedTarget.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VPACondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VPACondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VPACondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionStatus = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscaler) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscaler: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscaler: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spec == nil {
				m.Spec = &HorizontalPodAutoscalerSpec{}
			}
			if err := m.Spec.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &HorizontalPodAutoscalerStatus{}
			}
			if err := m.Status.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Yaml", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Yaml = append(m.Yaml[:0], data[iNdEx:postIndex]...)
			if m.Yaml == nil {
				m.Yaml = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, &HorizontalPodAutoscalerCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscalerSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &HorizontalPodAutoscalerTarget{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinReplicas", wireType)
			}
			m.MinReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MinReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReplicas", wireType)
			}
			m.MaxReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metrics = append(m.Metrics, &HorizontalPodAutoscalerMetricSpec{})
			if err := m.Metrics[len(m.Metrics)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Behavior", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Behavior == nil {
				m.Behavior = &HorizontalPodAutoscalerBehavior{}
			}
			if err := m.Behavior.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscalerTarget) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscalerMetricSpec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerMetricSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerMetricSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &ObjectMetricSource{}
			}
			if err := m.Object.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pods == nil {
				m.Pods = &PodsMetricSource{}
			}
			if err := m.Pods.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &ResourceMetricSource{}
			}
			if err := m.Resource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerResource == nil {
				m.ContainerResource = &ContainerResourceMetricSource{}
			}
			if err := m.ContainerResource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.External == nil {
				m.External = &ExternalMetricSource{}
			}
			if err := m.External.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetricSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetricSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetricSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescribedObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DescribedObject == nil {
				m.DescribedObject = &ObjectReference{}
			}
			if err := m.DescribedObject.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &MetricTarget{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricIdentifier{}
			}
			if err := m.Metric.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricTarget) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricTarget: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricTarget: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetricIdentifier) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetricIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetricIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelSelector = append(m.LabelSelector, &LabelSelectorRequirement{})
			if err := m.LabelSelector[len(m.LabelSelector)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodsMetricSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodsMetricSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodsMetricSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricIdentifier{}
			}
			if err := m.Metric.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &MetricTarget{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceMetricSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceMetricSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceMetricSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &MetricTarget{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerResourceMetricSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerResourceMetricSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerResourceMetricSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &MetricTarget{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalMetricSource) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalMetricSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalMetricSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricIdentifier{}
			}
			if err := m.Metric.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &MetricTarget{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscalerBehavior) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerBehavior: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerBehavior: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleUp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleUp == nil {
				m.ScaleUp = &HPAScalingRules{}
			}
			if err := m.ScaleUp.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScaleDown", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ScaleDown == nil {
				m.ScaleDown = &HPAScalingRules{}
			}
			if err := m.ScaleDown.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPAScalingRules) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPAScalingRules: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPAScalingRules: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StabilizationWindowSeconds", wireType)
			}
			m.StabilizationWindowSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StabilizationWindowSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectPolicy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Policies = append(m.Policies, &HPAScalingPolicy{})
			if err := m.Policies[len(m.Policies)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPAScalingPolicy) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPAScalingPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPAScalingPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodSeconds", wireType)
			}
			m.PeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PeriodSeconds |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscalerStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObservedGeneration", wireType)
			}
			m.ObservedGeneration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ObservedGeneration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastScaleTime", wireType)
			}
			m.LastScaleTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastScaleTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentReplicas", wireType)
			}
			m.CurrentReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurrentReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DesiredReplicas", wireType)
			}
			m.DesiredReplicas = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DesiredReplicas |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurrentMetrics = append(m.CurrentMetrics, &HorizontalPodAutoscalerMetricStatus{})
			if err := m.CurrentMetrics[len(m.CurrentMetrics)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscalerCondition) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionType = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConditionStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConditionStatus = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTransitionTime", wireType)
			}
			m.LastTransitionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTransitionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HorizontalPodAutoscalerMetricStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerMetricStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HorizontalPodAutoscalerMetricStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Object", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Object == nil {
				m.Object = &ObjectMetricStatus{}
			}
			if err := m.Object.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pods", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pods == nil {
				m.Pods = &PodsMetricStatus{}
			}
			if err := m.Pods.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Resource == nil {
				m.Resource = &ResourceMetricStatus{}
			}
			if err := m.Resource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerResource == nil {
				m.ContainerResource = &ContainerResourceMetricStatus{}
			}
			if err := m.ContainerResource.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.External == nil {
				m.External = &ExternalMetricStatus{}
			}
			if err := m.External.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMetricStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMetricStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMetricStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DescribedObject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DescribedObject == nil {
				m.DescribedObject = &ObjectReference{}
			}
			if err := m.DescribedObject.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Current |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricIdentifier{}
			}
			if err := m.Metric.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PodsMetricStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PodsMetricStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PodsMetricStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricIdentifier{}
			}
			if err := m.Metric.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Current |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceMetricStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceMetricStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceMetricStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Current |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerResourceMetricStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerResourceMetricStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerResourceMetricStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Current |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalMetricStatus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalMetricStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalMetricStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metric", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgent
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metric == nil {
				m.Metric = &MetricIdentifier{}
			}
			if err := m.Metric.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Current", wireType)
			}
			m.Current = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Current |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgent(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgent
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgent(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgent
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgent
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAgent
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAgent
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAgent(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAgent = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgent   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/process/agent.proto", fileDescriptorAgent) }

var fileDescriptorAgent = []byte{
	// 10024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0xbd, 0x6f, 0x6c, 0x24, 0xc9,
	0x75, 0x18, 0x7e, 0x3d, 0xff, 0xe7, 0xf1, 0x5f, 0xb3, 0x96, 0xcb, 0x9d, 0xe3, 0xed, 0xad, 0x56,
	0x2d, 0xe9, 0xb4, 0x5a, 0x9d, 0xf6, 0xee, 0xb7, 0xba, 0x3b, 0xed, 0xdd, 0x49, 0xa7, 0x23, 0x87,
	0xdc, 0x5d, 0x72, 0xf9, 0x67, 0x5c, 0x43, 0xee, 0xc9, 0x27, 0x19, 0x52, 0xb3, 0xbb, 0x48, 0xb6,
	0xd8, 0xd3, 0x3d, 0xea, 0xee, 0xe1, 0x2e, 0xcf, 0xf0, 0x07, 0xff, 0x14, 0x27, 0x30, 0x10, 0x23,
	0x82, 0xe3, 0xc0, 0x71, 0x82, 0x04, 0x70, 0xfe, 0x21, 0x76, 0x22, 0x25, 0xfa, 0x14, 0x24, 0x9f,
	0x12, 0x03, 0x81, 0x03, 0x1b, 0x30, 0x12, 0xd8, 0x40, 0x8c, 0x20, 0x01, 0x1c, 0x29, 0x0e, 0x12,
	0x7f, 0x08, 0x90, 0x0f, 0x71, 0x80, 0x18, 0x48, 0x82, 0xfa, 0xd7, 0x5d, 0xdd, 0xd3, 0x3d, 0x33,
	0x24, 0xf7, 0x8e, 0x27, 0xe4, 0xd3, 0x4c, 0xbd, 0xaa, 0xf7, 0xaa, 0xea, 0xd5, 0x7b, 0xaf, 0x5e,
	0x55, 0xbd, 0xaa, 0x86, 0xe7, 0xfb, 0x81, 0x1f, 0xf9, 0xaf, 0xf4, 0x03, 0xdf, 0x22, 0x61, 0xf8,
	0x8a, 0x79, 0x48, 0xbc, 0xe8, 0x0e, 0x83, 0xa1, 0xab, 0xb6, 0x19, 0x99, 0xb6, 0x7f, 0x78, 0x47,
	0x64, 0x7e, 0x93, 0x65, 0x1a, 0xbf, 0xa3, 0xc1, 0x34, 0x26, 0x61, 0xdb, 0x77, 0x5d, 0x62, 0x45,
	0x7e, 0x80, 0x56, 0xa0, 0x76, 0x44, 0x4c, 0x9b, 0x04, 0x2d, 0xed, 0xa6, 0x76, 0x6b, 0xea, 0xee,
	0xed, 0x3b, 0xb9, 0x88, 0x77, 0x54, 0xa4, 0x3b, 0x0f, 0x19, 0x06, 0x16, 0x98, 0xa8, 0x05, 0xf5,
	0x1e, 0x09, 0x43, 0xf3, 0x90, 0xb4, 0x4a, 0x37, 0xb5, 0x5b, 0x4d, 0x2c, 0x93, 0xe8, 0x1d, 0xa8,
	0x85, 0x91, 0x19, 0x0d, 0xc2, 0x56, 0x99, 0x51, 0x7f, 0xa9, 0x80, 0x7a, 0x4c, 0xba, 0xcb, 0x4a,
	0x63, 0x81, 0xb5, 0x74, 0x1d, 0x6a, 0xbc, 0x2e, 0x84, 0xa0, 0x12, 0x9d, 0xf6, 0x49, 0xab, 0x72,
	0x53, 0xbb, 0x55, 0xc5, 0xec, 0xbf, 0xf1, 0xbf, 0xca, 0x30, 0x13, 0x63, 0x76, 0x02, 0xdf, 0x42,
	0x4b, 0xd0, 0x38, 0xf2, 0xc3, 0x68, 0xdb, 0xec, 0xc9, 0xa6, 0xc4, 0x69, 0xf4, 0x65, 0x68, 0x8a,
	0x4a, 0x09, 0x6d, 0x4e, 0xf9, 0xd6, 0xd4, 0xdd, 0x1b, 0x05, 0xcd, 0xe9, 0xf0, 0x14, 0x4e, 0x10,
	0xd0, 0x2b, 0x50, 0xa1, 0x94, 0x58, 0xfd, 0x53, 0x77, 0x5f, 0x28, 0x40, 0x7c, 0xe8, 0x87, 0x11,
	0x66, 0x05, 0xd1, 0xeb, 0x50, 0x71, 0xbc, 0x03, 0xbf, 0x55, 0x65, 0x08, 0x9f, 0x2c, 0x40, 0xe8,
	0x9e, 0x86, 0x11, 0xe9, 0xad, 0x7b, 0x07, 0x3e, 0x66, 0xc5, 0x29, 0x2f, 0x0f, 0x03, 0x7f, 0xd0,
	0x5f, 0xb7, 0x5b, 0x35, 0xd6, 0x55, 0x99, 0x44, 0xd7, 0xa1, 0xc9, 0xfe, 0x76, 0x9d, 0x0f, 0x48,
	0xab, 0xce, 0xf2, 0x12, 0x00, 0x7a, 0x17, 0xc0, 0xf2, 0xbd, 0xc8, 0x74, 0x3c, 0x12, 0x84, 0x2d,
	0x60, 0xdd, 0xbb, 0x59, 0xc8, 0x6d, 0x51, 0x10, 0x2b, 0x38, 0x94, 0xbe, 0x47, 0xa2, 0x27, 0x7e,
	0x70, 0xbc, 0x6e, 0xb7, 0xa6, 0x18, 0xf3, 0x12, 0x00, 0x7a, 0x0c, 0xf3, 0x71, 0x59, 0xda, 0xcb,
	0x5d, 0x3a, 0x18, 0xd3, 0x37, 0xb5, 0x5b, 0xb3, 0x77, 0x6f, 0x8d, 0xab, 0x46, 0x96, 0xc7, 0xc3,
	0x24, 0xd0, 0x75, 0x68, 0x1c, 0x39, 0x5e, 0xb4, 0x65, 0x86, 0xc7, 0xad, 0x59, 0xda, 0xa9, 0x87,
	0xcf, 0xe1, 0x18, 0xb2, 0x52, 0x87, 0x2a, 0xfd, 0x1f, 0x6e, 0x54, 0x1a, 0x33, 0xfa, 0xec, 0x46,
	0xa5, 0xd1, 0xd0, 0x9b, 0x1b, 0x95, 0x46, 0x53, 0x07, 0xe3, 0x4f, 0x35, 0x58, 0x4c, 0x0d, 0xfe,
	0xaa, 0x13, 0x5a, 0xfe, 0x09, 0x09, 0x4e, 0x53, 0x52, 0xa0, 0x65, 0xa4, 0x40, 0xe1, 0x6f, 0x69,
	0x04, 0x7f, 0xcb, 0x59, 0xfe, 0xbe, 0x07, 0x48, 0xf4, 0x4e, 0xd6, 0xe3, 0x90, 0xb0, 0x55, 0x61,
	0x7c, 0xfe, 0xec, 0x68, 0x31, 0x8a, 0x1b, 0x86, 0x73, 0x48, 0xc4, 0x82, 0x55, 0x9d, 0x50, 0xb0,
	0x8c, 0x1f, 0x96, 0x61, 0x3e, 0xee, 0x38, 0x26, 0xa6, 0xbb, 0xeb, 0xf4, 0xc8, 0x48, 0xc9, 0xbf,
	0x07, 0x55, 0xaa, 0x4f, 0x52, 0xea, 0x8d, 0xd1, 0xcd, 0xa5, 0x2a, 0x88, 0x39, 0x02, 0x5a, 0x84,
	0x1a, 0xa5, 0xb2, 0x6e, 0x33, 0xb9, 0x2f, 0x63, 0x91, 0x42, 0x0b, 0x50, 0xf5, 0x83, 0xc3, 0x75,
	0x9b, 0xb5, 0xba, 0x8a, 0x79, 0xe2, 0xdc, 0xb2, 0xdb, 0x82, 0xba, 0x37, 0xe8, 0xb5, 0xfb, 0x83,
	0xb0, 0xd5, 0xe0, 0x78, 0x22, 0x89, 0x6e, 0xc2, 0x54, 0xe4, 0x47, 0xa6, 0xbb, 0x45, 0x7a, 0x7e,
	0x70, 0xda, 0x6a, 0xb2, 0x46, 0xa8, 0x20, 0xb4, 0x09, 0xb3, 0xb1, 0x50, 0x75, 0x59, 0x27, 0xb9,
	0xec, 0x7f, 0x7a, 0x9c, 0x50, 0xb2, 0x6e, 0x66, 0x70, 0xf3, 0xa5, 0x7c, 0xea, 0xc2, 0x52, 0x6e,
	0xfc, 0x4a, 0x19, 0x50, 0x3c, 0x66, 0x31, 0xc6, 0x48, 0x41, 0x95, 0xf6, 0xa3, 0x74, 0x36, 0xfb,
	0x91, 0xb6, 0x03, 0xe5, 0x73, 0xd8, 0x01, 0x65, 0x14, 0x2b, 0x23, 0x46, 0xb1, 0x9a, 0x1d, 0x45,
	0x29, 0xc8, 0x8d, 0x49, 0x2d, 0x64, 0x2e, 0xb3, 0x9b, 0xcf, 0xc2, 0xa4, 0x8c, 0x30, 0x64, 0x1b,
	0x95, 0x46, 0x4d, 0xaf, 0x6f, 0x54, 0x1a, 0x75, 0xbd, 0x61, 0xfc, 0x61, 0x09, 0x96, 0x86, 0x87,
	0x25, 0x57, 0xa7, 0xb2, 0xc3, 0xf3, 0x96, 0xd4, 0xa9, 0xd2, 0x19, 0xc4, 0x4d, 0x68, 0x95, 0x22,
	0xef, 0xe5, 0x91, 0xf2, 0x5e, 0x19, 0x96, 0xf7, 0x44, 0x23, 0xab, 0x29, 0x8d, 0x3c, 0xaf, 0xee,
	0xe5, 0x0e, 0x42, 0xe3, 0xe2, 0x12, 0xff, 0xaa, 0x22, 0xf0, 0x98, 0x7c, 0x87, 0xcf, 0xeb, 0xa3,
	0xac, 0x94, 0xf1, 0xab, 0x25, 0x98, 0x4e, 0x0c, 0xba, 0x6f, 0x8f, 0x64, 0xff, 0x4d, 0x98, 0xb2,
	0xdc, 0x41, 0x18, 0x91, 0x40, 0xa1, 0xa5, 0x82, 0x68, 0xb7, 0x45, 0x72, 0xdd, 0x66, 0x6c, 0x6e,
	0xe2, 0x04, 0x70, 0x6e, 0x21, 0xbf, 0x03, 0x95, 0xbe, 0x6f, 0x87, 0xad, 0x1a, 0x1b, 0xf5, 0xa5,
	0x22, 0x4b, 0xea, 0xdb, 0x98, 0x95, 0x8b, 0x95, 0xa2, 0x3e, 0xa9, 0x52, 0x50, 0x3f, 0xc7, 0x3c,
	0xa4, 0x86, 0xb0, 0x7c, 0xab, 0x89, 0xd9, 0x7f, 0xe3, 0x3f, 0x6b, 0x70, 0x45, 0x61, 0x66, 0xdf,
	0x75, 0x2c, 0xb3, 0x4b, 0xa2, 0x2c, 0x13, 0xb4, 0x31, 0x4c, 0x28, 0x8d, 0x60, 0x42, 0x79, 0x04,
	0x13, 0x2a, 0x59, 0x26, 0xb4, 0x61, 0x2a, 0x88, 0x5b, 0x11, 0xb6, 0xaa, 0x8c, 0x17, 0x9f, 0x2c,
	0x74, 0x1c, 0x65, 0x49, 0xac, 0x62, 0xc5, 0x1d, 0xad, 0x15, 0x75, 0x74, 0x95, 0xf4, 0x5d, 0xff,
	0xb4, 0x47, 0xbc, 0x4b, 0xed, 0xa8, 0x1d, 0xb7, 0x62, 0x5c, 0x47, 0x93, 0xf6, 0x62, 0x15, 0x2b,
	0xb7, 0xa3, 0xff, 0x4e, 0x03, 0x3d, 0xf1, 0x79, 0x49, 0x70, 0xe2, 0x58, 0xe4, 0xd2, 0x7a, 0xf9,
	0x16, 0x34, 0x42, 0xde, 0x04, 0xd9, 0xc5, 0x22, 0xbf, 0x58, 0xb4, 0x14, 0xc7, 0xe5, 0x73, 0x3b,
	0xf7, 0x57, 0x55, 0xb7, 0x7c, 0xdb, 0xb7, 0x2f, 0xaf, 0x67, 0xff, 0x1f, 0x54, 0x3d, 0xdf, 0x8e,
	0xbb, 0x55, 0xa4, 0x7e, 0xb4, 0x8d, 0x98, 0x97, 0xcc, 0xeb, 0x10, 0x3a, 0x00, 0x9d, 0xea, 0xe6,
	0xb2, 0xeb, 0x98, 0xe1, 0x96, 0xd9, 0xef, 0x3b, 0xde, 0x61, 0xab, 0xce, 0x28, 0xbe, 0x35, 0x6e,
	0x3d, 0x43, 0x49, 0x33, 0xf5, 0x56, 0x91, 0xd7, 0xbc, 0x28, 0x38, 0xc5, 0x43, 0x34, 0x97, 0xbe,
	0x05, 0x57, 0x73, 0x8b, 0x22, 0x1d, 0xca, 0xc7, 0xe4, 0x54, 0xf0, 0x8d, 0xfe, 0xa5, 0x3d, 0x3b,
	0x31, 0xdd, 0x01, 0x11, 0xee, 0xc1, 0x48, 0xc3, 0xc2, 0x4b, 0xbe, 0x55, 0xba, 0xa7, 0x19, 0x7f,
	0xa8, 0xca, 0x5d, 0x9b, 0xf3, 0xf7, 0xd2, 0x46, 0xe7, 0x1e, 0xd4, 0x05, 0x11, 0xe1, 0xfc, 0x16,
	0x89, 0x9d, 0x68, 0x28, 0x96, 0xc5, 0x73, 0xa5, 0xee, 0x77, 0x34, 0xc5, 0x2d, 0xde, 0x32, 0x3d,
	0xe7, 0x80, 0x84, 0x97, 0x67, 0x39, 0xbe, 0x02, 0xcd, 0x9e, 0x68, 0x83, 0x94, 0xbe, 0x4f, 0x14,
	0xf4, 0x4e, 0xb6, 0x15, 0x27, 0x18, 0xc6, 0x37, 0x60, 0x61, 0xa8, 0x2f, 0x6d, 0xbc, 0x8a, 0x56,
	0xa1, 0x21, 0x0b, 0x89, 0xf5, 0xfa, 0xad, 0x71, 0x12, 0x18, 0x93, 0x8f, 0x31, 0x8d, 0xaf, 0x2b,
	0x56, 0x36, 0xa1, 0xfe, 0x8c, 0x88, 0xff, 0x48, 0x53, 0x66, 0x7e, 0xca, 0xe1, 0xb0, 0x6f, 0x5e,
	0xa2, 0x71, 0x7b, 0x17, 0xc0, 0x93, 0x8d, 0x90, 0x23, 0x51, 0xe4, 0x0f, 0xc7, 0xad, 0xc5, 0x0a,
	0x4e, 0x91, 0xb0, 0x25, 0xbe, 0xca, 0x86, 0xbf, 0x7f, 0x69, 0xdd, 0xbb, 0x03, 0x95, 0x6f, 0xfb,
	0xfb, 0xb2, 0x63, 0x45, 0xfe, 0xc8, 0x86, 0xbf, 0x8f, 0x59, 0xb9, 0xf1, 0x93, 0x51, 0x3b, 0xf0,
	0xbd, 0xcb, 0xec, 0xd0, 0x5b, 0xd0, 0xb0, 0x78, 0x13, 0xc6, 0x4d, 0x46, 0xa2, 0xa5, 0x38, 0x2e,
	0x9f, 0xdb, 0xb9, 0x94, 0x38, 0xae, 0x9a, 0xa4, 0xe7, 0x7b, 0x97, 0xe9, 0x3a, 0xbd, 0x0b, 0x60,
	0xcb, 0x46, 0x8c, 0x13, 0xc7, 0xb8, 0xb5, 0x58, 0xc1, 0xc9, 0xed, 0xe4, 0x9f, 0x68, 0x8a, 0xbd,
	0xa0, 0xae, 0x36, 0x39, 0x18, 0xb8, 0x97, 0xd9, 0xcd, 0xfb, 0x30, 0x1d, 0x26, 0xcd, 0x90, 0x1d,
	0x2d, 0xda, 0x78, 0x50, 0x5a, 0x8c, 0x53, 0x78, 0xb9, 0x9d, 0xfd, 0xdf, 0x1a, 0x3c, 0x9f, 0xac,
	0x13, 0x48, 0x10, 0x3a, 0x61, 0x44, 0xbc, 0xe8, 0xb1, 0xef, 0x0e, 0x7a, 0x97, 0x67, 0x67, 0xf6,
	0x60, 0xbe, 0x9f, 0x69, 0x8b, 0xec, 0x76, 0xe1, 0xf6, 0x50, 0xa6, 0x3c, 0x1e, 0xa6, 0x90, 0xcb,
	0x80, 0x5f, 0x2e, 0xc1, 0x8d, 0x42, 0x06, 0xb4, 0x5d, 0xd3, 0xe9, 0x5d, 0x1a, 0x17, 0x6c, 0x58,
	0xec, 0xe7, 0x35, 0x48, 0xb2, 0xe2, 0xe5, 0x09, 0x59, 0xc1, 0x90, 0x70, 0x01, 0xad, 0x5c, 0xa6,
	0xfc, 0x9e, 0xa6, 0x38, 0x9d, 0xd8, 0x77, 0x2f, 0xd5, 0xe9, 0x0c, 0x7c, 0x77, 0xac, 0xd3, 0x49,
	0xdb, 0x88, 0x79, 0xc9, 0xf1, 0x3a, 0x4d, 0x0b, 0xaf, 0x38, 0x9e, 0xed, 0x78, 0x87, 0x97, 0xa9,
	0xd3, 0x41, 0xd2, 0x8c, 0x71, 0x3a, 0xad, 0xb4, 0x18, 0xa7, 0xf0, 0xc6, 0x77, 0x56, 0xba, 0x7b,
	0x97, 0x39, 0x88, 0xf7, 0x61, 0xda, 0x4a, 0x9a, 0x31, 0xae, 0xb3, 0x4a, 0x8b, 0x71, 0x0a, 0x2f,
	0xb7, 0xb3, 0x7f, 0xbe, 0x04, 0x2f, 0xe4, 0x75, 0xf6, 0xb2, 0x07, 0xf8, 0xeb, 0x70, 0xc5, 0x1a,
	0x6a, 0x8d, 0xec, 0xfa, 0xe7, 0xc6, 0x77, 0x5d, 0x0e, 0x77, 0x1e, 0x95, 0x5c, 0x46, 0xfc, 0xa9,
	0x06, 0xd7, 0xb2, 0xab, 0xe0, 0x65, 0xcb, 0xf2, 0x07, 0x97, 0xb8, 0xe4, 0xdf, 0x81, 0xb9, 0x30,
	0xd5, 0x12, 0xc9, 0x80, 0xcf, 0x8c, 0x5e, 0x13, 0x8b, 0xd2, 0x38, 0x8b, 0x9d, 0xdb, 0xf1, 0x7f,
	0xaf, 0x7a, 0x5c, 0xeb, 0xde, 0x61, 0x40, 0xc2, 0xf0, 0xd2, 0x7a, 0xfc, 0x65, 0x68, 0x3a, 0xbc,
	0x09, 0x63, 0xd7, 0xff, 0xa2, 0xa9, 0x38, 0x41, 0x18, 0x3f, 0x41, 0x3d, 0x26, 0x41, 0xe4, 0x58,
	0xa6, 0xdb, 0xf1, 0xed, 0xe5, 0x41, 0xe4, 0x87, 0x96, 0xe9, 0x5e, 0xe2, 0x9a, 0xd3, 0x86, 0xc5,
	0x93, 0xbc, 0x06, 0x8d, 0x9b, 0xa0, 0x72, 0x7b, 0x81, 0x0b, 0x68, 0xe5, 0x32, 0xe5, 0xaf, 0x95,
	0xe0, 0x66, 0xcc, 0x94, 0x87, 0x7e, 0xe0, 0x7c, 0xe0, 0x7b, 0xd1, 0xc7, 0x85, 0x2d, 0xdf, 0x86,
	0xd6, 0x51, 0x7e, 0x93, 0x24, 0x63, 0xee, 0x14, 0xee, 0x30, 0xe4, 0xa2, 0xe1, 0x42, 0x7a, 0xb9,
	0xcc, 0xe9, 0xc2, 0x5c, 0xe6, 0x08, 0x18, 0x7d, 0x1a, 0x66, 0x4c, 0x2b, 0x72, 0x4e, 0x48, 0xdb,
	0x75, 0xd8, 0xee, 0x9b, 0xc6, 0x1a, 0x9d, 0x06, 0xa2, 0x25, 0x68, 0x38, 0x5e, 0x44, 0x82, 0x13,
	0xd3, 0x15, 0xe7, 0x79, 0x71, 0xda, 0xf8, 0xc5, 0x3a, 0xd4, 0xc5, 0x99, 0x96, 0xba, 0x83, 0x32,
	0xc3, 0x77, 0x50, 0x74, 0x28, 0xf7, 0x1d, 0x79, 0x08, 0x48, 0xff, 0xc6, 0x7b, 0xb5, 0xe5, 0x49,
	0xf7, 0x6a, 0xef, 0x41, 0xdd, 0xf2, 0x7b, 0x3d, 0xd3, 0xb3, 0xc5, 0xb1, 0x70, 0xe1, 0x52, 0x85,
	0x97, 0xc2, 0xb2, 0x38, 0x7a, 0x03, 0x2a, 0x83, 0x30, 0xde, 0xf7, 0x18, 0x73, 0x20, 0xb7, 0x17,
	0x92, 0x00, 0xb3, 0xf2, 0xe8, 0x4d, 0xa8, 0xf5, 0xf8, 0xd1, 0x40, 0x7d, 0xe4, 0xb1, 0x10, 0x3f,
	0x2c, 0x60, 0x67, 0x0e, 0x02, 0x01, 0xbd, 0x0a, 0x65, 0xab, 0x3f, 0x10, 0xa7, 0x33, 0x85, 0x0d,
	0xed, 0xec, 0x31, 0x24, 0x5a, 0x14, 0xdd, 0x00, 0xb0, 0x02, 0x62, 0x46, 0x64, 0xd7, 0xe9, 0x11,
	0x71, 0xf6, 0xa6, 0x40, 0xd0, 0x3b, 0xd0, 0x8c, 0xf7, 0xfd, 0x5b, 0xc0, 0xe8, 0x8e, 0x3f, 0x69,
	0x4a, 0x50, 0xa8, 0xb0, 0xfb, 0x7d, 0xe2, 0xdd, 0xb7, 0xdb, 0xd4, 0x52, 0xb2, 0x93, 0x9a, 0x2a,
	0x56, 0x41, 0xe8, 0x4d, 0x7e, 0xc8, 0x22, 0x0f, 0x9a, 0x3f, 0x35, 0xfe, 0xe0, 0x92, 0xf0, 0x33,
	0x16, 0x82, 0x5e, 0x87, 0x9a, 0xe3, 0x53, 0x48, 0x6b, 0x86, 0xb5, 0xec, 0xc5, 0x22, 0x93, 0xb6,
	0xc3, 0xb9, 0xc4, 0x0b, 0x33, 0x05, 0x94, 0x0d, 0x5c, 0xb7, 0xd9, 0x89, 0x34, 0x55, 0xc0, 0x04,
	0x84, 0x0c, 0x98, 0x8e, 0x93, 0x8f, 0xc8, 0x69, 0x6b, 0x8e, 0x89, 0x54, 0x0a, 0x86, 0xee, 0xc2,
	0xc2, 0x89, 0xef, 0x0e, 0xbc, 0xc8, 0x0c, 0x4e, 0xdb, 0xd1, 0xd3, 0xee, 0x13, 0x27, 0xb2, 0x8e,
	0x48, 0xd8, 0xd2, 0x6f, 0x6a, 0xb7, 0x2a, 0x38, 0x37, 0x0f, 0xbd, 0x01, 0x8b, 0x8e, 0x97, 0x8b,
	0x35, 0xcf, 0xb0, 0x0a, 0x72, 0xa9, 0xca, 0xef, 0x9f, 0x46, 0x84, 0x36, 0x05, 0xdd, 0xd4, 0x6e,
	0x4d, 0x63, 0x99, 0x44, 0xb7, 0x41, 0x8f, 0x5b, 0xb5, 0x22, 0x8a, 0x5c, 0x61, 0x45, 0x86, 0xe0,
	0x68, 0x01, 0xaa, 0x5e, 0xd8, 0x71, 0xec, 0xd6, 0x02, 0x3f, 0xd0, 0x65, 0x09, 0xb4, 0x02, 0x0d,
	0x71, 0x70, 0x16, 0xb6, 0xae, 0x8e, 0x0c, 0xe0, 0x10, 0x43, 0xb0, 0x2d, 0x4a, 0xe3, 0x18, 0x8f,
	0x9f, 0xb7, 0x19, 0xbf, 0x5a, 0x02, 0x3d, 0x7b, 0x1c, 0x2e, 0x55, 0x50, 0x4b, 0x54, 0x30, 0x6e,
	0x46, 0x49, 0x6d, 0xc6, 0x4f, 0x80, 0x62, 0xa6, 0x75, 0xa5, 0x36, 0xa4, 0x2b, 0xca, 0x28, 0xd5,
	0x53, 0xa3, 0x64, 0x7c, 0x5f, 0x83, 0xba, 0x68, 0x06, 0x35, 0x8d, 0x66, 0x70, 0x48, 0x4d, 0x1d,
	0x33, 0x8d, 0xf4, 0x3f, 0x65, 0x92, 0xf5, 0x44, 0x9e, 0x60, 0xd1, 0xbf, 0xb4, 0x54, 0xe0, 0xfb,
	0x3c, 0x14, 0xa5, 0x89, 0xd9, 0x7f, 0xb4, 0x08, 0x35, 0xdf, 0x5b, 0x75, 0xc2, 0x63, 0xd6, 0xf2,
	0x06, 0x16, 0x29, 0x5a, 0xb6, 0x4f, 0x79, 0xcc, 0xcf, 0x04, 0xd9, 0x7f, 0x5a, 0xb6, 0xcf, 0x4c,
	0xbf, 0x38, 0x0d, 0x14, 0x29, 0x5a, 0x13, 0x79, 0xca, 0x0f, 0xff, 0x9a, 0x98, 0xfe, 0xa5, 0xd8,
	0x94, 0x31, 0x4c, 0xf7, 0x9b, 0x98, 0xfd, 0x37, 0xfe, 0x8a, 0x06, 0x53, 0x4a, 0xff, 0x69, 0x19,
	0x2f, 0x99, 0xab, 0xd8, 0x7f, 0x4a, 0x69, 0x90, 0xd8, 0xd6, 0x81, 0x63, 0x53, 0xc8, 0xa1, 0x23,
	0x27, 0x25, 0xfa, 0x97, 0xe2, 0x11, 0x5a, 0x48, 0x04, 0xf4, 0xd0, 0xff, 0x0c, 0x46, 0x8b, 0x55,
	0x05, 0x4c, 0x94, 0x0b, 0x07, 0x49, 0x0f, 0x42, 0x51, 0x2e, 0xa4, 0xe5, 0xea, 0x02, 0x76, 0xe8,
	0xd8, 0xc6, 0x7b, 0x30, 0x97, 0x11, 0x42, 0xf4, 0x12, 0x8b, 0x0d, 0xf0, 0x88, 0x15, 0x39, 0xbe,
	0x87, 0xa9, 0x1d, 0xa1, 0x8d, 0x2c, 0xe1, 0x0c, 0x94, 0xce, 0x8d, 0x74, 0x34, 0x42, 0x56, 0xa4,
	0xc4, 0x8a, 0x24, 0x00, 0xe3, 0x84, 0x2e, 0x2c, 0x85, 0xba, 0x2c, 0xdb, 0x76, 0x80, 0x66, 0xa1,
	0xe4, 0xf4, 0x45, 0x7f, 0x4b, 0x4e, 0x9f, 0xf1, 0xd8, 0x0f, 0x22, 0xd1, 0x5d, 0xf6, 0x1f, 0x2d,
	0x43, 0x83, 0xc5, 0x61, 0x59, 0xbe, 0xcb, 0x3a, 0x3d, 0x5b, 0xe8, 0x3f, 0xb6, 0xe3, 0xb6, 0xb0,
	0xa3, 0xd4, 0x18, 0xcd, 0xf8, 0xfd, 0x3a, 0x34, 0x93, 0x50, 0x01, 0x19, 0xff, 0x24, 0xd8, 0x4c,
	0xff, 0xb3, 0x86, 0x48, 0x27, 0xa0, 0xc4, 0xd9, 0xc2, 0x86, 0xa2, 0xac, 0x0c, 0xc5, 0x02, 0x54,
	0x9d, 0x9e, 0x79, 0x48, 0x84, 0xb4, 0xf0, 0x04, 0x9d, 0x36, 0xad, 0xfe, 0x60, 0xd3, 0xe9, 0x39,
	0x3c, 0xf0, 0xa4, 0x84, 0xe3, 0x34, 0x35, 0x81, 0x7c, 0xca, 0xe0, 0xd9, 0x35, 0x66, 0x7d, 0x54,
	0x10, 0x7a, 0x5b, 0x9a, 0xe5, 0xc6, 0xb8, 0x9e, 0x25, 0x67, 0xdf, 0xb1, 0x61, 0x7e, 0x87, 0x05,
	0x9c, 0xb9, 0xd1, 0x91, 0x38, 0xea, 0x7f, 0x69, 0xec, 0x29, 0x33, 0x2b, 0x8d, 0x05, 0x16, 0xd5,
	0x24, 0xae, 0x57, 0x36, 0x9b, 0x73, 0xca, 0x58, 0x26, 0x99, 0x5e, 0xec, 0xf7, 0x43, 0x36, 0x91,
	0x94, 0x30, 0xfb, 0x4f, 0x61, 0x4f, 0x28, 0x6c, 0x9a, 0xc3, 0xe8, 0x7f, 0xe9, 0x0b, 0xcc, 0x24,
	0xbe, 0x00, 0x8f, 0x18, 0xc0, 0xd6, 0x89, 0xdd, 0x09, 0x99, 0xcd, 0x2f, 0xe1, 0x04, 0x20, 0x72,
	0xbb, 0xc4, 0x8b, 0x3a, 0x21, 0x33, 0xf7, 0x3c, 0x97, 0x03, 0xa8, 0xe6, 0x8b, 0xa2, 0x2b, 0x7d,
	0x6e, 0xe1, 0x4b, 0x58, 0x81, 0x88, 0x7c, 0x5a, 0x98, 0xe6, 0xcf, 0xc7, 0xf9, 0x02, 0x42, 0xfb,
	0x43, 0x2d, 0x48, 0xc7, 0x8a, 0x98, 0xfd, 0x2e, 0x61, 0x99, 0xa4, 0xf5, 0x86, 0x2c, 0xbc, 0x83,
	0xe6, 0x5d, 0xe1, 0xf5, 0xc6, 0x00, 0x3a, 0x84, 0x2c, 0x2e, 0x80, 0x66, 0x2e, 0xf0, 0x21, 0x94,
	0x69, 0xaa, 0xe1, 0x3d, 0xd2, 0xc3, 0x21, 0xb7, 0xda, 0x15, 0x2c, 0x52, 0x14, 0xa7, 0x47, 0x7a,
	0x6d, 0xd3, 0x3a, 0x22, 0xad, 0x45, 0x96, 0x13, 0xa7, 0x63, 0x23, 0x7b, 0x6d, 0x52, 0x23, 0xdb,
	0x82, 0x7a, 0x18, 0x99, 0x01, 0x1d, 0x88, 0x16, 0x1f, 0x08, 0x91, 0x54, 0x8d, 0xdd, 0xf3, 0xe9,
	0x29, 0x49, 0xfa, 0x7e, 0x4b, 0xca, 0xe9, 0xda, 0x0a, 0x34, 0x4d, 0xdb, 0x16, 0xeb, 0x8f, 0x17,
	0x26, 0x8b, 0xa6, 0xa0, 0x7a, 0x88, 0x13, 0x34, 0x16, 0x37, 0x71, 0x14, 0x10, 0x53, 0xb8, 0x12,
	0xd7, 0xb9, 0xcc, 0x2a, 0xa0, 0xa4, 0x04, 0x97, 0xea, 0x17, 0xd5, 0x12, 0x5c, 0xaa, 0x39, 0x73,
	0xf6, 0x58, 0x18, 0xe3, 0x8d, 0x98, 0x39, 0x2c, 0xcd, 0xcc, 0x7b, 0x7f, 0xc0, 0xfe, 0x6f, 0x87,
	0xad, 0x4f, 0xf0, 0x41, 0x4c, 0x20, 0xd4, 0x29, 0xe8, 0x91, 0x9e, 0x58, 0xf3, 0x11, 0xbb, 0x75,
	0x93, 0xe1, 0xa7, 0x60, 0x22, 0xe4, 0xe4, 0xcf, 0x1a, 0xb1, 0xf9, 0x64, 0x0e, 0xc7, 0xf0, 0x1c,
	0x98, 0x9e, 0x4a, 0x4a, 0x43, 0x53, 0x49, 0xe2, 0x03, 0x96, 0xcf, 0xe9, 0x03, 0x56, 0x26, 0xf7,
	0x01, 0xa9, 0x49, 0x71, 0x2c, 0x19, 0x08, 0xc1, 0xfe, 0xd3, 0xe1, 0xe5, 0x7c, 0x0b, 0x85, 0x01,
	0x96, 0xc9, 0xac, 0x47, 0xd7, 0x18, 0xf6, 0xe8, 0x84, 0xee, 0x35, 0x13, 0xdd, 0xcb, 0x78, 0x5c,
	0x30, 0xec, 0x71, 0x6d, 0x65, 0x42, 0xbc, 0x64, 0x44, 0xd6, 0x84, 0x76, 0x27, 0x83, 0x8c, 0x1e,
	0xc0, 0x74, 0x5f, 0x71, 0x18, 0xcf, 0xe2, 0x5b, 0xa6, 0x10, 0x51, 0x07, 0xe6, 0xac, 0xb4, 0x91,
	0x62, 0xd6, 0x61, 0x72, 0x93, 0x96, 0x45, 0xa7, 0x6b, 0x9e, 0x18, 0x84, 0xf7, 0x63, 0x73, 0x92,
	0x06, 0xa6, 0x4a, 0xbd, 0xb7, 0x1f, 0x1b, 0x95, 0x34, 0x70, 0xc8, 0x4f, 0x45, 0x39, 0x7e, 0x6a,
	0xe2, 0x24, 0x5f, 0x39, 0x8b, 0x93, 0x7c, 0x07, 0x50, 0x4c, 0x66, 0x3b, 0xb6, 0x9b, 0xdc, 0x08,
	0xe5, 0xe4, 0x64, 0xcb, 0x0b, 0x4b, 0x7a, 0x75, 0xb8, 0xbc, 0x30, 0xa9, 0xaf, 0xc2, 0x95, 0x2c,
	0x15, 0x6a, 0x3b, 0x17, 0x19, 0x42, 0x5e, 0x56, 0x16, 0x43, 0x5a, 0xdb, 0x6b, 0xc3, 0x18, 0xd2,
	0xec, 0x16, 0xb9, 0xe8, 0xad, 0x73, 0xb9, 0xe8, 0xcf, 0x4f, 0xea, 0xa2, 0x2f, 0x8d, 0x77, 0xd1,
	0x5f, 0x28, 0x70, 0xd1, 0x55, 0x67, 0xfc, 0xfa, 0xf9, 0x9c, 0x71, 0xe3, 0x87, 0x1a, 0xcc, 0xd3,
	0x5c, 0x16, 0xed, 0xf8, 0x9e, 0x13, 0x1d, 0x75, 0x48, 0xd0, 0x8b, 0xd5, 0x76, 0x95, 0xab, 0xad,
	0xa6, 0xa8, 0x2d, 0x07, 0xd1, 0xa9, 0x28, 0xb1, 0xae, 0xdc, 0x24, 0x25, 0x00, 0x6a, 0xb1, 0x9e,
	0x04, 0x4e, 0x44, 0x78, 0x76, 0x99, 0x5b, 0xac, 0x04, 0x22, 0xb1, 0x69, 0x47, 0x42, 0x11, 0xd3,
	0x96, 0x00, 0x62, 0x6c, 0x9e, 0x5d, 0x55, 0xb0, 0x19, 0xc4, 0xf8, 0x23, 0x0d, 0x16, 0x87, 0xda,
	0xbc, 0x72, 0xda, 0x59, 0x5f, 0x45, 0x3f, 0x03, 0xc0, 0x22, 0xea, 0x58, 0x8a, 0x79, 0xcd, 0x53,
	0x77, 0xbf, 0x32, 0x82, 0x29, 0xc3, 0x24, 0xd8, 0xd9, 0x13, 0xc7, 0xe7, 0x51, 0x19, 0x0a, 0xc1,
	0xa5, 0x43, 0x98, 0xcb, 0x64, 0xab, 0xfb, 0x08, 0x55, 0x6e, 0xbf, 0xde, 0x49, 0x47, 0x62, 0xdc,
	0x9a, 0xb4, 0x7a, 0x35, 0x2c, 0xe3, 0x4f, 0xaa, 0x8a, 0x8f, 0xc9, 0x54, 0x8c, 0xbb, 0x76, 0x5a,
	0xec, 0xda, 0x29, 0x5e, 0x42, 0x69, 0x84, 0x97, 0x50, 0x1e, 0xe5, 0x25, 0x54, 0x32, 0x5e, 0xc2,
	0x28, 0x27, 0x30, 0xf1, 0x20, 0x6a, 0x85, 0x1e, 0x44, 0x3d, 0xe3, 0x41, 0xf0, 0x3c, 0x4e, 0xaf,
	0x11, 0xe7, 0x71, 0x7a, 0xd2, 0x37, 0x6b, 0xe6, 0xf8, 0x66, 0xa0, 0xf8, 0x66, 0x29, 0x4f, 0x6c,
	0x6a, 0xa4, 0x27, 0x36, 0x3d, 0xda, 0x13, 0x9b, 0x19, 0xe3, 0x89, 0xcd, 0x0e, 0x79, 0x62, 0xb1,
	0x5b, 0x3b, 0x77, 0x21, 0xb7, 0x56, 0x3f, 0x97, 0x5b, 0x2b, 0x04, 0x6b, 0x3e, 0x99, 0x18, 0x15,
	0xff, 0x0a, 0x15, 0xfa, 0x57, 0x57, 0xd2, 0xf6, 0x24, 0xe3, 0x07, 0x2d, 0x8c, 0xf5, 0x83, 0xae,
	0x8e, 0xf6, 0x83, 0x16, 0x47, 0xfa, 0x41, 0xd7, 0xc6, 0xfa, 0x41, 0xad, 0x61, 0x3f, 0xc8, 0xf8,
	0x07, 0x1a, 0x40, 0x12, 0xb6, 0x4c, 0xa5, 0x60, 0x30, 0x88, 0x65, 0x9d, 0xfd, 0x47, 0x5f, 0x80,
	0x92, 0x1f, 0x0a, 0x85, 0x2a, 0x9a, 0x93, 0x76, 0xba, 0x2c, 0xea, 0xb9, 0xe4, 0x53, 0x5b, 0x5e,
	0xb1, 0x78, 0x30, 0x6d, 0x79, 0xb4, 0x5f, 0xc3, 0xe3, 0xa4, 0xad, 0x9c, 0x48, 0xdb, 0xea, 0x50,
	0xa4, 0xed, 0x46, 0xa5, 0x51, 0xd1, 0xab, 0xc6, 0xf7, 0x34, 0xa8, 0xf1, 0xaa, 0x72, 0x57, 0xba,
	0x4b, 0xd0, 0xe8, 0xbb, 0x66, 0x74, 0xe0, 0x07, 0x3d, 0x19, 0xd0, 0x2a, 0xd3, 0x54, 0x87, 0x0e,
	0xcc, 0x9e, 0xe3, 0x9e, 0x8a, 0x05, 0x99, 0x48, 0xd1, 0xe1, 0x3b, 0x21, 0x41, 0xe8, 0xf8, 0x9e,
	0x58, 0x94, 0xc9, 0x24, 0x9d, 0xd9, 0x8f, 0x49, 0xe0, 0x11, 0xf7, 0xb1, 0xc8, 0xaf, 0xb2, 0xfc,
	0x34, 0x90, 0x35, 0x89, 0xcf, 0xc8, 0xb4, 0x7a, 0x3a, 0x70, 0xca, 0xda, 0x36, 0x4e, 0x53, 0x65,
	0x61, 0x56, 0x54, 0x5d, 0xd5, 0xc6, 0x00, 0x5a, 0x55, 0x6c, 0x82, 0x59, 0x09, 0x6e, 0x3a, 0xd2,
	0x40, 0xba, 0x82, 0x4e, 0x2c, 0x31, 0x2b, 0xc6, 0x8d, 0x48, 0x06, 0x6a, 0xfc, 0x43, 0x0d, 0x20,
	0xf1, 0x37, 0xa9, 0x30, 0x07, 0x21, 0xdf, 0xb1, 0xad, 0x60, 0xfa, 0x97, 0x42, 0x4e, 0x7a, 0x7c,
	0x48, 0x2b, 0x98, 0xfe, 0x65, 0x6b, 0xf8, 0x27, 0x66, 0x9f, 0xd5, 0x5b, 0xc1, 0xec, 0x3f, 0xe5,
	0x58, 0x78, 0x64, 0x06, 0x84, 0xef, 0x0a, 0x54, 0xb0, 0x48, 0xb1, 0x65, 0x03, 0x79, 0xca, 0xad,
	0x54, 0x05, 0xb3, 0xff, 0x94, 0xa2, 0xeb, 0xec, 0x0b, 0xf3, 0x44, 0xff, 0xd2, 0x52, 0x74, 0xe4,
	0x85, 0x5d, 0x62, 0xff, 0xe9, 0xf2, 0xd7, 0x76, 0x82, 0xe8, 0x54, 0x18, 0x24, 0x9e, 0x30, 0x7e,
	0xbd, 0x04, 0x75, 0xe1, 0xe6, 0xd2, 0xd1, 0x70, 0xcd, 0x30, 0x6a, 0xf7, 0x07, 0x62, 0x60, 0x65,
	0x32, 0x65, 0x3b, 0x4b, 0x19, 0xdb, 0xa9, 0xd8, 0xe3, 0xf2, 0x08, 0x7b, 0x5c, 0xc9, 0xda, 0x63,
	0x6a, 0x83, 0x06, 0xbd, 0x5d, 0xe1, 0x3e, 0x73, 0xaf, 0x5a, 0x81, 0xa0, 0x7b, 0x42, 0x94, 0x6b,
	0x23, 0xd7, 0x41, 0x5d, 0xc7, 0x3b, 0x74, 0x89, 0x74, 0xd4, 0xb9, 0x40, 0x4b, 0x4f, 0xbd, 0xae,
	0x78, 0xea, 0x4b, 0xd0, 0xa0, 0xcd, 0x62, 0x0b, 0x89, 0x06, 0x93, 0xf0, 0x38, 0x4d, 0x5b, 0xc2,
	0x9b, 0xa5, 0xee, 0xee, 0x26, 0x10, 0xe3, 0xab, 0x30, 0x93, 0xaa, 0xa6, 0x48, 0xfc, 0x8b, 0x58,
	0x64, 0xfc, 0xb1, 0xc6, 0x98, 0xcc, 0x54, 0x67, 0x11, 0x6a, 0xde, 0xa0, 0xb7, 0x2f, 0x6e, 0x99,
	0x55, 0xb1, 0x48, 0x51, 0xf8, 0x09, 0xf1, 0x6c, 0x3f, 0x10, 0xca, 0x23, 0x52, 0x85, 0xaa, 0xb3,
	0x00, 0xd5, 0x9e, 0x6f, 0x13, 0x57, 0xee, 0x66, 0xb0, 0x04, 0xed, 0x4a, 0xff, 0xe8, 0x34, 0x74,
	0x2c, 0xd3, 0x15, 0x71, 0xf1, 0x4d, 0xac, 0x40, 0x28, 0x35, 0xcb, 0x0f, 0x88, 0x08, 0x8d, 0x6f,
	0x62, 0x91, 0xa2, 0xd4, 0xe8, 0x3f, 0xb9, 0x8c, 0xe1, 0x09, 0x2a, 0x58, 0xbd, 0xa3, 0x0f, 0x04,
	0xbf, 0xe8, 0x5f, 0x76, 0xe6, 0x42, 0x67, 0x38, 0x76, 0x76, 0xd2, 0xe4, 0x67, 0x27, 0x31, 0xc0,
	0xf8, 0x91, 0x06, 0x15, 0xba, 0x2c, 0x56, 0xe6, 0xec, 0x32, 0x9b, 0xb3, 0xe3, 0x4b, 0x32, 0x25,
	0xf5, 0x92, 0x4c, 0xde, 0x26, 0x4d, 0x0b, 0xea, 0xa6, 0xeb, 0xee, 0x26, 0xa7, 0x22, 0x32, 0xa9,
	0x5e, 0x15, 0xa8, 0x8f, 0xbc, 0x2a, 0xd0, 0x18, 0xbe, 0x2a, 0x40, 0x07, 0xc7, 0x3c, 0x5c, 0xf7,
	0x6c, 0xf2, 0x54, 0xb4, 0x3a, 0x4e, 0x53, 0x43, 0x4d, 0x17, 0xdf, 0x5b, 0xbe, 0xed, 0x1c, 0x38,
	0xf1, 0x56, 0x4a, 0x0a, 0xc6, 0x0d, 0xe0, 0x46, 0xa5, 0x51, 0xd5, 0x6b, 0xc6, 0x2f, 0xd5, 0xa0,
	0x2e, 0xe3, 0x45, 0xe9, 0x2c, 0xec, 0xdb, 0x44, 0x75, 0x16, 0x13, 0x00, 0xfa, 0x19, 0x98, 0x3b,
	0x1e, 0xec, 0x13, 0x97, 0x44, 0xc2, 0x5e, 0xc9, 0x2b, 0x12, 0x5f, 0x1c, 0x7d, 0x82, 0x7c, 0xe7,
	0x51, 0x1a, 0x8b, 0xbb, 0x63, 0x59, 0x5a, 0xc8, 0x82, 0x79, 0xb3, 0xef, 0x74, 0x49, 0x70, 0x42,
	0x82, 0xb8, 0x02, 0x6e, 0xf8, 0x5f, 0x1f, 0x53, 0xc1, 0x72, 0x16, 0x8f, 0x57, 0x31, 0x4c, 0x8f,
	0xf2, 0xb6, 0xef, 0xdb, 0x6d, 0xb3, 0x6f, 0x5a, 0x4e, 0xc4, 0xaf, 0x61, 0xcc, 0x60, 0x15, 0x44,
	0x0d, 0x63, 0xdf, 0xb7, 0x97, 0x5d, 0xd7, 0xb7, 0xcc, 0xc8, 0xdc, 0x77, 0xf9, 0x0a, 0x79, 0x06,
	0x67, 0xa0, 0xe8, 0x65, 0x98, 0xe7, 0x6b, 0x6f, 0xb5, 0x28, 0xb7, 0x59, 0xc3, 0x19, 0x94, 0x2a,
	0x07, 0xc6, 0x55, 0x73, 0x5b, 0x96, 0x81, 0xb2, 0x8d, 0xcd, 0xfe, 0x40, 0x25, 0xc9, 0xcd, 0x5b,
	0x06, 0xca, 0xd6, 0xd6, 0xfd, 0x41, 0x4c, 0xac, 0xc9, 0x27, 0x7b, 0x05, 0x84, 0x6e, 0xc1, 0x5c,
	0x40, 0x42, 0x7f, 0x10, 0x58, 0x44, 0xce, 0x39, 0x7c, 0x05, 0x9e, 0x05, 0xd3, 0x9e, 0xb0, 0x4d,
	0x08, 0xc7, 0xf7, 0xa8, 0x7d, 0x08, 0x23, 0xb3, 0xd7, 0x67, 0x1e, 0x5a, 0x19, 0x0f, 0x67, 0xc4,
	0x1b, 0x3d, 0xd3, 0xca, 0x46, 0xcf, 0xbb, 0x50, 0xef, 0x91, 0x28, 0x70, 0xac, 0x50, 0x9c, 0xc9,
	0xbc, 0x54, 0x7c, 0xd7, 0x94, 0x55, 0xbd, 0xc5, 0x4b, 0x63, 0x89, 0xb6, 0xb4, 0x02, 0x0b, 0x79,
	0x52, 0x92, 0x13, 0x1f, 0xbd, 0xa0, 0x7a, 0xe5, 0x55, 0xc5, 0xd7, 0x5e, 0x5a, 0x85, 0xc5, 0x7c,
	0x41, 0x38, 0x0b, 0x15, 0xe3, 0xff, 0x94, 0xa0, 0xb1, 0x45, 0x22, 0x93, 0x4d, 0x32, 0x79, 0x96,
	0x91, 0x2a, 0x89, 0x8c, 0x21, 0x95, 0xe7, 0xb4, 0x31, 0x40, 0x6e, 0x90, 0x8b, 0x4d, 0x7d, 0xea,
	0xf2, 0xe4, 0xb2, 0xb7, 0x52, 0xc4, 0xde, 0x97, 0x61, 0xde, 0xa6, 0x6c, 0x48, 0x95, 0xe6, 0x3e,
	0xcc, 0x70, 0x06, 0xb5, 0x7f, 0xae, 0xb9, 0x4f, 0x5c, 0x69, 0x5d, 0x44, 0x8a, 0x8a, 0x87, 0xe9,
	0x79, 0x7e, 0xc4, 0x88, 0x87, 0x2c, 0xa4, 0xbd, 0x89, 0x55, 0x10, 0xda, 0x81, 0x39, 0xff, 0x09,
	0xbb, 0x12, 0x75, 0x40, 0x02, 0xe2, 0x59, 0x84, 0x5f, 0x4c, 0x29, 0x8e, 0x86, 0xd8, 0x49, 0x95,
	0xc6, 0x59, 0xec, 0x3c, 0x79, 0x6b, 0xe6, 0xcb, 0xdb, 0x0d, 0x80, 0x03, 0xc7, 0x33, 0x5d, 0xe7,
	0x03, 0x79, 0xa1, 0xb5, 0x89, 0x15, 0x88, 0xb1, 0x01, 0xb3, 0xe9, 0xca, 0xc6, 0x9d, 0x44, 0x08,
	0x46, 0x23, 0xa8, 0x1c, 0x3b, 0x9e, 0xe4, 0x3d, 0xfb, 0x6f, 0xfc, 0x1b, 0x0d, 0xe6, 0x76, 0xf6,
	0xbf, 0x4d, 0xac, 0x28, 0x45, 0x8d, 0x95, 0xd3, 0x92, 0x72, 0x63, 0x06, 0x35, 0xcf, 0xb2, 0x8b,
	0xfa, 0x2b, 0x49, 0xfd, 0x37, 0x00, 0xcc, 0xbe, 0x93, 0x76, 0xf0, 0x14, 0x48, 0x1e, 0x87, 0x6a,
	0xf9, 0x1c, 0xba, 0x0e, 0xcd, 0x03, 0x87, 0xb8, 0x76, 0xc7, 0x8c, 0x8e, 0x98, 0xa1, 0x68, 0xe2,
	0x04, 0x60, 0xfc, 0x92, 0x06, 0x53, 0x22, 0x36, 0xa5, 0xe3, 0x07, 0x85, 0xd3, 0x77, 0x7c, 0x4a,
	0x21, 0xbd, 0x57, 0x91, 0x8e, 0x4f, 0x35, 0xca, 0xca, 0xa9, 0xc6, 0x0d, 0x80, 0xc8, 0x0c, 0x0e,
	0x49, 0x44, 0x29, 0x8a, 0x4e, 0x29, 0x10, 0x4a, 0x8f, 0x4e, 0x04, 0x2c, 0x97, 0xfb, 0x36, 0x71,
	0xda, 0x78, 0x0c, 0xd7, 0x45, 0x73, 0xba, 0x24, 0xa4, 0xed, 0x5f, 0x3e, 0x38, 0x70, 0x3c, 0x27,
	0x3a, 0x6d, 0xfb, 0xde, 0x81, 0x73, 0x88, 0xde, 0x80, 0x45, 0x8b, 0x1d, 0xea, 0xaf, 0x77, 0xa8,
	0xe4, 0xfa, 0x83, 0xa8, 0x4b, 0x2c, 0xdf, 0xb3, 0xe5, 0xc1, 0x7f, 0x41, 0xae, 0xf1, 0xc7, 0x65,
	0xa8, 0xb0, 0x4b, 0x26, 0x6f, 0xd3, 0x75, 0x0b, 0xd7, 0x48, 0x11, 0xbe, 0x5e, 0x18, 0x71, 0x2f,
	0x8a, 0xe1, 0x18, 0x81, 0xce, 0xb3, 0xd4, 0xbc, 0xaf, 0xaf, 0x62, 0x79, 0x85, 0x5d, 0x24, 0x19,
	0x8f, 0xf8, 0x5f, 0x3e, 0xcf, 0x50, 0x1e, 0x89, 0x34, 0x75, 0xa2, 0x07, 0x5e, 0x68, 0x1d, 0x11,
	0x7b, 0xe0, 0x32, 0x33, 0x5c, 0x61, 0x87, 0x6f, 0x69, 0x20, 0x7a, 0x0d, 0x6a, 0x74, 0xc9, 0x17,
	0x47, 0x12, 0x5d, 0x2f, 0x68, 0xd6, 0x2e, 0x2d, 0x84, 0x45, 0x59, 0xf4, 0x66, 0x7c, 0x75, 0xbe,
	0x36, 0x72, 0x9b, 0x97, 0xf6, 0x3d, 0x7d, 0x6b, 0x1e, 0x2d, 0x42, 0xe5, 0xd4, 0xec, 0xb9, 0xfc,
	0xa4, 0x71, 0xa5, 0xd4, 0xd2, 0x30, 0x4b, 0x53, 0x73, 0xc6, 0x23, 0x13, 0xf9, 0xe5, 0xb2, 0x4c,
	0xf0, 0x61, 0x53, 0x31, 0xd5, 0xd4, 0xa3, 0x0a, 0xfc, 0x13, 0xc7, 0x26, 0xc1, 0xfa, 0xaa, 0x98,
	0x11, 0x14, 0x48, 0x7c, 0x58, 0x30, 0x35, 0xe9, 0x61, 0x81, 0x62, 0xfb, 0xa7, 0xcf, 0x65, 0xfb,
	0x8d, 0xef, 0xd6, 0x01, 0x92, 0xbe, 0xa2, 0x47, 0xd0, 0xb0, 0xe4, 0xbc, 0xc6, 0x37, 0x7e, 0x5e,
	0x19, 0xcb, 0xa0, 0x3b, 0x72, 0xda, 0xe3, 0x13, 0x7f, 0x4c, 0x00, 0xed, 0xc2, 0x94, 0xa9, 0x4c,
	0xa6, 0xdc, 0x5f, 0xb9, 0x3b, 0x9e, 0x9e, 0x32, 0xd7, 0x72, 0x92, 0x2a, 0x19, 0xf4, 0x3e, 0xcc,
	0x50, 0xe9, 0x5f, 0x8e, 0x0f, 0x37, 0xb8, 0x9b, 0xf2, 0xda, 0x78, 0xba, 0xdb, 0x2a, 0x1a, 0xa7,
	0x9c, 0x26, 0xc5, 0x56, 0x4a, 0x5c, 0x3a, 0xb8, 0x16, 0xca, 0xa1, 0x7f, 0x09, 0x66, 0xd3, 0x1e,
	0x93, 0xb0, 0x30, 0x19, 0x28, 0x5a, 0x65, 0xd7, 0x84, 0x6d, 0x87, 0x5b, 0xfe, 0xd1, 0xab, 0x8d,
	0x6d, 0xe6, 0xdb, 0x89, 0xc2, 0x58, 0xc1, 0x43, 0x5f, 0x81, 0x1a, 0x3b, 0x4f, 0x0c, 0xc5, 0x75,
	0xa8, 0xb1, 0x5b, 0x26, 0xeb, 0xb4, 0x34, 0x16, 0x48, 0xe8, 0x36, 0xe8, 0xb4, 0x59, 0x9d, 0xc0,
	0x7f, 0x7a, 0x2a, 0x9b, 0xcb, 0x4f, 0x9f, 0x87, 0xe0, 0xd4, 0x2c, 0xfa, 0x7d, 0x12, 0x98, 0x91,
	0xe3, 0x1d, 0xf2, 0xdd, 0x03, 0x39, 0x71, 0x64, 0xc0, 0xd4, 0xb5, 0x35, 0x03, 0xeb, 0xc8, 0x89,
	0x88, 0x15, 0x0d, 0x02, 0x22, 0xa4, 0x37, 0x05, 0x1b, 0x5e, 0x68, 0x4f, 0xe5, 0x2c, 0xb4, 0xa9,
	0x51, 0xf0, 0x43, 0xd6, 0x64, 0x26, 0xb4, 0x4d, 0x2c, 0x93, 0xe8, 0x1e, 0x5c, 0x4b, 0xf6, 0xe4,
	0x07, 0x5e, 0xe4, 0xf4, 0x62, 0x63, 0x3d, 0xc3, 0x4a, 0x16, 0x65, 0x2f, 0xbd, 0x0d, 0x33, 0x29,
	0x29, 0x1c, 0xe7, 0x75, 0x94, 0x55, 0xdf, 0xe5, 0x1d, 0xd0, 0xb3, 0x22, 0x77, 0x26, 0xfc, 0x77,
	0x01, 0x0d, 0x8b, 0xd6, 0x38, 0x0a, 0x4d, 0xd5, 0xef, 0xf9, 0x1b, 0x1a, 0xcc, 0xa4, 0xe4, 0x21,
	0xf7, 0x60, 0x3a, 0x91, 0xce, 0x52, 0x4a, 0x3a, 0xef, 0x00, 0xa2, 0x8b, 0xeb, 0xdd, 0xc0, 0xf4,
	0x42, 0x47, 0xfa, 0x28, 0x62, 0xc3, 0x38, 0x27, 0x87, 0xd2, 0x09, 0x88, 0x19, 0xc6, 0x1b, 0x25,
	0x22, 0xa5, 0x3e, 0x38, 0x52, 0x4d, 0x3d, 0x38, 0x62, 0xac, 0xc2, 0x6c, 0x5a, 0xd8, 0x58, 0x48,
	0x09, 0x9d, 0xa2, 0x45, 0x50, 0x05, 0x4f, 0xb0, 0x55, 0xba, 0xf3, 0x81, 0xd8, 0x73, 0x16, 0x1b,
	0xda, 0x31, 0xc0, 0x20, 0x50, 0x65, 0xc6, 0x78, 0x52, 0xd6, 0xd0, 0x86, 0x92, 0x83, 0x03, 0x22,
	0x76, 0x03, 0x9a, 0x58, 0xa4, 0x68, 0x35, 0x74, 0xf0, 0x97, 0x6d, 0x9b, 0xc8, 0x27, 0x14, 0x12,
	0x80, 0xf1, 0xdb, 0xd5, 0x78, 0x8a, 0xee, 0xf6, 0x89, 0x85, 0xee, 0x41, 0x95, 0x4e, 0xb3, 0xa1,
	0x30, 0x68, 0xc6, 0xe8, 0x88, 0x53, 0x3a, 0xab, 0x62, 0x8e, 0x80, 0xb6, 0xa0, 0x19, 0x12, 0x1e,
	0x3e, 0x27, 0x97, 0x5b, 0x45, 0xe6, 0x70, 0x93, 0xfa, 0x7e, 0x5d, 0x12, 0xdf, 0xcc, 0x1e, 0x38,
	0x01, 0x61, 0x97, 0x56, 0x13, 0x0a, 0x6a, 0x90, 0x61, 0x27, 0x7b, 0x77, 0xba, 0x93, 0x7a, 0x8a,
	0x45, 0x8e, 0xf8, 0x4d, 0x98, 0x22, 0x4f, 0x23, 0x12, 0x78, 0xa6, 0xbb, 0xde, 0xe1, 0x13, 0x5d,
	0x13, 0xab, 0x20, 0xaa, 0xc0, 0x61, 0x7a, 0xe2, 0x97, 0x7e, 0x4d, 0x06, 0x4c, 0x6d, 0x98, 0xeb,
	0x9b, 0xf6, 0x8a, 0xe9, 0x9a, 0x9e, 0xc5, 0x9a, 0xc0, 0x9d, 0x9b, 0x0c, 0x14, 0xbd, 0x05, 0x2d,
	0x15, 0xd2, 0x65, 0xf3, 0x06, 0x36, 0xbd, 0xc3, 0x78, 0x86, 0x2b, 0xcc, 0xa7, 0x46, 0x42, 0x36,
	0x8e, 0x45, 0x5a, 0x72, 0x5b, 0x92, 0x82, 0xa1, 0xd7, 0xe0, 0xaa, 0x4c, 0xef, 0x06, 0xe6, 0xc1,
	0x81, 0x63, 0x75, 0x7c, 0xd7, 0xb1, 0x4e, 0x85, 0x45, 0xc9, 0xcf, 0x44, 0xaf, 0xc2, 0x15, 0xbe,
	0xa5, 0xdb, 0x3e, 0x22, 0xd6, 0xf1, 0xb6, 0x74, 0x87, 0x78, 0x74, 0x5b, 0x5e, 0x16, 0xed, 0x47,
	0x7f, 0xb0, 0xef, 0x3a, 0xe1, 0xd1, 0xb6, 0x1f, 0x61, 0x62, 0xda, 0xa7, 0xc9, 0x94, 0x31, 0xcd,
	0x1c, 0x8a, 0xc2, 0x7c, 0xe4, 0xc0, 0xd5, 0x30, 0xcf, 0x9d, 0x12, 0x2b, 0xac, 0x2f, 0x8e, 0x16,
	0xa1, 0x5c, 0x4f, 0x0c, 0xe7, 0x53, 0x64, 0xa1, 0x96, 0xfd, 0xfb, 0x7c, 0x57, 0x86, 0xc7, 0xc5,
	0xc5, 0x69, 0x63, 0x19, 0x66, 0x24, 0x49, 0xae, 0xe9, 0xaf, 0xc2, 0x95, 0xd4, 0x68, 0xf1, 0x78,
	0xe1, 0xd6, 0x3c, 0x1b, 0x96, 0xbc, 0x2c, 0xe3, 0x37, 0x4b, 0x50, 0x97, 0x37, 0xa1, 0x2f, 0xe4,
	0xca, 0xbd, 0x01, 0x95, 0xb0, 0x4f, 0x2c, 0xb1, 0x7d, 0x3c, 0x46, 0x89, 0xa8, 0xde, 0x61, 0x56,
	0x1e, 0x7d, 0x39, 0xf3, 0x56, 0xd1, 0xa7, 0xc7, 0x60, 0xe6, 0xfb, 0x5c, 0x95, 0x8c, 0xcf, 0x25,
	0xbd, 0xab, 0x6a, 0xfe, 0x42, 0xb8, 0x76, 0x3e, 0x67, 0xe8, 0x77, 0x35, 0xb8, 0x92, 0xdc, 0x37,
	0x3f, 0x9f, 0x31, 0x3e, 0xb3, 0x71, 0x65, 0x8a, 0x69, 0x86, 0xd1, 0x5e, 0xdf, 0x4e, 0x07, 0xba,
	0x65, 0xa0, 0x05, 0x66, 0xbe, 0x5e, 0x64, 0xe6, 0x8d, 0xff, 0x58, 0x03, 0x50, 0x6e, 0xfb, 0x5f,
	0x68, 0xf4, 0xd9, 0xf2, 0x89, 0xbd, 0x32, 0x10, 0xae, 0x92, 0xd0, 0x09, 0x88, 0xdc, 0x7e, 0xcb,
	0x82, 0x69, 0x2b, 0x93, 0x6b, 0xfa, 0xdd, 0x28, 0x30, 0x23, 0x72, 0x28, 0xf7, 0x1b, 0x73, 0x72,
	0xd8, 0xe6, 0x8c, 0xf9, 0x74, 0xcf, 0x33, 0x4f, 0x4c, 0x27, 0xf1, 0xf6, 0x9b, 0x38, 0x03, 0x65,
	0xe7, 0x27, 0xe6, 0xd3, 0xee, 0x20, 0x88, 0x19, 0x18, 0xa7, 0x59, 0xe8, 0x9d, 0x39, 0x08, 0x09,
	0xdf, 0x89, 0x6c, 0x60, 0x91, 0x4a, 0xdb, 0xef, 0xfa, 0x85, 0xed, 0x37, 0x3b, 0x16, 0xe0, 0xbd,
	0x15, 0x41, 0x18, 0x71, 0x9a, 0x32, 0x68, 0xc0, 0x86, 0xca, 0xc6, 0xb2, 0x08, 0xdf, 0x1c, 0xcc,
	0x82, 0xe5, 0x11, 0xc1, 0x69, 0x5c, 0x0e, 0x78, 0x04, 0x76, 0x0a, 0x88, 0x5e, 0x86, 0xf9, 0xb8,
	0xef, 0x71, 0x49, 0x6e, 0xed, 0x86, 0x33, 0xa8, 0x5d, 0x18, 0x78, 0xc3, 0xe5, 0xa7, 0xb9, 0x75,
	0xcc, 0xc9, 0x12, 0x47, 0xe4, 0x5c, 0xbe, 0xb7, 0x84, 0x5c, 0x72, 0x1f, 0x6b, 0x08, 0x1e, 0x2b,
	0xe1, 0x6c, 0x81, 0x12, 0xce, 0x29, 0x4a, 0xf8, 0x4d, 0x58, 0x90, 0x0b, 0x6a, 0x85, 0x8b, 0x61,
	0x4b, 0x67, 0xdc, 0xff, 0xfc, 0x18, 0x8d, 0x54, 0x51, 0x70, 0x2e, 0x21, 0x55, 0xcb, 0xe7, 0xcf,
	0xa5, 0xe5, 0x68, 0x23, 0xe5, 0xa4, 0x23, 0xd6, 0xb0, 0xdb, 0x63, 0x5f, 0x9f, 0xc8, 0x75, 0xd5,
	0x8d, 0xbf, 0xad, 0xc1, 0x95, 0xe4, 0x29, 0x8e, 0x8f, 0xab, 0xfb, 0xf6, 0xf3, 0x55, 0x00, 0xe5,
	0x81, 0x93, 0x8f, 0xc8, 0x12, 0xa4, 0xb4, 0xaf, 0xfc, 0x4c, 0xb5, 0xaf, 0x92, 0xd1, 0xbe, 0xbb,
	0xb0, 0x70, 0x30, 0x70, 0xdd, 0x53, 0x46, 0x47, 0x51, 0x41, 0xbe, 0x5b, 0x92, 0x9b, 0x37, 0xac,
	0x87, 0xb5, 0x89, 0xf5, 0xb0, 0x5e, 0xa4, 0x87, 0x52, 0x53, 0x1a, 0x05, 0x9a, 0xd2, 0x9c, 0x40,
	0x53, 0xe0, 0x43, 0xd0, 0x94, 0xa9, 0x67, 0xa1, 0x29, 0xd3, 0x23, 0x35, 0x25, 0x47, 0x0b, 0x52,
	0x9a, 0xf2, 0x2d, 0x68, 0x15, 0x8d, 0x72, 0xce, 0x7a, 0x60, 0x09, 0x1a, 0x7c, 0x01, 0x1a, 0x9f,
	0x61, 0xc5, 0x69, 0x76, 0xba, 0x45, 0x97, 0x07, 0x72, 0xe3, 0x48, 0xa4, 0x8c, 0x5f, 0xab, 0x43,
	0xb9, 0xe3, 0xdb, 0x17, 0x13, 0xef, 0x59, 0x28, 0xad, 0x77, 0x64, 0xf0, 0xef, 0x7a, 0x87, 0x8e,
	0xbf, 0xe7, 0xf7, 0x1c, 0x8f, 0x9a, 0x70, 0xea, 0x5a, 0x6e, 0x27, 0x5b, 0x91, 0xc3, 0x19, 0x72,
	0xa7, 0x8e, 0x15, 0xe2, 0xca, 0x19, 0xa7, 0xe9, 0x12, 0xa7, 0x7f, 0x64, 0x86, 0x52, 0x39, 0x79,
	0x82, 0x7a, 0xcc, 0x01, 0x61, 0x11, 0x08, 0xfc, 0xe0, 0x87, 0x0b, 0x61, 0x0a, 0x86, 0x76, 0x95,
	0xc7, 0xa4, 0xb8, 0x7f, 0x14, 0x6f, 0x0d, 0xbc, 0x34, 0x49, 0x34, 0xc5, 0x20, 0xc4, 0xc3, 0x04,
	0x72, 0x67, 0x80, 0x46, 0xe1, 0x0c, 0x20, 0x4d, 0x57, 0x33, 0xe3, 0xec, 0x70, 0x79, 0x87, 0x02,
	0x79, 0x9f, 0x52, 0xe4, 0x5d, 0x6e, 0x6e, 0x4d, 0x4f, 0xba, 0xb9, 0x55, 0xa4, 0x20, 0x33, 0xcf,
	0x4a, 0x41, 0xbe, 0x01, 0x57, 0xa9, 0x27, 0xde, 0x1e, 0xe2, 0xed, 0xec, 0x99, 0x78, 0x9b, 0x4f,
	0x84, 0xca, 0xc2, 0x4f, 0xed, 0x74, 0xdb, 0xae, 0x19, 0xf2, 0xf0, 0xe6, 0x26, 0x8e, 0xd3, 0xd4,
	0xf6, 0xf4, 0x03, 0xc7, 0x0f, 0xe8, 0x32, 0x80, 0x15, 0xd0, 0xf9, 0x46, 0x49, 0x0a, 0xf8, 0x0c,
	0xa6, 0x3a, 0xba, 0x1e, 0xa7, 0x72, 0xc4, 0x66, 0x14, 0x24, 0xd6, 0xe3, 0x12, 0x40, 0x5b, 0x21,
	0x36, 0x54, 0x89, 0xcd, 0x4a, 0x5c, 0x61, 0x25, 0xd2, 0x40, 0xd4, 0x4e, 0x19, 0x81, 0x05, 0xc6,
	0x9a, 0x4f, 0x15, 0xbf, 0xd0, 0x95, 0xaf, 0xfd, 0xbf, 0xa5, 0xc1, 0xb4, 0x9a, 0x79, 0xa6, 0x09,
	0xf2, 0xd3, 0x30, 0x43, 0xa7, 0xc1, 0x4e, 0xe0, 0xef, 0x13, 0x65, 0x6e, 0x4c, 0x03, 0x0b, 0xa6,
	0xd1, 0xca, 0x04, 0xd3, 0x68, 0xb5, 0x68, 0x1a, 0xad, 0xa5, 0xa7, 0xd1, 0x1f, 0x6a, 0x30, 0x97,
	0x19, 0xe7, 0xdc, 0xfd, 0xff, 0x54, 0xec, 0xed, 0x6a, 0xfc, 0x8a, 0x5a, 0x02, 0x62, 0x5b, 0xc6,
	0x74, 0x9a, 0x61, 0x3d, 0x69, 0x60, 0x9e, 0x18, 0xb2, 0x05, 0x95, 0x1c, 0x5b, 0xb0, 0x20, 0xa3,
	0xa9, 0x84, 0x15, 0xe1, 0x61, 0x52, 0xc5, 0x6d, 0xfe, 0xc7, 0x1a, 0x34, 0xe2, 0x67, 0x7b, 0x54,
	0xa6, 0x8b, 0xd7, 0x5e, 0xf3, 0x0e, 0x46, 0x4a, 0xf9, 0x07, 0x23, 0xc3, 0xa7, 0x6b, 0x2d, 0xa8,
	0xd3, 0x5e, 0x11, 0xd1, 0xd6, 0x69, 0x2c, 0x93, 0x92, 0x05, 0xc4, 0xe3, 0x2f, 0xdf, 0x55, 0x13,
	0x16, 0x08, 0x90, 0x1a, 0xae, 0x53, 0x4b, 0x85, 0xeb, 0x18, 0x7f, 0x4b, 0x03, 0x14, 0xbf, 0x19,
	0xf3, 0x71, 0x75, 0xa9, 0xbe, 0x5b, 0x82, 0x66, 0xf2, 0x0c, 0xcf, 0x85, 0xa6, 0x9c, 0xa2, 0x4e,
	0xe4, 0x19, 0xe8, 0xf2, 0x18, 0x17, 0x7d, 0x92, 0x75, 0xf2, 0x7a, 0xce, 0x26, 0xf5, 0xe7, 0xc6,
	0xbd, 0xdd, 0x93, 0xaf, 0xd6, 0x7f, 0xa9, 0x0c, 0x0b, 0x79, 0x06, 0x17, 0xed, 0x40, 0xcd, 0x75,
	0x7a, 0x4e, 0xbc, 0xe9, 0xf6, 0xa5, 0x33, 0x58, 0xeb, 0x3b, 0x2c, 0x60, 0x4e, 0x6c, 0xd0, 0x0b,
	0x32, 0x68, 0x8f, 0x7a, 0x7f, 0xdf, 0x19, 0xb0, 0x87, 0x9f, 0xf8, 0x4e, 0xdc, 0x9b, 0x67, 0x21,
	0x89, 0x05, 0xae, 0x38, 0xa2, 0x90, 0xa4, 0x72, 0x0f, 0x17, 0xdb, 0xca, 0x46, 0xdc, 0x6c, 0xa1,
	0xcb, 0x9a, 0x57, 0x0d, 0xbb, 0x6a, 0xc4, 0x90, 0x97, 0xde, 0x84, 0x29, 0xa5, 0x1b, 0x67, 0xda,
	0x4e, 0x7e, 0x1b, 0x66, 0x52, 0xcd, 0x3d, 0x0b, 0x32, 0xd5, 0xf7, 0xb9, 0xcc, 0x74, 0x80, 0xbe,
	0x01, 0xd3, 0x7c, 0x42, 0x78, 0xcc, 0xdd, 0x26, 0x3e, 0x24, 0xf7, 0x26, 0x9b, 0x4c, 0xee, 0x6c,
	0x29, 0xa8, 0x9c, 0x7d, 0x29, 0x6a, 0x4b, 0x5f, 0x85, 0xf9, 0xa1, 0x22, 0xe3, 0x9a, 0xac, 0x65,
	0x0e, 0xfd, 0xeb, 0x1b, 0xfe, 0x3e, 0xdb, 0xab, 0xbd, 0x09, 0x53, 0x7d, 0x33, 0x30, 0x5d, 0x97,
	0xb8, 0x4e, 0xd8, 0x93, 0x31, 0xd3, 0x0a, 0x88, 0x5b, 0x96, 0x5e, 0x9f, 0x1f, 0xc6, 0x87, 0x62,
	0xed, 0xa1, 0x82, 0xd0, 0x6b, 0x70, 0x95, 0xdf, 0x66, 0x5e, 0x25, 0xa6, 0xed, 0x3a, 0x1e, 0x91,
	0x27, 0x9e, 0x5c, 0xff, 0xf3, 0x33, 0xa9, 0xf1, 0xdd, 0x37, 0xad, 0x63, 0xff, 0xe0, 0x80, 0x87,
	0x70, 0x0a, 0xe3, 0xab, 0xc2, 0xd2, 0x2b, 0x9a, 0xea, 0x85, 0x57, 0x34, 0x6c, 0xeb, 0xc3, 0x1b,
	0x98, 0x71, 0x39, 0xb1, 0x7d, 0x91, 0x81, 0x16, 0x3a, 0x42, 0xf5, 0x67, 0xe4, 0x08, 0x19, 0xbf,
	0xab, 0x41, 0x93, 0x8e, 0x40, 0xb1, 0xdd, 0xd1, 0x0a, 0xec, 0x4e, 0xca, 0xc1, 0x28, 0x65, 0x1d,
	0x0c, 0x76, 0x53, 0x50, 0x0e, 0x8c, 0x62, 0x82, 0x33, 0x50, 0x6a, 0x01, 0xf9, 0xa0, 0x08, 0xae,
	0x8b, 0x14, 0xa3, 0x3e, 0xb0, 0x2c, 0x42, 0x6c, 0x22, 0x6f, 0x2f, 0x26, 0x00, 0x1e, 0xcd, 0xe6,
	0xb8, 0x44, 0x5e, 0x62, 0x14, 0x29, 0xe6, 0x6b, 0x6c, 0xf8, 0xfb, 0x3f, 0xd9, 0xbe, 0xc6, 0xaf,
	0x97, 0xa0, 0xbc, 0xe1, 0xef, 0x5f, 0x6c, 0x66, 0xb9, 0x9b, 0xda, 0xb3, 0xbd, 0x51, 0xfc, 0x8c,
	0x99, 0xb2, 0x5f, 0x7b, 0x2f, 0xb3, 0x5f, 0x7b, 0x73, 0x04, 0xd6, 0xf9, 0xf7, 0x6a, 0xdb, 0x39,
	0x73, 0xd0, 0xa7, 0x8a, 0x6b, 0xca, 0x9f, 0x7d, 0xfe, 0x5c, 0x19, 0xa6, 0xc4, 0x73, 0x65, 0xcc,
	0x78, 0x2c, 0x41, 0x43, 0xba, 0xae, 0xf2, 0x65, 0x5b, 0x99, 0x46, 0xf7, 0xe0, 0x1a, 0x93, 0x4b,
	0xc7, 0x3b, 0xcc, 0x9a, 0x05, 0x2e, 0xb6, 0x45, 0xd9, 0x2c, 0x84, 0xc8, 0xf7, 0xac, 0x41, 0x10,
	0x10, 0xcf, 0x3a, 0x15, 0x67, 0x15, 0x62, 0x05, 0x38, 0x94, 0xc1, 0xc2, 0xcb, 0x07, 0x61, 0x9f,
	0x88, 0x3b, 0xd2, 0x0d, 0x2c, 0x93, 0xe8, 0x1d, 0x58, 0x62, 0xb2, 0x1b, 0x86, 0x07, 0x03, 0x77,
	0xc3, 0xdf, 0x0f, 0x1f, 0x3a, 0x61, 0x14, 0xdf, 0x07, 0xe5, 0xd2, 0x3d, 0xa2, 0x04, 0x7a, 0x03,
	0x16, 0xb9, 0x80, 0x0f, 0xe1, 0x72, 0xf1, 0x2f, 0xc8, 0xfd, 0xf0, 0xad, 0xc7, 0xcf, 0xc2, 0x8c,
	0x1c, 0x05, 0x2e, 0x08, 0xef, 0xc4, 0xea, 0xac, 0x8d, 0x5c, 0x48, 0x65, 0x62, 0x83, 0x62, 0xb5,
	0xbf, 0x0d, 0x3a, 0xd5, 0xa1, 0xae, 0x18, 0x3b, 0xc5, 0xb6, 0x0c, 0xc1, 0x8d, 0xff, 0xa2, 0x41,
	0x5d, 0x3e, 0xae, 0xf7, 0x11, 0x9c, 0x6f, 0x28, 0xe2, 0x76, 0xc6, 0xf3, 0x8d, 0x14, 0x8b, 0xce,
	0xa3, 0x33, 0xc6, 0xff, 0x28, 0xc1, 0x4c, 0xfc, 0x78, 0x1d, 0x13, 0xf8, 0xd4, 0x7c, 0xa4, 0x5d,
	0x78, 0x3e, 0xca, 0xdf, 0xba, 0x2f, 0x9d, 0x61, 0xeb, 0xbe, 0x9c, 0xbb, 0x75, 0x7f, 0x0b, 0xe6,
	0x7a, 0x8e, 0xc7, 0x8e, 0xd8, 0xa4, 0xce, 0x71, 0x3b, 0x9f, 0x05, 0xa3, 0xbb, 0x54, 0x56, 0x4f,
	0x1c, 0xba, 0x0c, 0xc8, 0xd1, 0x8e, 0xdc, 0xbc, 0x42, 0xf9, 0xae, 0x3d, 0x2b, 0xf9, 0xfe, 0x71,
	0x09, 0xe6, 0x12, 0xbe, 0xf3, 0x71, 0x7b, 0x03, 0x16, 0xb9, 0xe2, 0x47, 0xdb, 0x2c, 0xe4, 0x5a,
	0xca, 0xa4, 0x1d, 0x87, 0x55, 0xe5, 0xe6, 0x52, 0x16, 0xf3, 0x18, 0xed, 0x2d, 0x27, 0x8c, 0x97,
	0xd9, 0xc2, 0x89, 0xc9, 0xc9, 0xa1, 0xf5, 0xd8, 0x7c, 0x3b, 0x35, 0x5b, 0x0f, 0x0f, 0x20, 0x2b,
	0xc8, 0xa5, 0x5e, 0x12, 0xa7, 0xc6, 0xd8, 0x2b, 0xd8, 0xad, 0x82, 0x28, 0x65, 0x71, 0x32, 0x91,
	0xa5, 0x2c, 0xcc, 0x49, 0x7e, 0x2e, 0x1d, 0x4c, 0x4e, 0x66, 0x39, 0x1e, 0x75, 0xbe, 0x1d, 0x9a,
	0x05, 0xb3, 0xad, 0x33, 0x06, 0x52, 0x25, 0x84, 0x9f, 0x9b, 0x0c, 0x67, 0xb0, 0x55, 0x5f, 0xcc,
	0xe5, 0x8f, 0xeb, 0xaa, 0xef, 0xcf, 0x4a, 0xd0, 0x4c, 0x5e, 0xbb, 0xbc, 0x90, 0xbd, 0xb9, 0x97,
	0xb2, 0x37, 0x9f, 0x1e, 0xf7, 0x58, 0xa5, 0x62, 0x71, 0x26, 0xfd, 0xfa, 0x4b, 0x46, 0x66, 0x2f,
	0xe7, 0x4c, 0x35, 0xb3, 0xda, 0xac, 0x8f, 0x5c, 0x6d, 0x0e, 0x8f, 0x7f, 0x6a, 0xbe, 0xff, 0x85,
	0x32, 0xbf, 0x39, 0x28, 0xde, 0xb1, 0x64, 0x26, 0xf0, 0x16, 0xcc, 0x09, 0x15, 0x88, 0x77, 0xe7,
	0xb9, 0x06, 0x66, 0xc1, 0xcf, 0x3a, 0x98, 0xe3, 0x26, 0x4c, 0x89, 0x37, 0xc9, 0x94, 0x2d, 0x61,
	0x15, 0x84, 0x5e, 0x85, 0x2b, 0x7d, 0xdf, 0xde, 0x32, 0x3d, 0xf3, 0x90, 0x61, 0x0b, 0xd7, 0x81,
	0xcb, 0x5a, 0x5e, 0x16, 0x35, 0xa8, 0x5c, 0xeb, 0x62, 0xe3, 0x2b, 0xc2, 0xcc, 0xd2, 0x50, 0xea,
	0x17, 0xf7, 0xa9, 0xb3, 0x12, 0xc9, 0xdd, 0x93, 0x2a, 0x4e, 0x00, 0x1f, 0xfe, 0x84, 0xff, 0x1b,
	0x1a, 0xcc, 0xab, 0xe3, 0x10, 0x7f, 0x84, 0x20, 0x48, 0x0f, 0x41, 0x72, 0x3e, 0x33, 0x74, 0xd6,
	0x52, 0xca, 0x3b, 0x6b, 0xb9, 0x05, 0x73, 0xc2, 0x6c, 0xc6, 0xe5, 0xb8, 0x95, 0xcb, 0x82, 0xf3,
	0x4e, 0x5b, 0x2b, 0xb9, 0xa7, 0xad, 0xc6, 0xdf, 0xd1, 0x60, 0x41, 0x69, 0xeb, 0xc7, 0x76, 0x3b,
	0xa9, 0x0c, 0x53, 0xea, 0x0b, 0xb3, 0x17, 0x32, 0x2d, 0x6f, 0xa5, 0x4c, 0xcb, 0x4b, 0xe3, 0x9f,
	0x87, 0x55, 0x8c, 0xcb, 0xbb, 0x19, 0xe3, 0x72, 0x6b, 0x02, 0xec, 0xcb, 0x34, 0x2f, 0x8f, 0x72,
	0xcc, 0xcb, 0xe7, 0xc7, 0xb7, 0x39, 0xdf, 0xc0, 0x7c, 0xb7, 0x04, 0xfa, 0xd0, 0xd3, 0xb7, 0x17,
	0x1a, 0x8a, 0xaf, 0xa6, 0x86, 0xe2, 0xf3, 0x13, 0xbe, 0xd3, 0xaa, 0x8c, 0xc7, 0x5a, 0x66, 0x3c,
	0xbe, 0x30, 0x29, 0x89, 0xf3, 0xfb, 0x99, 0x3f, 0xa8, 0xc2, 0x42, 0x5e, 0x8b, 0xd0, 0xde, 0x50,
	0x70, 0xf0, 0x9b, 0x67, 0xe8, 0x50, 0x61, 0x98, 0xf0, 0x5d, 0x58, 0xc8, 0xbe, 0x48, 0xcb, 0x36,
	0x8d, 0xb9, 0x0e, 0xe6, 0xe6, 0xb1, 0x3b, 0x16, 0x6c, 0xa5, 0xb4, 0xc5, 0x3e, 0x44, 0x50, 0x16,
	0x77, 0x2c, 0x12, 0x10, 0x5a, 0x81, 0x86, 0xc5, 0x9e, 0xbb, 0x25, 0x07, 0xe2, 0x65, 0x8e, 0x49,
	0x97, 0x21, 0x31, 0x1e, 0x5a, 0x85, 0x17, 0xb3, 0xb5, 0x63, 0xc2, 0x72, 0x85, 0x2d, 0xe7, 0x5a,
	0x3c, 0xba, 0x10, 0x5d, 0xce, 0x50, 0x77, 0xd5, 0x3c, 0x24, 0xec, 0x58, 0x87, 0x4d, 0x17, 0x7c,
	0xb5, 0x3f, 0x04, 0x67, 0x37, 0x7d, 0xfd, 0x81, 0x17, 0xed, 0xf4, 0xd5, 0xcb, 0x23, 0x29, 0x18,
	0xba, 0x01, 0x70, 0xc2, 0xaa, 0xa1, 0x1d, 0x15, 0x47, 0x76, 0x0a, 0x04, 0x3d, 0x82, 0x69, 0x16,
	0xd5, 0x2c, 0xe3, 0x01, 0x9b, 0x23, 0x9f, 0x4b, 0x66, 0xf1, 0xd1, 0x62, 0x56, 0xdb, 0x25, 0x41,
	0x0f, 0xa7, 0x90, 0x11, 0x19, 0x7e, 0x7a, 0x98, 0x47, 0xfc, 0x89, 0xa7, 0xe9, 0x26, 0x96, 0x47,
	0x3e, 0x8d, 0x14, 0x10, 0xbb, 0x50, 0xfc, 0xae, 0xf1, 0x2f, 0xcb, 0xb0, 0x98, 0x5f, 0x1f, 0xda,
	0x87, 0xf9, 0x43, 0x8b, 0x24, 0x99, 0xec, 0x2d, 0x2f, 0xae, 0xc5, 0x45, 0x01, 0xe3, 0x0f, 0xda,
	0x6b, 0xe9, 0xf2, 0xa9, 0x0e, 0x0c, 0x93, 0x43, 0xc7, 0xb0, 0x60, 0x3e, 0x09, 0xd7, 0xe8, 0x3c,
	0xe0, 0x58, 0x2b, 0xae, 0x6f, 0x1d, 0x77, 0x23, 0x3f, 0x90, 0x2f, 0x17, 0x14, 0xed, 0x7c, 0x2f,
	0xbf, 0xd7, 0x1d, 0x42, 0x49, 0xd5, 0x94, 0x4b, 0x14, 0xed, 0x42, 0xd3, 0xfc, 0x60, 0x10, 0x90,
	0xfb, 0x8e, 0x58, 0x6e, 0x4d, 0xdd, 0x7d, 0xa3, 0xa8, 0x06, 0x59, 0xae, 0x60, 0x2c, 0x12, 0x42,
	0x68, 0x43, 0x50, 0x65, 0xec, 0xe1, 0xda, 0xf2, 0xf2, 0x28, 0xaa, 0x43, 0x6c, 0x49, 0xd0, 0xd1,
	0x3d, 0x28, 0x5b, 0xa1, 0x23, 0x9e, 0x7a, 0x2b, 0x3c, 0x43, 0xed, 0xae, 0xa7, 0xf0, 0x29, 0x8a,
	0xf1, 0x8b, 0x1a, 0xbc, 0x38, 0x92, 0xfb, 0x2c, 0xd0, 0xcb, 0x56, 0xde, 0xf0, 0x14, 0x29, 0xb6,
	0x15, 0x18, 0x2a, 0x46, 0x43, 0xa4, 0xd2, 0x8e, 0x52, 0x39, 0xeb, 0x28, 0x89, 0x6b, 0xde, 0x3b,
	0x9e, 0x7b, 0x2a, 0x36, 0x6b, 0xe2, 0xb4, 0xf1, 0x3d, 0x0d, 0x6e, 0x8e, 0x1b, 0x22, 0x4a, 0x80,
	0xeb, 0x1d, 0x7b, 0x26, 0x83, 0x6d, 0x38, 0xc9, 0xf4, 0x87, 0xd0, 0xa4, 0xbf, 0xab, 0xc1, 0x27,
	0xc6, 0x8c, 0x29, 0xbb, 0x7e, 0x4c, 0xac, 0x80, 0xa8, 0x9f, 0x77, 0x52, 0x20, 0x6c, 0x47, 0xf5,
	0xc8, 0x0c, 0x88, 0xf2, 0x79, 0xa7, 0x04, 0x90, 0xaa, 0xbd, 0x9c, 0xae, 0x9d, 0x07, 0x1a, 0x4b,
	0x3a, 0xfc, 0xaa, 0x56, 0x45, 0x06, 0x1a, 0xa7, 0xc0, 0xc6, 0x3f, 0xd1, 0xe0, 0x6a, 0xae, 0x94,
	0x50, 0xfa, 0xb6, 0x13, 0x1e, 0xab, 0x9f, 0x9e, 0x92, 0x69, 0xea, 0x1b, 0xd1, 0xff, 0x7b, 0x78,
	0x5d, 0x5e, 0x15, 0x12, 0x49, 0xb6, 0xe3, 0x6f, 0x5a, 0x47, 0x8e, 0x77, 0xc8, 0x0c, 0x9e, 0xf0,
	0xb4, 0x15, 0x90, 0xc2, 0xeb, 0x4a, 0x8a, 0xd7, 0x6a, 0x7f, 0xaa, 0x99, 0xfe, 0xc8, 0x8b, 0x68,
	0x35, 0xe5, 0xc2, 0xda, 0x5f, 0xac, 0xc1, 0x5c, 0x46, 0x32, 0x29, 0x6d, 0x3b, 0x70, 0x4e, 0xc4,
	0x1d, 0xeb, 0x26, 0x16, 0x29, 0x6a, 0xa9, 0xf9, 0x58, 0x3f, 0x34, 0x3d, 0xdb, 0x95, 0xcc, 0x4c,
	0xc1, 0x46, 0xf2, 0xb3, 0xa8, 0xcd, 0x47, 0xa0, 0x73, 0x1a, 0xcb, 0x51, 0x14, 0x38, 0xfb, 0x83,
	0x28, 0x7e, 0x3e, 0xf8, 0xcb, 0x93, 0xe9, 0xd2, 0x9d, 0xc7, 0x19, 0x74, 0xf1, 0x5d, 0x9c, 0x2c,
	0x55, 0x74, 0x00, 0x4b, 0x96, 0xef, 0x45, 0x81, 0xef, 0xba, 0x24, 0xe8, 0xf0, 0x50, 0xe8, 0x2e,
	0x1b, 0x4b, 0x3a, 0x67, 0x8e, 0xf6, 0xc7, 0xe2, 0x72, 0x62, 0xce, 0x1c, 0x41, 0x09, 0x3d, 0x06,
	0xe4, 0xf1, 0x4b, 0x38, 0x87, 0x24, 0xa1, 0x5f, 0x3f, 0x13, 0xfd, 0x1c, 0x0a, 0xe8, 0x7d, 0x58,
	0x60, 0xd7, 0xe0, 0xb2, 0x2d, 0x6f, 0x9c, 0x89, 0x72, 0x2e, 0x0d, 0x64, 0xc3, 0xf3, 0x49, 0x8f,
	0xd6, 0x9e, 0xf6, 0x4d, 0xcf, 0x4e, 0x2a, 0x68, 0x9e, 0xa9, 0x82, 0x62, 0x42, 0xe8, 0x6b, 0x70,
	0x85, 0xd6, 0x9e, 0xa5, 0x0f, 0x67, 0xa2, 0x9f, 0x47, 0x62, 0xa9, 0x0d, 0x57, 0x73, 0xc5, 0xe0,
	0x4c, 0xb7, 0x52, 0xda, 0x30, 0x97, 0xa9, 0xec, 0xec, 0x77, 0x72, 0x8d, 0x6f, 0xe5, 0xcc, 0xcd,
	0xdc, 0x27, 0x8d, 0x03, 0xa2, 0x34, 0x35, 0x20, 0xaa, 0xf8, 0xab, 0xb7, 0xc9, 0xaa, 0xaa, 0xac,
	0xae, 0xaa, 0x8c, 0xdf, 0xd2, 0x40, 0xcf, 0x7a, 0x31, 0xe8, 0xeb, 0xa0, 0xf7, 0xcc, 0xc8, 0x3a,
	0x5a, 0x7b, 0xda, 0x0f, 0x78, 0xdc, 0xfd, 0xb9, 0x77, 0x48, 0x87, 0x08, 0xa1, 0x9f, 0x82, 0x29,
	0x06, 0xbb, 0xef, 0x10, 0xd7, 0x3e, 0xf7, 0x66, 0x82, 0x4a, 0xc3, 0xf8, 0xe5, 0x12, 0x5c, 0xcd,
	0xff, 0xe8, 0xc4, 0x85, 0xd6, 0x1f, 0xab, 0xa9, 0xf5, 0xc7, 0xab, 0x67, 0xf9, 0x4e, 0x84, 0xb2,
	0x08, 0xd9, 0xc8, 0x2c, 0x42, 0xee, 0x9e, 0x89, 0xce, 0xf9, 0x57, 0x22, 0xbf, 0x5d, 0x82, 0x17,
	0x46, 0xd0, 0x2c, 0x90, 0xa0, 0xcc, 0xda, 0xa0, 0x34, 0xbc, 0x36, 0xf8, 0x86, 0xb2, 0x90, 0xe1,
	0x81, 0xa9, 0xef, 0x9e, 0xbd, 0x47, 0x85, 0xeb, 0x99, 0xbd, 0xd4, 0x92, 0xb4, 0x32, 0xf2, 0x11,
	0x85, 0x5c, 0xfa, 0xb9, 0x8b, 0xd3, 0x8b, 0xb9, 0xc8, 0x7f, 0xb9, 0x0c, 0xcf, 0x17, 0x8e, 0x72,
	0x96, 0x63, 0xda, 0x30, 0xc7, 0xd6, 0xa1, 0x29, 0xb7, 0x82, 0xc2, 0x31, 0x8b, 0xd9, 0xdc, 0x8d,
	0xa4, 0x04, 0x3b, 0x59, 0xbe, 0x28, 0xfb, 0x66, 0x0a, 0x04, 0x3d, 0x82, 0x86, 0xdc, 0x65, 0x13,
	0xcc, 0x3b, 0xb3, 0x66, 0xc5, 0x04, 0x72, 0xd7, 0x5e, 0xd5, 0x82, 0xb5, 0x57, 0x7a, 0x5d, 0x55,
	0x1b, 0x5a, 0x57, 0x75, 0x00, 0x68, 0x3b, 0xc4, 0xf2, 0xa7, 0x3e, 0x52, 0xa3, 0xe8, 0x54, 0x6e,
	0x6f, 0xfa, 0x96, 0xe9, 0x66, 0x57, 0x97, 0x0a, 0x0d, 0xe3, 0x9b, 0xf0, 0x7c, 0x61, 0x41, 0xea,
	0x3c, 0x98, 0x7d, 0xe7, 0x01, 0x7b, 0x51, 0x58, 0x38, 0x4b, 0x32, 0x1d, 0x3b, 0x2f, 0x25, 0xe5,
	0x16, 0x7d, 0x4e, 0x28, 0x8b, 0xf1, 0x07, 0x1a, 0xdc, 0x18, 0x2d, 0x62, 0x3f, 0x91, 0x87, 0xe3,
	0x3f, 0xd0, 0x00, 0xf8, 0xe2, 0x1a, 0x0f, 0x5c, 0x16, 0x59, 0x7b, 0x42, 0x82, 0xfd, 0xf8, 0x2e,
	0x22, 0x4b, 0xd0, 0x69, 0x49, 0xf2, 0x4b, 0x1a, 0x81, 0x04, 0xc0, 0x1f, 0xcf, 0x93, 0x02, 0xcd,
	0xb7, 0x0f, 0x14, 0x19, 0x65, 0xfb, 0x95, 0x3c, 0xc1, 0xfc, 0x5a, 0x26, 0x88, 0x4d, 0x9c, 0x06,
	0xb2, 0xa3, 0x10, 0xdf, 0x93, 0xf2, 0xbe, 0x87, 0x37, 0xa5, 0xf5, 0xca, 0x82, 0x8d, 0x63, 0xa8,
	0x77, 0x07, 0x6c, 0x7c, 0x73, 0x1f, 0x40, 0x50, 0x87, 0xba, 0x34, 0x3c, 0xd4, 0x43, 0x11, 0x4a,
	0xa9, 0x19, 0xb7, 0x92, 0x9d, 0x71, 0xff, 0xbe, 0x06, 0x15, 0xf6, 0x95, 0x97, 0x0b, 0xcd, 0x1c,
	0x5f, 0x82, 0x6a, 0x30, 0x70, 0x89, 0x9c, 0xdd, 0x3e, 0x59, 0x18, 0xf1, 0x29, 0x87, 0x01, 0xf3,
	0xf2, 0xb1, 0x81, 0x2f, 0x17, 0x18, 0xf8, 0x4a, 0xfa, 0xa3, 0x53, 0x53, 0xea, 0x37, 0x5a, 0x2e,
	0xb8, 0xed, 0xd9, 0x08, 0x39, 0x93, 0x65, 0xa3, 0x0b, 0x3f, 0xb8, 0xc9, 0x8b, 0xe1, 0xb8, 0x3c,
	0xda, 0x80, 0x7a, 0xe0, 0xbb, 0x84, 0x7a, 0x5f, 0xe5, 0x73, 0x2a, 0xb6, 0x24, 0x70, 0xa6, 0x19,
	0xee, 0xf7, 0x4a, 0x30, 0xa5, 0x7e, 0x98, 0xe7, 0x72, 0x86, 0xec, 0xeb, 0xa0, 0x9b, 0x87, 0x87,
	0x01, 0x39, 0x64, 0xef, 0x93, 0x60, 0x46, 0xe3, 0x9c, 0x17, 0x36, 0x86, 0x08, 0x7d, 0xc4, 0x57,
	0xf8, 0x7e, 0xa1, 0x04, 0x28, 0xe7, 0xe3, 0x3f, 0xff, 0xcf, 0x09, 0xd6, 0x7f, 0x28, 0xc1, 0x6c,
	0xe6, 0xdb, 0x3f, 0x17, 0xe2, 0xc1, 0xbb, 0x50, 0xe7, 0xeb, 0x7c, 0xc9, 0x82, 0x49, 0x77, 0x53,
	0x25, 0x1a, 0xfa, 0x06, 0xe8, 0xec, 0x81, 0x82, 0xce, 0xc0, 0x75, 0xbb, 0x82, 0x14, 0x17, 0xb2,
	0xb3, 0xb3, 0x64, 0x88, 0x12, 0x5a, 0x81, 0xeb, 0xe6, 0x20, 0xf2, 0xd9, 0x46, 0x69, 0xba, 0xdf,
	0xbb, 0xfe, 0x31, 0xf1, 0xc4, 0x66, 0xca, 0xc8, 0x32, 0x31, 0x7f, 0xab, 0x05, 0xfc, 0x55, 0x3f,
	0xad, 0x32, 0x80, 0xab, 0xe2, 0x8a, 0xad, 0xa0, 0xb4, 0x62, 0x5a, 0xc7, 0xc4, 0xb3, 0xb3, 0xe7,
	0x82, 0xda, 0xf0, 0xb9, 0x20, 0x7b, 0xfa, 0x24, 0x48, 0x7d, 0xad, 0x5b, 0xa6, 0xd9, 0x0b, 0x21,
	0xf4, 0x3f, 0x7f, 0xd5, 0x8d, 0x6f, 0x0f, 0x29, 0x10, 0xe3, 0xef, 0x69, 0x30, 0x2b, 0xea, 0x95,
	0x15, 0xde, 0xa7, 0x23, 0xc3, 0xa8, 0x8b, 0x51, 0x7d, 0x79, 0xf4, 0x67, 0x86, 0xd2, 0xed, 0xc5,
	0x12, 0x19, 0x6d, 0x42, 0x43, 0x4e, 0x6f, 0x63, 0x96, 0x0b, 0xc5, 0xe3, 0x12, 0x53, 0x30, 0x56,
	0x00, 0x44, 0x7d, 0xbb, 0x9b, 0x5d, 0x3a, 0x43, 0x1f, 0xf9, 0x61, 0x14, 0xcf, 0xd0, 0x2c, 0x91,
	0xd9, 0xac, 0x2a, 0x65, 0x37, 0xab, 0x8c, 0xff, 0x5f, 0x83, 0xb9, 0x87, 0xbb, 0xbb, 0x1d, 0x41,
	0xa8, 0x63, 0x46, 0x47, 0xec, 0xfd, 0x1c, 0x33, 0x3a, 0x92, 0xd3, 0x27, 0xfd, 0x8f, 0xbe, 0x0a,
	0xf5, 0x7d, 0xde, 0x1b, 0xd1, 0xf0, 0xcf, 0x8c, 0xe6, 0x40, 0xdc, 0x75, 0x81, 0xc5, 0x46, 0xc4,
	0x8c, 0x8e, 0xd8, 0x6e, 0x4c, 0x59, 0x8c, 0x88, 0x48, 0x1b, 0x87, 0x30, 0x25, 0xbf, 0xcf, 0x44,
	0x7d, 0x0d, 0x24, 0x6e, 0xb1, 0x88, 0xfa, 0xd9, 0x45, 0x95, 0x55, 0x68, 0x1e, 0x45, 0x51, 0x9f,
	0xb6, 0x6f, 0x9c, 0x76, 0x64, 0xba, 0x83, 0x13, 0x44, 0xe3, 0x7f, 0x6a, 0x71, 0x4d, 0x22, 0xb8,
	0x67, 0xd6, 0x26, 0x07, 0xe6, 0xc0, 0x8d, 0x44, 0x7b, 0xc5, 0xf0, 0x4e, 0xd8, 0xb9, 0x0c, 0x32,
	0xfa, 0x22, 0x94, 0x23, 0x77, 0xdc, 0xd4, 0x90, 0x0c, 0x19, 0xa6, 0xa5, 0xd1, 0x3d, 0x39, 0xa3,
	0x94, 0x47, 0x3e, 0x9d, 0xa0, 0x30, 0x48, 0x4e, 0x29, 0xb7, 0x41, 0x17, 0x5f, 0xb3, 0x4a, 0x1c,
	0x6f, 0xee, 0xa9, 0x0c, 0xc1, 0x0d, 0x4c, 0xbd, 0xb9, 0x20, 0x4a, 0x6e, 0x54, 0xb0, 0x17, 0x92,
	0x34, 0xe5, 0x85, 0xa4, 0x51, 0x2f, 0x2a, 0x2d, 0x40, 0x95, 0x04, 0x81, 0x1f, 0x88, 0x91, 0xe3,
	0x09, 0xe3, 0x03, 0xb8, 0xb2, 0x39, 0x7c, 0x1d, 0x7e, 0xe8, 0x23, 0x13, 0xe2, 0x63, 0xf8, 0x5e,
	0xe6, 0xcb, 0xf9, 0xcc, 0xcb, 0xfa, 0x92, 0x7c, 0x37, 0xa2, 0x32, 0x66, 0x3a, 0x95, 0x4d, 0x17,
	0xcf, 0x46, 0x18, 0x7b, 0x30, 0x23, 0x07, 0x92, 0x77, 0x69, 0x15, 0xea, 0xa2, 0xd3, 0x62, 0x0f,
	0xa2, 0xe8, 0x12, 0x5d, 0x4e, 0x93, 0xb1, 0x44, 0x65, 0xa1, 0x6e, 0xb2, 0x1f, 0x1f, 0x41, 0xa8,
	0x9b, 0x22, 0x8b, 0x67, 0x0c, 0x75, 0x4b, 0x75, 0xfe, 0x5c, 0x0b, 0xff, 0x6f, 0x01, 0x7a, 0x64,
	0x1e, 0x1c, 0x9b, 0x22, 0x0e, 0xfe, 0x21, 0x31, 0x6d, 0x12, 0xa0, 0x4f, 0xc2, 0xb4, 0x08, 0xdc,
	0xff, 0x66, 0xbc, 0x64, 0x99, 0xc1, 0x53, 0x02, 0xc6, 0x76, 0x4f, 0x3f, 0x0b, 0x73, 0xb2, 0xc8,
	0x89, 0x72, 0x9b, 0x65, 0x06, 0xcf, 0x0a, 0xb0, 0x7c, 0xed, 0xf5, 0xe7, 0x35, 0xd0, 0x59, 0x15,
	0xcb, 0x89, 0xbf, 0x82, 0x96, 0xd9, 0x6b, 0xc3, 0xb6, 0xd8, 0xeb, 0x2d, 0x8e, 0x53, 0x19, 0x6e,
	0x1b, 0x16, 0x88, 0x54, 0x1a, 0x23, 0xbf, 0xef, 0x58, 0x72, 0x37, 0x8d, 0x25, 0xf8, 0x93, 0x98,
	0xf2, 0x15, 0xef, 0x19, 0xcc, 0x13, 0xc6, 0x5f, 0xa8, 0xc2, 0xb5, 0x55, 0xba, 0x1a, 0x8c, 0x02,
	0x62, 0xf6, 0x42, 0xa5, 0x25, 0x21, 0xfa, 0xae, 0x06, 0xad, 0x63, 0x5a, 0x4d, 0x27, 0xf0, 0xed,
	0x81, 0x45, 0xd4, 0x4c, 0xd1, 0xba, 0x07, 0x85, 0x51, 0x34, 0xb9, 0x24, 0x79, 0xab, 0x73, 0xc8,
	0xe1, 0xc2, 0x8a, 0xd0, 0xcf, 0xc1, 0x22, 0xcb, 0xbb, 0x4f, 0x22, 0xeb, 0x28, 0xd5, 0x04, 0x2e,
	0x3b, 0x6b, 0xe7, 0x69, 0xc2, 0x10, 0x31, 0x5c, 0x50, 0x09, 0xda, 0x83, 0xf9, 0xe3, 0xcc, 0x18,
	0x49, 0x53, 0xf4, 0xd9, 0x51, 0x43, 0xa3, 0x94, 0xc7, 0xc3, 0x14, 0x96, 0xee, 0x01, 0xec, 0xd2,
	0x61, 0x61, 0x0f, 0x87, 0x27, 0x23, 0xa6, 0xe5, 0x8e, 0x58, 0x49, 0x19, 0xb1, 0xa5, 0x63, 0x68,
	0x15, 0x71, 0x11, 0xed, 0xf0, 0x9b, 0x59, 0xe1, 0x98, 0xa3, 0xf1, 0x22, 0xd6, 0x24, 0x2d, 0xe2,
	0x97, 0xba, 0xc2, 0x25, 0x07, 0x16, 0xf3, 0xf9, 0xf5, 0xcc, 0xab, 0x32, 0x3c, 0xd0, 0xe9, 0xcc,
	0x94, 0xaa, 0x64, 0x17, 0x16, 0x88, 0x67, 0xf7, 0x7d, 0xc7, 0x8b, 0x32, 0x23, 0x3f, 0xea, 0xeb,
	0xca, 0x94, 0x0c, 0x27, 0x9d, 0x8b, 0xbd, 0x51, 0x69, 0x68, 0x7a, 0xc9, 0x70, 0x60, 0x9e, 0x16,
	0xbc, 0x3b, 0x51, 0x85, 0xda, 0x45, 0x2a, 0x34, 0x7e, 0xad, 0x02, 0xcd, 0xb8, 0x0c, 0xfa, 0x3a,
	0x5c, 0x15, 0x2f, 0xd1, 0x63, 0x12, 0xf6, 0x7d, 0x2f, 0x14, 0x9b, 0xd1, 0xa2, 0x92, 0xcf, 0x8c,
	0xab, 0x84, 0xf1, 0x14, 0xe7, 0xd3, 0x40, 0x04, 0xe6, 0x45, 0x06, 0x07, 0xb4, 0x7d, 0x5b, 0xbe,
	0x7a, 0xf6, 0xa5, 0xb1, 0x84, 0xbb, 0x59, 0x4c, 0xf1, 0x8c, 0xea, 0x10, 0xc5, 0xd8, 0x05, 0xaa,
	0x28, 0x2e, 0x10, 0xfb, 0x7a, 0x49, 0x74, 0xe4, 0xf3, 0x6b, 0x12, 0xb3, 0x85, 0x93, 0x15, 0xad,
	0x6f, 0x8b, 0x15, 0xc4, 0x02, 0x81, 0x4e, 0x81, 0x07, 0x03, 0xd7, 0x65, 0xcf, 0x1d, 0xf2, 0xfb,
	0x27, 0x71, 0x7a, 0xe9, 0x18, 0x16, 0xf3, 0xdb, 0x95, 0xf3, 0x62, 0xff, 0xdb, 0xe9, 0x17, 0xfb,
	0x27, 0x64, 0xa5, 0x72, 0xef, 0xa9, 0x0f, 0x95, 0x55, 0xf1, 0xb8, 0xb4, 0x15, 0x3f, 0x82, 0x2b,
	0x55, 0x0f, 0x5d, 0x87, 0xa6, 0x6b, 0x46, 0xc4, 0xb3, 0x1c, 0xb1, 0x03, 0x39, 0x8d, 0x13, 0x00,
	0xba, 0x03, 0xe8, 0xc0, 0x09, 0xc2, 0x68, 0x93, 0x41, 0x4e, 0xbb, 0x66, 0xaf, 0x2f, 0x5e, 0x12,
	0xd1, 0x70, 0x4e, 0xce, 0x46, 0xa5, 0x51, 0xd6, 0x2b, 0xc6, 0x6b, 0xa0, 0xaf, 0x6e, 0x77, 0x69,
	0xa5, 0xfb, 0x66, 0x28, 0x3a, 0x76, 0x13, 0xa6, 0xe8, 0xec, 0xbf, 0x73, 0x70, 0x10, 0x12, 0xa1,
	0x61, 0x55, 0xac, 0x82, 0x8c, 0xdf, 0xd4, 0x60, 0x5a, 0xae, 0x3f, 0x37, 0x9d, 0x30, 0x42, 0x3f,
	0x9d, 0x7b, 0xbf, 0xea, 0xf5, 0x31, 0x4b, 0x57, 0x8a, 0xfa, 0xe1, 0x5f, 0xae, 0xfa, 0xaf, 0x25,
	0xb8, 0x9a, 0xff, 0xad, 0xd0, 0x8f, 0xe0, 0x5c, 0x21, 0xb7, 0xe2, 0x73, 0x9c, 0x2b, 0xe4, 0xd3,
	0x39, 0x7f, 0xd8, 0xd9, 0x5e, 0xce, 0xed, 0x93, 0xd7, 0xcf, 0x52, 0x77, 0x7e, 0xf8, 0xd8, 0x0f,
	0x34, 0xb8, 0x31, 0xba, 0xf8, 0xc7, 0x2c, 0xea, 0xf0, 0xc7, 0x1a, 0x3c, 0x5f, 0x38, 0x46, 0x74,
	0x74, 0xf8, 0x23, 0xa4, 0x42, 0x3c, 0xce, 0x34, 0x3a, 0xbb, 0x0c, 0x13, 0x0b, 0x0a, 0x74, 0xa9,
	0xc7, 0x23, 0x33, 0xb7, 0xb8, 0x4d, 0x64, 0x4b, 0xbd, 0x04, 0x82, 0xde, 0x07, 0x5d, 0x2e, 0x1d,
	0xd9, 0xf6, 0x94, 0x13, 0xaf, 0x39, 0xee, 0x8c, 0xfd, 0xf6, 0xa5, 0x8a, 0x77, 0x8a, 0x87, 0xe8,
	0x18, 0x6b, 0xf0, 0xc2, 0x88, 0x26, 0xe6, 0x6e, 0xc8, 0xca, 0x4d, 0xd7, 0x92, 0xb2, 0x97, 0xfe,
	0x4f, 0x4b, 0x70, 0xad, 0xa0, 0xd2, 0xd4, 0xb7, 0x83, 0x94, 0x65, 0x7f, 0x1a, 0x48, 0xa9, 0xf6,
	0x92, 0xee, 0xb3, 0xff, 0xa8, 0x0d, 0xd0, 0x73, 0xbc, 0x65, 0xd7, 0xf5, 0x9f, 0x88, 0xa0, 0xfe,
	0xe2, 0x8b, 0x50, 0xaa, 0xe5, 0xc0, 0x0a, 0x1a, 0x23, 0x62, 0x3e, 0x95, 0x44, 0x2a, 0x67, 0x21,
	0x12, 0xa3, 0xc9, 0xcf, 0x09, 0xb1, 0x93, 0x6a, 0x5b, 0x96, 0x12, 0x6a, 0x93, 0x93, 0x23, 0x3f,
	0xb2, 0xc3, 0xa1, 0xc2, 0xf2, 0xd5, 0xe2, 0x6b, 0x82, 0x29, 0xb8, 0xf1, 0xdf, 0xb4, 0x82, 0x31,
	0x48, 0xde, 0x35, 0xdb, 0x34, 0xc3, 0x08, 0x13, 0xcb, 0xef, 0xf5, 0x88, 0x67, 0x13, 0x7b, 0x55,
	0x7e, 0x7b, 0xa1, 0x8c, 0xf3, 0xb2, 0xd0, 0xd7, 0xa8, 0xa3, 0x2f, 0x40, 0x29, 0xc7, 0x64, 0x02,
	0x79, 0x51, 0xd1, 0x70, 0x96, 0x4c, 0xe6, 0x6a, 0x5a, 0x79, 0xe4, 0xd5, 0xb4, 0xc7, 0x9d, 0xe5,
	0x7c, 0x53, 0xf0, 0xfb, 0x69, 0x61, 0x51, 0x6b, 0x98, 0x50, 0x58, 0xde, 0x8e, 0xb5, 0xaf, 0x34,
	0xf9, 0x78, 0x4a, 0x75, 0x6b, 0x03, 0xd0, 0x41, 0x0d, 0x56, 0xfc, 0x81, 0x77, 0x36, 0xa9, 0x4a,
	0xd0, 0x28, 0x91, 0x41, 0xbf, 0x2f, 0x89, 0x9c, 0x45, 0xaa, 0x12, 0x34, 0xf4, 0x08, 0x66, 0x07,
	0x9e, 0x65, 0xf6, 0xfb, 0xc4, 0xe6, 0xfa, 0x26, 0x02, 0xc3, 0x26, 0x22, 0x94, 0x41, 0x35, 0xfe,
	0xb9, 0x06, 0xd3, 0x2a, 0xcb, 0x29, 0x2b, 0xe3, 0xc4, 0x6e, 0x62, 0x57, 0xd3, 0x40, 0x74, 0x8b,
	0x3d, 0xdb, 0xc0, 0x01, 0x5d, 0xd5, 0xd2, 0x66, 0xc1, 0x54, 0x07, 0x36, 0x0b, 0x4d, 0xee, 0x66,
	0xae, 0xc9, 0xc5, 0x29, 0x93, 0x8b, 0x63, 0x93, 0xbb, 0x95, 0x36, 0xb9, 0x22, 0x69, 0xfc, 0xf7,
	0x12, 0x5c, 0x2b, 0xfa, 0x4c, 0xf5, 0x85, 0x66, 0xe4, 0xfb, 0xa9, 0x19, 0xf9, 0xee, 0xd9, 0xbe,
	0x2b, 0xad, 0xcc, 0xc9, 0x9b, 0x99, 0x39, 0xf9, 0xb5, 0x33, 0x52, 0x3a, 0xff, 0xac, 0xfc, 0x5e,
	0xce, 0xac, 0xfc, 0xa5, 0xb3, 0xd5, 0x9e, 0xaf, 0x8c, 0xff, 0xb6, 0x04, 0x2f, 0x8c, 0xe8, 0x38,
	0xed, 0x72, 0x6a, 0xa2, 0x3b, 0x63, 0x97, 0x33, 0x53, 0xdd, 0x4d, 0x98, 0x62, 0xd7, 0xda, 0x52,
	0x37, 0x1d, 0x54, 0x10, 0x2b, 0x61, 0x3e, 0xcd, 0xdc, 0x71, 0x50, 0x41, 0x08, 0x27, 0xe7, 0x20,
	0x95, 0x91, 0x97, 0xf5, 0x0b, 0x9a, 0xc4, 0x7d, 0x46, 0x36, 0xaa, 0x71, 0xa4, 0x3c, 0x86, 0xc6,
	0x3e, 0x39, 0x32, 0x4f, 0x1c, 0x5f, 0x7e, 0x87, 0xf7, 0x8d, 0xb3, 0x11, 0x5d, 0x11, 0xd8, 0x38,
	0xa6, 0x63, 0x3c, 0x80, 0x17, 0x47, 0x32, 0x65, 0xe2, 0xc9, 0xf5, 0xfb, 0x65, 0xf8, 0xe4, 0xd8,
	0xbe, 0xe4, 0x7a, 0x4f, 0xcb, 0x50, 0xf3, 0xd9, 0x2e, 0xb4, 0x90, 0xfc, 0xcf, 0x8d, 0x3c, 0x97,
	0x10, 0xc4, 0x78, 0x80, 0x82, 0x40, 0x44, 0x6f, 0x43, 0xa5, 0xef, 0xdb, 0x52, 0xe0, 0x3f, 0x5b,
	0xfc, 0xb6, 0x4d, 0x98, 0x42, 0x67, 0x48, 0xe8, 0x81, 0xb2, 0x6d, 0x5e, 0x99, 0x28, 0x30, 0x22,
	0x45, 0x24, 0x46, 0x46, 0xfb, 0xca, 0x2b, 0x4f, 0xca, 0xf4, 0x3b, 0x4a, 0x20, 0x87, 0xdc, 0x91,
	0x14, 0xe9, 0x61, 0x72, 0xb4, 0xb1, 0xf2, 0x79, 0x55, 0x71, 0xc0, 0x56, 0xd4, 0xd8, 0x35, 0x51,
	0x2c, 0xdd, 0x58, 0x89, 0x6c, 0xfc, 0x27, 0x0d, 0xd0, 0x30, 0x47, 0x51, 0x87, 0xdd, 0xc6, 0xb2,
	0x02, 0x67, 0x9f, 0xd8, 0x3c, 0x5b, 0xa8, 0xd4, 0xa4, 0xa7, 0x45, 0x59, 0xf4, 0x89, 0xa7, 0x41,
	0xde, 0x8c, 0x8c, 0x2a, 0x7e, 0x95, 0xad, 0x8a, 0x03, 0xc7, 0x1a, 0x33, 0xb4, 0x1c, 0x79, 0xdd,
	0x26, 0x5e, 0xe4, 0x1c, 0x38, 0x24, 0xc0, 0x02, 0xcd, 0xb8, 0x07, 0xd3, 0x2a, 0xe1, 0x5c, 0x01,
	0xcc, 0x0d, 0xba, 0x31, 0x7e, 0x0e, 0xf4, 0x2c, 0xd5, 0xdc, 0xe0, 0xb9, 0x3d, 0x98, 0x71, 0xd5,
	0xb3, 0xd4, 0xf3, 0x06, 0x93, 0xa5, 0xa9, 0x18, 0xdf, 0xd3, 0x40, 0xcf, 0x0a, 0xac, 0xc2, 0x0e,
	0xed, 0x5c, 0xec, 0xb8, 0xd0, 0x60, 0x18, 0x4f, 0x92, 0xa7, 0x62, 0x52, 0xad, 0xe2, 0xaf, 0x1e,
	0xc5, 0x61, 0x15, 0x82, 0x3b, 0x29, 0xd8, 0xc5, 0x2a, 0xfe, 0x9b, 0x1a, 0xbc, 0x38, 0x52, 0x53,
	0x3e, 0xf4, 0x26, 0xb0, 0x97, 0x9f, 0xe3, 0x6f, 0xfa, 0xcb, 0x97, 0x9f, 0x25, 0xc0, 0xf8, 0x15,
	0x0d, 0x16, 0xf2, 0xf4, 0xed, 0x92, 0x07, 0xec, 0x37, 0x34, 0xf8, 0xc4, 0x98, 0xa9, 0x80, 0x1d,
	0x0b, 0x53, 0xc8, 0x5e, 0x7f, 0x8c, 0xa2, 0x3f, 0xec, 0x2c, 0x77, 0x2d, 0xd3, 0x75, 0xbc, 0x43,
	0x16, 0x15, 0x80, 0x25, 0x1a, 0x5a, 0x85, 0x26, 0xfb, 0xbb, 0xea, 0x3f, 0xf1, 0xc6, 0xdc, 0x58,
	0xcb, 0xd2, 0x48, 0x10, 0x8d, 0x7f, 0xa6, 0xc1, 0x5c, 0x26, 0x9b, 0x3d, 0xb8, 0x10, 0x99, 0xfb,
	0x8e, 0xeb, 0x7c, 0xc0, 0x1c, 0xef, 0xf7, 0x1c, 0xcf, 0xf6, 0x9f, 0xa4, 0x3f, 0x7f, 0x31, 0xa2,
	0x04, 0x95, 0x0a, 0x1e, 0x47, 0x26, 0x2e, 0xfb, 0x88, 0x08, 0x6f, 0x15, 0x86, 0xda, 0xd0, 0xe8,
	0xa7, 0xd7, 0xab, 0x9f, 0x1d, 0xdb, 0x78, 0xb1, 0x50, 0x8d, 0x11, 0x8d, 0x7d, 0xd0, 0xb3, 0xb9,
	0xe3, 0x2d, 0x8d, 0xfc, 0x6e, 0x0e, 0x7b, 0x4b, 0x8e, 0x04, 0x8e, 0x6f, 0xab, 0xcf, 0xdc, 0x54,
	0x71, 0x1a, 0x68, 0x7c, 0xbf, 0x54, 0x38, 0x55, 0x27, 0xbe, 0xaf, 0xbf, 0x1f, 0x92, 0xe0, 0x84,
	0xd8, 0x0f, 0x88, 0xc7, 0x1e, 0xff, 0xf7, 0x3d, 0xb1, 0x04, 0xcb, 0xc9, 0x91, 0xc1, 0x60, 0xb4,
	0xd9, 0xea, 0x13, 0x0d, 0x69, 0xe0, 0xd9, 0xee, 0x74, 0x66, 0x6f, 0xf2, 0x56, 0xf2, 0x6f, 0xf2,
	0xee, 0xc3, 0xac, 0x40, 0x16, 0xe1, 0x1f, 0x22, 0x40, 0xfe, 0xad, 0x73, 0x39, 0x49, 0xdc, 0x61,
	0xcd, 0x50, 0x34, 0xfe, 0x40, 0x83, 0x9b, 0xe3, 0x9c, 0x4c, 0xb1, 0x92, 0x1b, 0x5e, 0x7e, 0x58,
	0xd9, 0xe5, 0x87, 0x95, 0xbf, 0xfc, 0xb0, 0x86, 0x97, 0x1f, 0x1f, 0xf2, 0x8e, 0xcf, 0x3f, 0x2a,
	0xc3, 0xa7, 0x26, 0x60, 0xc7, 0xb3, 0xf3, 0xb4, 0xc4, 0x72, 0xe0, 0xbc, 0x9e, 0x16, 0x47, 0xbf,
	0xa0, 0xa7, 0xc5, 0x89, 0x7c, 0x28, 0x9e, 0x56, 0xf6, 0x75, 0xcd, 0x8b, 0x7b, 0x5a, 0xa2, 0xb1,
	0xb1, 0xa7, 0xf5, 0x2f, 0xb2, 0x9e, 0x16, 0x1f, 0xa0, 0x67, 0xef, 0x69, 0xb5, 0xa0, 0x2e, 0x74,
	0x40, 0x68, 0xb2, 0x4c, 0x5e, 0xdc, 0x8d, 0xea, 0xa5, 0x9c, 0x11, 0xde, 0x81, 0x0b, 0xcf, 0x6d,
	0x85, 0xed, 0x35, 0x76, 0x87, 0x3c, 0x0d, 0x5e, 0xe5, 0x24, 0xd3, 0x7c, 0x31, 0xd5, 0x9f, 0x2d,
	0xf6, 0x22, 0x9e, 0x01, 0xf9, 0x31, 0x2e, 0xc2, 0x77, 0x86, 0x3c, 0x84, 0x0f, 0x9b, 0x8b, 0xb7,
	0xd7, 0x60, 0x3e, 0xf9, 0xaa, 0xae, 0x2f, 0xce, 0xd7, 0x75, 0x98, 0xf6, 0x7c, 0x76, 0x5f, 0x9c,
	0x7d, 0xcc, 0x50, 0x7f, 0x0e, 0xcd, 0x02, 0x1c, 0x98, 0xc1, 0xa1, 0x19, 0x91, 0xb5, 0x76, 0x57,
	0xd7, 0xd4, 0xf4, 0xa3, 0xae, 0x5e, 0xba, 0xed, 0x28, 0x9f, 0x0e, 0xe1, 0x1f, 0x78, 0x9f, 0x82,
	0xfa, 0xc0, 0x3b, 0xf6, 0xfc, 0x27, 0x9e, 0xfe, 0x1c, 0x4d, 0xf0, 0x8f, 0xf0, 0xdb, 0x1c, 0x57,
	0x3c, 0x76, 0xe9, 0x78, 0x87, 0x7a, 0x89, 0x66, 0x06, 0x03, 0xcf, 0xa3, 0x89, 0x32, 0x02, 0xf9,
	0xc8, 0xbb, 0x5e, 0xa1, 0xff, 0xc9, 0x53, 0x87, 0x22, 0x55, 0x51, 0x03, 0x2a, 0x36, 0x31, 0x6d,
	0xbd, 0x76, 0x7b, 0x5b, 0x79, 0x9e, 0x53, 0x7c, 0xfa, 0x7d, 0x1e, 0x66, 0x44, 0x5d, 0x1c, 0xa0,
	0x3f, 0x87, 0xa6, 0xa1, 0x11, 0x57, 0xa1, 0xd1, 0x2a, 0xf8, 0xc7, 0x23, 0x4e, 0xf5, 0x12, 0x9a,
	0x81, 0xe6, 0xc0, 0x93, 0xc9, 0xf2, 0xed, 0xfb, 0x30, 0xad, 0x7e, 0xa7, 0x1e, 0x55, 0x41, 0xdb,
	0xd3, 0x9f, 0xa3, 0x3f, 0xab, 0xba, 0x46, 0x7f, 0xb0, 0x5e, 0xa2, 0x3f, 0x5d, 0xbd, 0x4c, 0x7f,
	0x76, 0xf5, 0x0a, 0xfd, 0x79, 0x4f, 0xaf, 0xd2, 0x9f, 0xaf, 0xe9, 0x35, 0xfa, 0xf3, 0xbe, 0x5e,
	0xbf, 0x6d, 0x30, 0x16, 0x78, 0xc4, 0x8a, 0xa7, 0x84, 0x3a, 0x94, 0x23, 0xab, 0xaf, 0x3f, 0x47,
	0xff, 0x0c, 0xec, 0xbe, 0xae, 0xdd, 0xfe, 0xeb, 0x65, 0x98, 0x7a, 0x74, 0x2f, 0x8c, 0xed, 0xc7,
	0x0b, 0x70, 0xed, 0xd1, 0xbd, 0x2e, 0x5e, 0xeb, 0xee, 0xec, 0xe1, 0xf6, 0xda, 0x37, 0xf7, 0xb6,
	0xbb, 0x9d, 0xb5, 0xf6, 0xfa, 0xfd, 0xf5, 0xb5, 0x55, 0x8e, 0xd5, 0xd9, 0x59, 0xe5, 0x0c, 0xc3,
	0x6b, 0x9d, 0xcd, 0xf5, 0xf6, 0x72, 0x77, 0x6d, 0x97, 0x33, 0xac, 0xbb, 0x86, 0x1f, 0xaf, 0xb7,
	0xd7, 0xf4, 0x32, 0x65, 0xcc, 0xf6, 0xce, 0xea, 0x9a, 0x5e, 0xa1, 0xe0, 0xf6, 0xe6, 0x5e, 0x77,
	0x77, 0x0d, 0xeb, 0x55, 0x8a, 0xbc, 0xb1, 0xb3, 0xa2, 0xd7, 0x18, 0x14, 0xef, 0x6c, 0xd3, 0x44,
	0x9d, 0x76, 0x7d, 0x75, 0x79, 0x6d, 0x6b, 0x67, 0x9b, 0x12, 0x6a, 0xa0, 0x39, 0x98, 0xea, 0xee,
	0x2e, 0xef, 0xae, 0xdd, 0xdf, 0xdb, 0xa4, 0x80, 0x26, 0x5a, 0x00, 0xbd, 0xb3, 0x86, 0xbb, 0xeb,
	0xdd, 0xdd, 0xb5, 0xed, 0xdd, 0xc7, 0x3b, 0x9b, 0x7b, 0x5b, 0x6b, 0x3a, 0xa0, 0xe7, 0xe1, 0x6a,
	0x16, 0xda, 0xde, 0x5c, 0x5e, 0xdf, 0xd2, 0xa7, 0x68, 0xed, 0x78, 0x67, 0x73, 0x4d, 0x9f, 0xa6,
	0xb4, 0xe8, 0xbf, 0x95, 0xf5, 0xed, 0xd5, 0xf5, 0xed, 0x07, 0xfa, 0x0c, 0x05, 0x88, 0xe6, 0xb0,
	0x12, 0xb3, 0x68, 0x11, 0x90, 0x02, 0x90, 0x05, 0xe7, 0x10, 0x82, 0x59, 0xd1, 0x9d, 0xe5, 0x76,
	0x7b, 0x67, 0x6f, 0x7b, 0x57, 0xd7, 0x69, 0xab, 0xd7, 0xb7, 0x1f, 0xe0, 0xb5, 0x6e, 0x57, 0x9f,
	0xa7, 0xfd, 0x5f, 0x5d, 0xeb, 0x6c, 0xee, 0xfc, 0xf4, 0xd6, 0xda, 0xf6, 0xae, 0x8e, 0x68, 0x2f,
	0xb6, 0x97, 0xb7, 0xd6, 0xba, 0x9d, 0xe5, 0xf6, 0x9a, 0x7e, 0x85, 0x76, 0xb5, 0x8d, 0x57, 0xf5,
	0x05, 0x54, 0x83, 0x52, 0x1b, 0xeb, 0x57, 0x69, 0x7b, 0x1f, 0xaf, 0xe1, 0xdd, 0xf5, 0xf6, 0xf2,
	0x66, 0x67, 0x67, 0x75, 0x79, 0x6f, 0x77, 0xa7, 0xdb, 0x5e, 0xde, 0x5c, 0xc3, 0xfa, 0x22, 0x65,
	0xf8, 0xc3, 0x1d, 0xbc, 0xfe, 0xfe, 0xce, 0xf6, 0x6e, 0x36, 0xf3, 0xda, 0x6d, 0x02, 0xad, 0xa2,
	0xf7, 0x1e, 0x69, 0x6f, 0x84, 0x88, 0xd1, 0xa4, 0xfe, 0x1c, 0x6d, 0x44, 0xac, 0xb8, 0xba, 0x46,
	0x45, 0x30, 0xf5, 0x40, 0xb0, 0x5e, 0xa2, 0xfd, 0x25, 0xfd, 0x23, 0xd2, 0x23, 0x81, 0xe9, 0x26,
	0xf0, 0xf2, 0xed, 0xf7, 0x00, 0x3d, 0xdc, 0xdd, 0xed, 0x64, 0x8e, 0x95, 0x1b, 0x50, 0x59, 0xf7,
	0x0e, 0x7c, 0xae, 0x2c, 0x5d, 0xfe, 0x40, 0x98, 0xae, 0x51, 0x39, 0xc6, 0xc4, 0x76, 0x02, 0x62,
	0x45, 0x5c, 0x74, 0xdb, 0xec, 0x4b, 0x6e, 0x6b, 0x41, 0xa0, 0x97, 0x69, 0x92, 0x7f, 0x8b, 0x91,
	0x26, 0x2b, 0xb7, 0x2d, 0x80, 0xe4, 0xe4, 0x97, 0x92, 0xd9, 0x8b, 0x15, 0xb0, 0x0e, 0xe5, 0x07,
	0x24, 0xd2, 0x35, 0x5a, 0x4d, 0xc7, 0x0f, 0x29, 0x2d, 0x2a, 0x5e, 0x83, 0x88, 0xab, 0xdc, 0x2a,
	0x71, 0x49, 0x44, 0xf4, 0x0a, 0xcd, 0x7e, 0x48, 0xd5, 0xac, 0x4a, 0xd1, 0xc5, 0x55, 0x74, 0xbd,
	0x86, 0x9a, 0x50, 0xed, 0x98, 0x91, 0x75, 0xa4, 0xd7, 0x57, 0xbe, 0xf2, 0xaf, 0x7e, 0x74, 0x43,
	0xfb, 0xd7, 0x3f, 0xba, 0xa1, 0xfd, 0xd1, 0x8f, 0x6e, 0x68, 0xdf, 0xfb, 0xf1, 0x8d, 0xe7, 0xde,
	0xff, 0xfc, 0xa1, 0x13, 0x1d, 0x0d, 0xf6, 0xef, 0x58, 0x7e, 0xef, 0x95, 0x55, 0x33, 0x32, 0x57,
	0xfd, 0xc3, 0x57, 0x98, 0x3d, 0xfa, 0x42, 0xdf, 0x3c, 0x75, 0x7d, 0xd3, 0x7e, 0xe5, 0xe4, 0xf5,
	0x57, 0x84, 0xa1, 0xda, 0xaf, 0xb1, 0x88, 0xae, 0x2f, 0xfe, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x3c, 0x91, 0x0e, 0x43, 0x7e, 0xad, 0x00, 0x00,
}
