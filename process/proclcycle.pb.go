// Code generated by protoc-gen-gogo.
// source: proto/process/proclcycle.proto
// DO NOT EDIT!

package process

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// ProcEventType is a type of process lifecycle event collected by the process-agent
type ProcEventType int32

const (
	ProcEventType_exec ProcEventType = 0
	ProcEventType_exit ProcEventType = 1
)

var ProcEventType_name = map[int32]string{
	0: "exec",
	1: "exit",
}
var ProcEventType_value = map[string]int32{
	"exec": 0,
	"exit": 1,
}

func (x ProcEventType) String() string {
	return proto.EnumName(ProcEventType_name, int32(x))
}
func (ProcEventType) EnumDescriptor() ([]byte, []int) { return fileDescriptorProclcycle, []int{0} }

// CollectorProcEvent is a payload used to send a batch of process lifecycle events
type CollectorProcEvent struct {
	Hostname  string          `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Host      *Host           `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
	Info      *SystemInfo     `protobuf:"bytes,3,opt,name=info" json:"info,omitempty"`
	Events    []*ProcessEvent `protobuf:"bytes,4,rep,name=events" json:"events,omitempty"`
	GroupId   int32           `protobuf:"varint,5,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize int32           `protobuf:"varint,6,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
}

func (m *CollectorProcEvent) Reset()                    { *m = CollectorProcEvent{} }
func (m *CollectorProcEvent) String() string            { return proto.CompactTextString(m) }
func (*CollectorProcEvent) ProtoMessage()               {}
func (*CollectorProcEvent) Descriptor() ([]byte, []int) { return fileDescriptorProclcycle, []int{0} }

func (m *CollectorProcEvent) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *CollectorProcEvent) GetInfo() *SystemInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CollectorProcEvent) GetEvents() []*ProcessEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

// ProcessEvent holds information about a process lifeycle event
type ProcessEvent struct {
	Type           ProcEventType `protobuf:"varint,1,opt,name=type,proto3,enum=datadog.process_agent.ProcEventType" json:"type,omitempty"`
	CollectionTime int64         `protobuf:"varint,2,opt,name=collectionTime,proto3" json:"collectionTime,omitempty"`
	Pid            uint32        `protobuf:"varint,3,opt,name=pid,proto3" json:"pid,omitempty"`
	Command        *Command      `protobuf:"bytes,4,opt,name=command" json:"command,omitempty"`
	User           *ProcessUser  `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	Host           *Host         `protobuf:"bytes,6,opt,name=host" json:"host,omitempty"`
	ContainerId    string        `protobuf:"bytes,7,opt,name=containerId,proto3" json:"containerId,omitempty"`
	// Types that are valid to be assigned to TypedEvent:
	//	*ProcessEvent_Exec
	//	*ProcessEvent_Exit
	TypedEvent isProcessEvent_TypedEvent `protobuf_oneof:"typedEvent"`
}

func (m *ProcessEvent) Reset()                    { *m = ProcessEvent{} }
func (m *ProcessEvent) String() string            { return proto.CompactTextString(m) }
func (*ProcessEvent) ProtoMessage()               {}
func (*ProcessEvent) Descriptor() ([]byte, []int) { return fileDescriptorProclcycle, []int{1} }

type isProcessEvent_TypedEvent interface {
	isProcessEvent_TypedEvent()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ProcessEvent_Exec struct {
	Exec *ProcessExec `protobuf:"bytes,8,opt,name=exec,oneof"`
}
type ProcessEvent_Exit struct {
	Exit *ProcessExit `protobuf:"bytes,9,opt,name=exit,oneof"`
}

func (*ProcessEvent_Exec) isProcessEvent_TypedEvent() {}
func (*ProcessEvent_Exit) isProcessEvent_TypedEvent() {}

func (m *ProcessEvent) GetTypedEvent() isProcessEvent_TypedEvent {
	if m != nil {
		return m.TypedEvent
	}
	return nil
}

func (m *ProcessEvent) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ProcessEvent) GetUser() *ProcessUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *ProcessEvent) GetHost() *Host {
	if m != nil {
		return m.Host
	}
	return nil
}

func (m *ProcessEvent) GetExec() *ProcessExec {
	if x, ok := m.GetTypedEvent().(*ProcessEvent_Exec); ok {
		return x.Exec
	}
	return nil
}

func (m *ProcessEvent) GetExit() *ProcessExit {
	if x, ok := m.GetTypedEvent().(*ProcessEvent_Exit); ok {
		return x.Exit
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ProcessEvent) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ProcessEvent_OneofMarshaler, _ProcessEvent_OneofUnmarshaler, _ProcessEvent_OneofSizer, []interface{}{
		(*ProcessEvent_Exec)(nil),
		(*ProcessEvent_Exit)(nil),
	}
}

func _ProcessEvent_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ProcessEvent)
	// typedEvent
	switch x := m.TypedEvent.(type) {
	case *ProcessEvent_Exec:
		_ = b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Exec); err != nil {
			return err
		}
	case *ProcessEvent_Exit:
		_ = b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Exit); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ProcessEvent.TypedEvent has unexpected type %T", x)
	}
	return nil
}

func _ProcessEvent_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ProcessEvent)
	switch tag {
	case 8: // typedEvent.exec
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProcessExec)
		err := b.DecodeMessage(msg)
		m.TypedEvent = &ProcessEvent_Exec{msg}
		return true, err
	case 9: // typedEvent.exit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ProcessExit)
		err := b.DecodeMessage(msg)
		m.TypedEvent = &ProcessEvent_Exit{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ProcessEvent_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ProcessEvent)
	// typedEvent
	switch x := m.TypedEvent.(type) {
	case *ProcessEvent_Exec:
		s := proto.Size(x.Exec)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *ProcessEvent_Exit:
		s := proto.Size(x.Exit)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// ProcessExec holds information specific to exec events
type ProcessExec struct {
	ForkTime int64 `protobuf:"varint,1,opt,name=forkTime,proto3" json:"forkTime,omitempty"`
	ExecTime int64 `protobuf:"varint,2,opt,name=execTime,proto3" json:"execTime,omitempty"`
}

func (m *ProcessExec) Reset()                    { *m = ProcessExec{} }
func (m *ProcessExec) String() string            { return proto.CompactTextString(m) }
func (*ProcessExec) ProtoMessage()               {}
func (*ProcessExec) Descriptor() ([]byte, []int) { return fileDescriptorProclcycle, []int{2} }

// ProcessExit holds information specific to exit events
type ProcessExit struct {
	ExitCode int32 `protobuf:"varint,1,opt,name=exitCode,proto3" json:"exitCode,omitempty"`
	ExecTime int64 `protobuf:"varint,2,opt,name=execTime,proto3" json:"execTime,omitempty"`
	ExitTime int64 `protobuf:"varint,3,opt,name=exitTime,proto3" json:"exitTime,omitempty"`
}

func (m *ProcessExit) Reset()                    { *m = ProcessExit{} }
func (m *ProcessExit) String() string            { return proto.CompactTextString(m) }
func (*ProcessExit) ProtoMessage()               {}
func (*ProcessExit) Descriptor() ([]byte, []int) { return fileDescriptorProclcycle, []int{3} }

func init() {
	proto.RegisterType((*CollectorProcEvent)(nil), "datadog.process_agent.CollectorProcEvent")
	proto.RegisterType((*ProcessEvent)(nil), "datadog.process_agent.ProcessEvent")
	proto.RegisterType((*ProcessExec)(nil), "datadog.process_agent.ProcessExec")
	proto.RegisterType((*ProcessExit)(nil), "datadog.process_agent.ProcessExit")
	proto.RegisterEnum("datadog.process_agent.ProcEventType", ProcEventType_name, ProcEventType_value)
}
func (m *CollectorProcEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorProcEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Hostname) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintProclcycle(data, i, uint64(len(m.Hostname)))
		i += copy(data[i:], m.Hostname)
	}
	if m.Host != nil {
		data[i] = 0x12
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Host.Size()))
		n1, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Info != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Info.Size()))
		n2, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Events) > 0 {
		for _, msg := range m.Events {
			data[i] = 0x22
			i++
			i = encodeVarintProclcycle(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GroupId != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.GroupSize))
	}
	return i, nil
}

func (m *ProcessEvent) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessEvent) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Type))
	}
	if m.CollectionTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.CollectionTime))
	}
	if m.Pid != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Pid))
	}
	if m.Command != nil {
		data[i] = 0x22
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Command.Size()))
		n3, err := m.Command.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.User != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.User.Size()))
		n4, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Host != nil {
		data[i] = 0x32
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Host.Size()))
		n5, err := m.Host.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.ContainerId) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintProclcycle(data, i, uint64(len(m.ContainerId)))
		i += copy(data[i:], m.ContainerId)
	}
	if m.TypedEvent != nil {
		nn6, err := m.TypedEvent.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += nn6
	}
	return i, nil
}

func (m *ProcessEvent_Exec) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Exec != nil {
		data[i] = 0x42
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Exec.Size()))
		n7, err := m.Exec.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *ProcessEvent_Exit) MarshalTo(data []byte) (int, error) {
	i := 0
	if m.Exit != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.Exit.Size()))
		n8, err := m.Exit.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *ProcessExec) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessExec) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ForkTime != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.ForkTime))
	}
	if m.ExecTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.ExecTime))
	}
	return i, nil
}

func (m *ProcessExit) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProcessExit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ExitCode != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.ExitCode))
	}
	if m.ExecTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.ExecTime))
	}
	if m.ExitTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintProclcycle(data, i, uint64(m.ExitTime))
	}
	return i, nil
}

func encodeFixed64Proclcycle(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Proclcycle(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintProclcycle(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *CollectorProcEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovProclcycle(uint64(l))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovProclcycle(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovProclcycle(uint64(l))
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovProclcycle(uint64(l))
		}
	}
	if m.GroupId != 0 {
		n += 1 + sovProclcycle(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovProclcycle(uint64(m.GroupSize))
	}
	return n
}

func (m *ProcessEvent) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovProclcycle(uint64(m.Type))
	}
	if m.CollectionTime != 0 {
		n += 1 + sovProclcycle(uint64(m.CollectionTime))
	}
	if m.Pid != 0 {
		n += 1 + sovProclcycle(uint64(m.Pid))
	}
	if m.Command != nil {
		l = m.Command.Size()
		n += 1 + l + sovProclcycle(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovProclcycle(uint64(l))
	}
	if m.Host != nil {
		l = m.Host.Size()
		n += 1 + l + sovProclcycle(uint64(l))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovProclcycle(uint64(l))
	}
	if m.TypedEvent != nil {
		n += m.TypedEvent.Size()
	}
	return n
}

func (m *ProcessEvent_Exec) Size() (n int) {
	var l int
	_ = l
	if m.Exec != nil {
		l = m.Exec.Size()
		n += 1 + l + sovProclcycle(uint64(l))
	}
	return n
}
func (m *ProcessEvent_Exit) Size() (n int) {
	var l int
	_ = l
	if m.Exit != nil {
		l = m.Exit.Size()
		n += 1 + l + sovProclcycle(uint64(l))
	}
	return n
}
func (m *ProcessExec) Size() (n int) {
	var l int
	_ = l
	if m.ForkTime != 0 {
		n += 1 + sovProclcycle(uint64(m.ForkTime))
	}
	if m.ExecTime != 0 {
		n += 1 + sovProclcycle(uint64(m.ExecTime))
	}
	return n
}

func (m *ProcessExit) Size() (n int) {
	var l int
	_ = l
	if m.ExitCode != 0 {
		n += 1 + sovProclcycle(uint64(m.ExitCode))
	}
	if m.ExecTime != 0 {
		n += 1 + sovProclcycle(uint64(m.ExecTime))
	}
	if m.ExitTime != 0 {
		n += 1 + sovProclcycle(uint64(m.ExitTime))
	}
	return n
}

func sovProclcycle(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozProclcycle(x uint64) (n int) {
	return sovProclcycle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectorProcEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProclcycle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorProcEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorProcEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &SystemInfo{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &ProcessEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProclcycle(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProclcycle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessEvent) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProclcycle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (ProcEventType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CollectionTime", wireType)
			}
			m.CollectionTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CollectionTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Command == nil {
				m.Command = &Command{}
			}
			if err := m.Command.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &ProcessUser{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Host == nil {
				m.Host = &Host{}
			}
			if err := m.Host.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProcessExec{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TypedEvent = &ProcessEvent_Exec{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthProclcycle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProcessExit{}
			if err := v.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TypedEvent = &ProcessEvent_Exit{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProclcycle(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProclcycle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessExec) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProclcycle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessExec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessExec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForkTime", wireType)
			}
			m.ForkTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ForkTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecTime", wireType)
			}
			m.ExecTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExecTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProclcycle(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProclcycle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessExit) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProclcycle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessExit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessExit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExitCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecTime", wireType)
			}
			m.ExecTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExecTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitTime", wireType)
			}
			m.ExitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExitTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipProclcycle(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthProclcycle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProclcycle(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProclcycle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProclcycle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthProclcycle
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowProclcycle
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipProclcycle(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthProclcycle = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProclcycle   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/process/proclcycle.proto", fileDescriptorProclcycle) }

var fileDescriptorProclcycle = []byte{
	// 519 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xcd, 0x6a, 0xdb, 0x40,
	0x10, 0x8e, 0x22, 0xf9, 0x6f, 0x9d, 0x04, 0xb3, 0x50, 0xd8, 0xa6, 0x45, 0xb8, 0x4e, 0x29, 0xa6,
	0xa5, 0x36, 0xb8, 0xa4, 0x04, 0x4a, 0x2f, 0x71, 0x0c, 0xf1, 0x2d, 0x6c, 0xd2, 0x4b, 0x2f, 0x65,
	0xb3, 0x5a, 0x3b, 0x4b, 0x2d, 0x8d, 0x90, 0xd6, 0x21, 0xea, 0x3b, 0x14, 0xfa, 0x58, 0xed, 0xad,
	0x8f, 0x50, 0xdc, 0x17, 0x29, 0x9a, 0x8d, 0x54, 0xa5, 0xd4, 0xc6, 0x27, 0xcd, 0x37, 0xf3, 0x7d,
	0xb3, 0xa3, 0x6f, 0x76, 0x89, 0x1f, 0x27, 0x60, 0x60, 0x18, 0x27, 0x20, 0x55, 0x9a, 0xe2, 0x77,
	0x21, 0x33, 0xb9, 0x50, 0x03, 0x2c, 0xd0, 0x47, 0x81, 0x30, 0x22, 0x80, 0xf9, 0xe0, 0x9e, 0xf1,
	0x49, 0xcc, 0x55, 0x64, 0x0e, 0x1f, 0x3f, 0x94, 0x61, 0xd2, 0x2a, 0x7a, 0x5f, 0x77, 0x09, 0x1d,
	0xc3, 0x62, 0xa1, 0xa4, 0x81, 0xe4, 0x22, 0x01, 0x39, 0xb9, 0x55, 0x91, 0xa1, 0x87, 0xa4, 0x79,
	0x03, 0xa9, 0x89, 0x44, 0xa8, 0x98, 0xd3, 0x75, 0xfa, 0x2d, 0x5e, 0x62, 0x3a, 0x24, 0x5e, 0x1e,
	0xb3, 0xdd, 0xae, 0xd3, 0x6f, 0x8f, 0x9e, 0x0c, 0xfe, 0x7b, 0xe6, 0xe0, 0x1c, 0x52, 0xc3, 0x91,
	0x48, 0x8f, 0x89, 0xa7, 0xa3, 0x19, 0x30, 0x17, 0x05, 0xcf, 0xd6, 0x08, 0x2e, 0xb3, 0xd4, 0xa8,
	0x70, 0x1a, 0xcd, 0x80, 0x23, 0x9d, 0xbe, 0x23, 0x75, 0x95, 0x0f, 0x93, 0x32, 0xaf, 0xeb, 0xf6,
	0xdb, 0xa3, 0xa3, 0x35, 0xc2, 0x0b, 0x8b, 0x70, 0x70, 0x7e, 0x2f, 0xa1, 0x8c, 0x34, 0xe6, 0x09,
	0x2c, 0xe3, 0x69, 0xc0, 0x6a, 0x5d, 0xa7, 0x5f, 0xe3, 0x05, 0xa4, 0x4f, 0x49, 0x0b, 0xc3, 0x4b,
	0xfd, 0x45, 0xb1, 0x3a, 0xd6, 0xfe, 0x26, 0x7a, 0x3f, 0x5c, 0xb2, 0x57, 0x6d, 0x48, 0x4f, 0x88,
	0x67, 0xb2, 0xd8, 0xba, 0x70, 0x30, 0x7a, 0xbe, 0x61, 0x06, 0xe4, 0x5f, 0x65, 0xb1, 0xe2, 0xa8,
	0xa0, 0x2f, 0xc8, 0x81, 0xb4, 0xce, 0x6a, 0x88, 0xae, 0x74, 0xa8, 0xd0, 0x31, 0x97, 0xff, 0x93,
	0xa5, 0x1d, 0xe2, 0xc6, 0x3a, 0x40, 0x77, 0xf6, 0x79, 0x1e, 0xd2, 0x13, 0xd2, 0x90, 0x10, 0x86,
	0x22, 0x0a, 0x98, 0x87, 0x9e, 0xf9, 0x6b, 0x8e, 0x1d, 0x5b, 0x16, 0x2f, 0xe8, 0xf4, 0x2d, 0xf1,
	0x96, 0xa9, 0x4a, 0xf0, 0x9f, 0xdb, 0xa3, 0xde, 0x66, 0xc7, 0x3e, 0xa4, 0x2a, 0xe1, 0xc8, 0x2f,
	0x77, 0x5a, 0xdf, 0x76, 0xa7, 0x5d, 0xd2, 0x96, 0x10, 0x19, 0xa1, 0x23, 0x95, 0x4c, 0x03, 0xd6,
	0xc0, 0x3b, 0x52, 0x4d, 0xe5, 0xc6, 0xa9, 0x3b, 0x25, 0x59, 0x73, 0x9b, 0x51, 0x26, 0x77, 0x4a,
	0x9e, 0xef, 0x70, 0x54, 0x58, 0xa5, 0x36, 0xac, 0xb5, 0x9d, 0x52, 0x1b, 0xab, 0xd4, 0xe6, 0x74,
	0x8f, 0x90, 0xdc, 0xfa, 0x00, 0x57, 0xd1, 0x9b, 0x90, 0x76, 0xa5, 0x7d, 0x7e, 0xa7, 0x67, 0x90,
	0x7c, 0xc6, 0x4d, 0x38, 0xb8, 0x89, 0x12, 0xe7, 0xb5, 0xfc, 0xe8, 0xca, 0x96, 0x4a, 0xdc, 0x13,
	0x95, 0x36, 0xda, 0x58, 0xaa, 0x36, 0x63, 0x08, 0x6c, 0x9b, 0x1a, 0x2f, 0xf1, 0xa6, 0x36, 0x85,
	0x0e, 0x6b, 0x6e, 0x51, 0xb3, 0xf8, 0xe5, 0x11, 0xd9, 0x7f, 0x70, 0x83, 0x68, 0xd3, 0x9a, 0xd7,
	0xd9, 0xb1, 0x91, 0x36, 0x1d, 0xe7, 0xf4, 0xfd, 0xf7, 0x95, 0xef, 0xfc, 0x5c, 0xf9, 0xce, 0xaf,
	0x95, 0xef, 0x7c, 0xfb, 0xed, 0xef, 0x7c, 0x7c, 0x35, 0xd7, 0xe6, 0x66, 0x79, 0x3d, 0x90, 0x10,
	0x0e, 0xcf, 0x84, 0x11, 0x67, 0x30, 0xb7, 0x8f, 0xfb, 0x75, 0x2c, 0xb2, 0x05, 0x88, 0x60, 0x78,
	0x7b, 0x5c, 0xbc, 0xfa, 0xeb, 0x3a, 0x3e, 0xf8, 0x37, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xda,
	0x20, 0x97, 0xa7, 0x44, 0x04, 0x00, 0x00,
}
