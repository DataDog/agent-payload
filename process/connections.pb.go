// Code generated by protoc-gen-gogo.
// source: proto/process/connections.proto
// DO NOT EDIT!

package process

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type RuntimeCompilationResult int32

const (
	RuntimeCompilationResult_NotAttempted        RuntimeCompilationResult = 0
	RuntimeCompilationResult_CompilationSuccess  RuntimeCompilationResult = 1
	RuntimeCompilationResult_KernelVersionErr    RuntimeCompilationResult = 2
	RuntimeCompilationResult_VerificationError   RuntimeCompilationResult = 3
	RuntimeCompilationResult_OutputDirErr        RuntimeCompilationResult = 4
	RuntimeCompilationResult_OutputFileErr       RuntimeCompilationResult = 5
	RuntimeCompilationResult_NewCompilerErr      RuntimeCompilationResult = 6
	RuntimeCompilationResult_CompilationErr      RuntimeCompilationResult = 7
	RuntimeCompilationResult_ResultReadErr       RuntimeCompilationResult = 8
	RuntimeCompilationResult_HeaderFetchErr      RuntimeCompilationResult = 9
	RuntimeCompilationResult_CompiledOutputFound RuntimeCompilationResult = 10
	RuntimeCompilationResult_InputHashError      RuntimeCompilationResult = 11
)

var RuntimeCompilationResult_name = map[int32]string{
	0:  "NotAttempted",
	1:  "CompilationSuccess",
	2:  "KernelVersionErr",
	3:  "VerificationError",
	4:  "OutputDirErr",
	5:  "OutputFileErr",
	6:  "NewCompilerErr",
	7:  "CompilationErr",
	8:  "ResultReadErr",
	9:  "HeaderFetchErr",
	10: "CompiledOutputFound",
	11: "InputHashError",
}
var RuntimeCompilationResult_value = map[string]int32{
	"NotAttempted":        0,
	"CompilationSuccess":  1,
	"KernelVersionErr":    2,
	"VerificationError":   3,
	"OutputDirErr":        4,
	"OutputFileErr":       5,
	"NewCompilerErr":      6,
	"CompilationErr":      7,
	"ResultReadErr":       8,
	"HeaderFetchErr":      9,
	"CompiledOutputFound": 10,
	"InputHashError":      11,
}

func (x RuntimeCompilationResult) String() string {
	return proto.EnumName(RuntimeCompilationResult_name, int32(x))
}
func (RuntimeCompilationResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorConnections, []int{0}
}

type KernelHeaderFetchResult int32

const (
	KernelHeaderFetchResult_FetchNotAttempted               KernelHeaderFetchResult = 0
	KernelHeaderFetchResult_CustomHeadersFound              KernelHeaderFetchResult = 1
	KernelHeaderFetchResult_DefaultHeadersFound             KernelHeaderFetchResult = 2
	KernelHeaderFetchResult_SysfsHeadersFound               KernelHeaderFetchResult = 3
	KernelHeaderFetchResult_DownloadedHeadersFound          KernelHeaderFetchResult = 4
	KernelHeaderFetchResult_DownloadSuccess                 KernelHeaderFetchResult = 5
	KernelHeaderFetchResult_HostVersionErr                  KernelHeaderFetchResult = 6
	KernelHeaderFetchResult_DownloadFailure                 KernelHeaderFetchResult = 7
	KernelHeaderFetchResult_ValidationFailure               KernelHeaderFetchResult = 8
	KernelHeaderFetchResult_ReposDirAccessFailure           KernelHeaderFetchResult = 9
	KernelHeaderFetchResult_HeadersNotFoundDownloadDisabled KernelHeaderFetchResult = 10
)

var KernelHeaderFetchResult_name = map[int32]string{
	0:  "FetchNotAttempted",
	1:  "CustomHeadersFound",
	2:  "DefaultHeadersFound",
	3:  "SysfsHeadersFound",
	4:  "DownloadedHeadersFound",
	5:  "DownloadSuccess",
	6:  "HostVersionErr",
	7:  "DownloadFailure",
	8:  "ValidationFailure",
	9:  "ReposDirAccessFailure",
	10: "HeadersNotFoundDownloadDisabled",
}
var KernelHeaderFetchResult_value = map[string]int32{
	"FetchNotAttempted":               0,
	"CustomHeadersFound":              1,
	"DefaultHeadersFound":             2,
	"SysfsHeadersFound":               3,
	"DownloadedHeadersFound":          4,
	"DownloadSuccess":                 5,
	"HostVersionErr":                  6,
	"DownloadFailure":                 7,
	"ValidationFailure":               8,
	"ReposDirAccessFailure":           9,
	"HeadersNotFoundDownloadDisabled": 10,
}

func (x KernelHeaderFetchResult) String() string {
	return proto.EnumName(KernelHeaderFetchResult_name, int32(x))
}
func (KernelHeaderFetchResult) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorConnections, []int{1}
}

type COREResult int32

const (
	COREResult_SuccessCustomBTF   COREResult = 0
	COREResult_SuccessEmbeddedBTF COREResult = 1
	COREResult_SuccessDefaultBTF  COREResult = 2
	COREResult_BtfNotFound        COREResult = 3
	COREResult_AssetReadError     COREResult = 4
	COREResult_VerifierError      COREResult = 5
	COREResult_LoaderError        COREResult = 6
)

var COREResult_name = map[int32]string{
	0: "SuccessCustomBTF",
	1: "SuccessEmbeddedBTF",
	2: "SuccessDefaultBTF",
	3: "BtfNotFound",
	4: "AssetReadError",
	5: "VerifierError",
	6: "LoaderError",
}
var COREResult_value = map[string]int32{
	"SuccessCustomBTF":   0,
	"SuccessEmbeddedBTF": 1,
	"SuccessDefaultBTF":  2,
	"BtfNotFound":        3,
	"AssetReadError":     4,
	"VerifierError":      5,
	"LoaderError":        6,
}

func (x COREResult) String() string {
	return proto.EnumName(COREResult_name, int32(x))
}
func (COREResult) EnumDescriptor() ([]byte, []int) { return fileDescriptorConnections, []int{2} }

type ConnectionFamily int32

const (
	ConnectionFamily_v4 ConnectionFamily = 0
	ConnectionFamily_v6 ConnectionFamily = 1
)

var ConnectionFamily_name = map[int32]string{
	0: "v4",
	1: "v6",
}
var ConnectionFamily_value = map[string]int32{
	"v4": 0,
	"v6": 1,
}

func (x ConnectionFamily) String() string {
	return proto.EnumName(ConnectionFamily_name, int32(x))
}
func (ConnectionFamily) EnumDescriptor() ([]byte, []int) { return fileDescriptorConnections, []int{3} }

type ConnectionDirection int32

const (
	ConnectionDirection_unspecified ConnectionDirection = 0
	ConnectionDirection_incoming    ConnectionDirection = 1
	ConnectionDirection_outgoing    ConnectionDirection = 2
	ConnectionDirection_local       ConnectionDirection = 3
	ConnectionDirection_none        ConnectionDirection = 4
)

var ConnectionDirection_name = map[int32]string{
	0: "unspecified",
	1: "incoming",
	2: "outgoing",
	3: "local",
	4: "none",
}
var ConnectionDirection_value = map[string]int32{
	"unspecified": 0,
	"incoming":    1,
	"outgoing":    2,
	"local":       3,
	"none":        4,
}

func (x ConnectionDirection) String() string {
	return proto.EnumName(ConnectionDirection_name, int32(x))
}
func (ConnectionDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorConnections, []int{4}
}

type EphemeralPortState int32

const (
	EphemeralPortState_ephemeralUnspecified EphemeralPortState = 0
	EphemeralPortState_ephemeralTrue        EphemeralPortState = 1
	EphemeralPortState_ephemeralFalse       EphemeralPortState = 2
)

var EphemeralPortState_name = map[int32]string{
	0: "ephemeralUnspecified",
	1: "ephemeralTrue",
	2: "ephemeralFalse",
}
var EphemeralPortState_value = map[string]int32{
	"ephemeralUnspecified": 0,
	"ephemeralTrue":        1,
	"ephemeralFalse":       2,
}

func (x EphemeralPortState) String() string {
	return proto.EnumName(EphemeralPortState_name, int32(x))
}
func (EphemeralPortState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorConnections, []int{5}
}

type ProtocolType int32

const (
	ProtocolType_protocolUnclassified ProtocolType = 0
	ProtocolType_protocolUnknown      ProtocolType = 1
	ProtocolType_protocolHTTP         ProtocolType = 2
	ProtocolType_protocolHTTP2        ProtocolType = 3
	ProtocolType_protocolTLS          ProtocolType = 4
	ProtocolType_protocolKafka        ProtocolType = 5
	ProtocolType_protocolMongo        ProtocolType = 6
	ProtocolType_protocolPostgres     ProtocolType = 7
	ProtocolType_protocolAMQP         ProtocolType = 8
	ProtocolType_protocolRedis        ProtocolType = 9
	ProtocolType_protocolMySQL        ProtocolType = 10
)

var ProtocolType_name = map[int32]string{
	0:  "protocolUnclassified",
	1:  "protocolUnknown",
	2:  "protocolHTTP",
	3:  "protocolHTTP2",
	4:  "protocolTLS",
	5:  "protocolKafka",
	6:  "protocolMongo",
	7:  "protocolPostgres",
	8:  "protocolAMQP",
	9:  "protocolRedis",
	10: "protocolMySQL",
}
var ProtocolType_value = map[string]int32{
	"protocolUnclassified": 0,
	"protocolUnknown":      1,
	"protocolHTTP":         2,
	"protocolHTTP2":        3,
	"protocolTLS":          4,
	"protocolKafka":        5,
	"protocolMongo":        6,
	"protocolPostgres":     7,
	"protocolAMQP":         8,
	"protocolRedis":        9,
	"protocolMySQL":        10,
}

func (x ProtocolType) String() string {
	return proto.EnumName(ProtocolType_name, int32(x))
}
func (ProtocolType) EnumDescriptor() ([]byte, []int) { return fileDescriptorConnections, []int{6} }

type CollectorConnections struct {
	HostName    string        `protobuf:"bytes,2,opt,name=hostName,proto3" json:"hostName,omitempty"`
	NetworkId   string        `protobuf:"bytes,12,opt,name=networkId,proto3" json:"networkId,omitempty"`
	Connections []*Connection `protobuf:"bytes,3,rep,name=connections" json:"connections,omitempty"`
	// Message batching metadata
	GroupId   int32 `protobuf:"varint,5,opt,name=groupId,proto3" json:"groupId,omitempty"`
	GroupSize int32 `protobuf:"varint,6,opt,name=groupSize,proto3" json:"groupSize,omitempty"`
	// Mapping of resourceID to metadata. For containers, each `connection` has a containerId field which can be mapped here.
	ResolvedResources map[string]*ResourceMetadata `protobuf:"bytes,8,rep,name=resolvedResources" json:"resolvedResources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Mapping of processes running in each container
	ContainerForPid map[int32]string `protobuf:"bytes,10,rep,name=containerForPid" json:"containerForPid,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// encoded bytes here are use to store a tags []string
	// the tags encoder is more space efficient than protobuf
	EncodedTags []byte `protobuf:"bytes,11,opt,name=encodedTags,proto3" json:"encodedTags,omitempty"`
	// All tags indexed by Connection.tags
	EncodedConnectionsTags []byte            `protobuf:"bytes,38,opt,name=encodedConnectionsTags,proto3" json:"encodedConnectionsTags,omitempty"`
	ContainerHostType      ContainerHostType `protobuf:"varint,15,opt,name=containerHostType,proto3,enum=datadog.process_agent.ContainerHostType" json:"containerHostType,omitempty"`
	// For now, we'll keep emitting telemetry from agents < 7.35
	ConnTelemetry    *CollectorConnectionsTelemetry `protobuf:"bytes,16,opt,name=connTelemetry" json:"connTelemetry,omitempty"`
	ConnTelemetryMap map[string]int64               `protobuf:"bytes,39,rep,name=connTelemetryMap" json:"connTelemetryMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// OS Telemetry
	Architecture    string `protobuf:"bytes,17,opt,name=architecture,proto3" json:"architecture,omitempty"`
	KernelVersion   string `protobuf:"bytes,18,opt,name=kernelVersion,proto3" json:"kernelVersion,omitempty"`
	Platform        string `protobuf:"bytes,19,opt,name=platform,proto3" json:"platform,omitempty"`
	PlatformVersion string `protobuf:"bytes,20,opt,name=platformVersion,proto3" json:"platformVersion,omitempty"`
	// Runtime compilation telemetry
	CompilationTelemetryByAsset map[string]*RuntimeCompilationTelemetry `protobuf:"bytes,21,rep,name=compilationTelemetryByAsset" json:"compilationTelemetryByAsset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	KernelHeaderFetchResult     KernelHeaderFetchResult                 `protobuf:"varint,41,opt,name=kernelHeaderFetchResult,proto3,enum=datadog.process_agent.KernelHeaderFetchResult" json:"kernelHeaderFetchResult,omitempty"`
	// CO-RE telemetry
	CORETelemetryByAsset map[string]COREResult `protobuf:"bytes,42,rep,name=CORETelemetryByAsset" json:"CORETelemetryByAsset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=datadog.process_agent.COREResult"`
	// Prebuilt EBPF assets in use
	PrebuiltEBPFAssets []string            `protobuf:"bytes,44,rep,name=PrebuiltEBPFAssets" json:"PrebuiltEBPFAssets,omitempty"`
	Routes             []*Route            `protobuf:"bytes,31,rep,name=routes" json:"routes,omitempty"`
	RouteMetadata      []*RouteMetadata    `protobuf:"bytes,34,rep,name=routeMetadata" json:"routeMetadata,omitempty"`
	AgentConfiguration *AgentConfiguration `protobuf:"bytes,35,opt,name=agentConfiguration" json:"agentConfiguration,omitempty"`
	// encoded dns is a map of (string) ip-> list of domains (DNSEntry)
	EncodedDNS []byte `protobuf:"bytes,14,opt,name=encodedDNS,proto3" json:"encodedDNS,omitempty"`
	// All queried DNS domains for which we have collected stats
	Domains []string `protobuf:"bytes,30,rep,name=domains" json:"domains,omitempty"`
	// ////////////////
	// V2 encodings
	// all domain strings are now indexes into a single array of strings
	// hostname query information.  Encoded via V2DNSEncoder.EncodeDomainDatabase
	// is a single buffer; varint number of strings, followed by each string.
	EncodedDomainDatabase []byte `protobuf:"bytes,36,opt,name=encodedDomainDatabase,proto3" json:"encodedDomainDatabase,omitempty"`
	// new representation of encoded DNS.  This is a map of the string representation
	// of the IP --> DNSDatabaseEntry message. (was encodedDNS).  Encoded
	// via V2DNSEncoder.EncodeMapped.  Full buffer description provided there.
	EncodedDnsLookups   []byte           `protobuf:"bytes,37,opt,name=encodedDnsLookups,proto3" json:"encodedDnsLookups,omitempty"`
	ResolvedHostsByName map[string]*Host `protobuf:"bytes,40,rep,name=resolvedHostsByName" json:"resolvedHostsByName,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CollectorConnections) Reset()                    { *m = CollectorConnections{} }
func (m *CollectorConnections) String() string            { return proto.CompactTextString(m) }
func (*CollectorConnections) ProtoMessage()               {}
func (*CollectorConnections) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{0} }

func (m *CollectorConnections) GetConnections() []*Connection {
	if m != nil {
		return m.Connections
	}
	return nil
}

func (m *CollectorConnections) GetResolvedResources() map[string]*ResourceMetadata {
	if m != nil {
		return m.ResolvedResources
	}
	return nil
}

func (m *CollectorConnections) GetContainerForPid() map[int32]string {
	if m != nil {
		return m.ContainerForPid
	}
	return nil
}

func (m *CollectorConnections) GetConnTelemetry() *CollectorConnectionsTelemetry {
	if m != nil {
		return m.ConnTelemetry
	}
	return nil
}

func (m *CollectorConnections) GetConnTelemetryMap() map[string]int64 {
	if m != nil {
		return m.ConnTelemetryMap
	}
	return nil
}

func (m *CollectorConnections) GetCompilationTelemetryByAsset() map[string]*RuntimeCompilationTelemetry {
	if m != nil {
		return m.CompilationTelemetryByAsset
	}
	return nil
}

func (m *CollectorConnections) GetCORETelemetryByAsset() map[string]COREResult {
	if m != nil {
		return m.CORETelemetryByAsset
	}
	return nil
}

func (m *CollectorConnections) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *CollectorConnections) GetRouteMetadata() []*RouteMetadata {
	if m != nil {
		return m.RouteMetadata
	}
	return nil
}

func (m *CollectorConnections) GetAgentConfiguration() *AgentConfiguration {
	if m != nil {
		return m.AgentConfiguration
	}
	return nil
}

func (m *CollectorConnections) GetResolvedHostsByName() map[string]*Host {
	if m != nil {
		return m.ResolvedHostsByName
	}
	return nil
}

// please update process/connections.go Aggregate() if you add a field
type Connections struct {
	Conns []*Connection        `protobuf:"bytes,1,rep,name=conns" json:"conns,omitempty"`
	Dns   map[string]*DNSEntry `protobuf:"bytes,2,rep,name=dns" json:"dns,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// For now, we'll keep emitting telemetry from agents < 7.35
	ConnTelemetry               *ConnectionsTelemetry                   `protobuf:"bytes,3,opt,name=connTelemetry" json:"connTelemetry,omitempty"`
	Domains                     []string                                `protobuf:"bytes,4,rep,name=domains" json:"domains,omitempty"`
	Routes                      []*Route                                `protobuf:"bytes,5,rep,name=routes" json:"routes,omitempty"`
	CompilationTelemetryByAsset map[string]*RuntimeCompilationTelemetry `protobuf:"bytes,6,rep,name=compilationTelemetryByAsset" json:"compilationTelemetryByAsset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	AgentConfiguration          *AgentConfiguration                     `protobuf:"bytes,7,opt,name=agentConfiguration" json:"agentConfiguration,omitempty"`
	Tags                        []string                                `protobuf:"bytes,8,rep,name=tags" json:"tags,omitempty"`
	ConnTelemetryMap            map[string]int64                        `protobuf:"bytes,9,rep,name=connTelemetryMap" json:"connTelemetryMap,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	KernelHeaderFetchResult     KernelHeaderFetchResult                 `protobuf:"varint,10,opt,name=kernelHeaderFetchResult,proto3,enum=datadog.process_agent.KernelHeaderFetchResult" json:"kernelHeaderFetchResult,omitempty"`
	CORETelemetryByAsset        map[string]COREResult                   `protobuf:"bytes,11,rep,name=CORETelemetryByAsset" json:"CORETelemetryByAsset,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=datadog.process_agent.COREResult"`
	PrebuiltEBPFAssets          []string                                `protobuf:"bytes,12,rep,name=PrebuiltEBPFAssets" json:"PrebuiltEBPFAssets,omitempty"`
}

func (m *Connections) Reset()                    { *m = Connections{} }
func (m *Connections) String() string            { return proto.CompactTextString(m) }
func (*Connections) ProtoMessage()               {}
func (*Connections) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{1} }

func (m *Connections) GetConns() []*Connection {
	if m != nil {
		return m.Conns
	}
	return nil
}

func (m *Connections) GetDns() map[string]*DNSEntry {
	if m != nil {
		return m.Dns
	}
	return nil
}

func (m *Connections) GetConnTelemetry() *ConnectionsTelemetry {
	if m != nil {
		return m.ConnTelemetry
	}
	return nil
}

func (m *Connections) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *Connections) GetCompilationTelemetryByAsset() map[string]*RuntimeCompilationTelemetry {
	if m != nil {
		return m.CompilationTelemetryByAsset
	}
	return nil
}

func (m *Connections) GetAgentConfiguration() *AgentConfiguration {
	if m != nil {
		return m.AgentConfiguration
	}
	return nil
}

func (m *Connections) GetConnTelemetryMap() map[string]int64 {
	if m != nil {
		return m.ConnTelemetryMap
	}
	return nil
}

func (m *Connections) GetCORETelemetryByAsset() map[string]COREResult {
	if m != nil {
		return m.CORETelemetryByAsset
	}
	return nil
}

type Connection struct {
	Pid                  int32              `protobuf:"varint,1,opt,name=pid,proto3" json:"pid,omitempty"`
	Laddr                *Addr              `protobuf:"bytes,5,opt,name=laddr" json:"laddr,omitempty"`
	Raddr                *Addr              `protobuf:"bytes,6,opt,name=raddr" json:"raddr,omitempty"`
	Family               ConnectionFamily   `protobuf:"varint,10,opt,name=family,proto3,enum=datadog.process_agent.ConnectionFamily" json:"family,omitempty"`
	Type                 ConnectionType     `protobuf:"varint,11,opt,name=type,proto3,enum=datadog.process_agent.ConnectionType" json:"type,omitempty"`
	IsLocalPortEphemeral EphemeralPortState `protobuf:"varint,41,opt,name=isLocalPortEphemeral,proto3,enum=datadog.process_agent.EphemeralPortState" json:"isLocalPortEphemeral,omitempty"`
	// Relative counters since last check
	LastBytesSent       uint64              `protobuf:"varint,16,opt,name=lastBytesSent,proto3" json:"lastBytesSent,omitempty"`
	LastBytesReceived   uint64              `protobuf:"varint,17,opt,name=lastBytesReceived,proto3" json:"lastBytesReceived,omitempty"`
	LastRetransmits     uint32              `protobuf:"varint,18,opt,name=lastRetransmits,proto3" json:"lastRetransmits,omitempty"`
	Direction           ConnectionDirection `protobuf:"varint,19,opt,name=direction,proto3,enum=datadog.process_agent.ConnectionDirection" json:"direction,omitempty"`
	LastPacketsSent     uint64              `protobuf:"varint,38,opt,name=lastPacketsSent,proto3" json:"lastPacketsSent,omitempty"`
	LastPacketsReceived uint64              `protobuf:"varint,39,opt,name=lastPacketsReceived,proto3" json:"lastPacketsReceived,omitempty"`
	Protocol            *ProtocolStack      `protobuf:"bytes,48,opt,name=protocol" json:"protocol,omitempty"`
	// Network namespace
	NetNS uint32 `protobuf:"varint,20,opt,name=netNS,proto3" json:"netNS,omitempty"`
	// NetworkID of the remote address (post-resolution field)
	RemoteNetworkId string `protobuf:"bytes,32,opt,name=remoteNetworkId,proto3" json:"remoteNetworkId,omitempty"`
	// the conntrack entry associated with the connection. May be null on systems which don't support querying conntrack.
	IpTranslation *IPTranslation `protobuf:"bytes,21,opt,name=ipTranslation" json:"ipTranslation,omitempty"`
	// TCP-specific metrics
	Rtt    uint32 `protobuf:"varint,22,opt,name=rtt,proto3" json:"rtt,omitempty"`
	RttVar uint32 `protobuf:"varint,23,opt,name=rttVar,proto3" json:"rttVar,omitempty"`
	// Indicates that this connection begins and ends on the same host
	IntraHost bool `protobuf:"varint,24,opt,name=intraHost,proto3" json:"intraHost,omitempty"`
	// DNS-specific metrics
	DnsSuccessfulResponses uint32            `protobuf:"varint,25,opt,name=dnsSuccessfulResponses,proto3" json:"dnsSuccessfulResponses,omitempty"`
	DnsFailedResponses     uint32            `protobuf:"varint,26,opt,name=dnsFailedResponses,proto3" json:"dnsFailedResponses,omitempty"`
	DnsTimeouts            uint32            `protobuf:"varint,27,opt,name=dnsTimeouts,proto3" json:"dnsTimeouts,omitempty"`
	DnsSuccessLatencySum   uint64            `protobuf:"varint,28,opt,name=dnsSuccessLatencySum,proto3" json:"dnsSuccessLatencySum,omitempty"`
	DnsFailureLatencySum   uint64            `protobuf:"varint,29,opt,name=dnsFailureLatencySum,proto3" json:"dnsFailureLatencySum,omitempty"`
	DnsCountByRcode        map[uint32]uint32 `protobuf:"bytes,33,rep,name=dnsCountByRcode" json:"dnsCountByRcode,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// TCP state transition counters relative to last check
	LastTcpEstablished uint32 `protobuf:"varint,30,opt,name=lastTcpEstablished,proto3" json:"lastTcpEstablished,omitempty"`
	LastTcpClosed      uint32 `protobuf:"varint,31,opt,name=lastTcpClosed,proto3" json:"lastTcpClosed,omitempty"`
	// dns stats based on domain queried, the key corresponds to an index into the `domains` field
	// dnsStatsByDomain is deprecated field, left in for handling old agent versions
	DnsStatsByDomain map[int32]*DNSStats `protobuf:"bytes,34,rep,name=dnsStatsByDomain" json:"dnsStatsByDomain,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// dnsStatsByDomainByQueryType is new field
	DnsStatsByDomainByQueryType map[int32]*DNSStatsByQueryType `protobuf:"bytes,42,rep,name=dnsStatsByDomainByQueryType" json:"dnsStatsByDomainByQueryType,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// int32 index into map is the offset into the CollectorConnections.encodedDomainDatabase
	DnsStatsByDomainOffsetByQueryType map[int32]*DNSStatsByQueryType `protobuf:"bytes,43,rep,name=dnsStatsByDomainOffsetByQueryType" json:"dnsStatsByDomainOffsetByQueryType,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	RouteIdx                          int32                          `protobuf:"varint,36,opt,name=routeIdx,proto3" json:"routeIdx,omitempty"`
	// the index of the resolved target of the route (post-resolution field)
	RouteTargetIdx int32 `protobuf:"varint,40,opt,name=routeTargetIdx,proto3" json:"routeTargetIdx,omitempty"`
	// serialized HTTPAggregations object summarizing all http transactions recorded for this connection, organized by request path
	HttpAggregations []byte `protobuf:"bytes,37,opt,name=httpAggregations,proto3" json:"httpAggregations,omitempty"`
	// The stored values corresponds to an index into the `Connections.tags` field
	Tags []uint32 `protobuf:"varint,44,rep,name=tags" json:"tags,omitempty"`
	// the tags index of encodedConnectionsTags (from process.tagsV2.Encode())
	TagsIdx int32 `protobuf:"varint,45,opt,name=tagsIdx,proto3" json:"tagsIdx,omitempty"`
	// a checksum of all the tags in this connection. Populated by the agent, but used by the backend to know when tags have changed for a connection.
	TagsChecksum uint32 `protobuf:"varint,47,opt,name=tagsChecksum,proto3" json:"tagsChecksum,omitempty"`
	// Used for offset state management (backend)
	StateIndex uint32 `protobuf:"varint,46,opt,name=stateIndex,proto3" json:"stateIndex,omitempty"`
	// serialized DataStreamsAggregations object summarizing all data streams transactions (Kafka produce & Kafka fetch) recorded for this connection organized by topic
	DataStreamsAggregations []byte `protobuf:"bytes,49,opt,name=dataStreamsAggregations,proto3" json:"dataStreamsAggregations,omitempty"`
	// serialized HTTP2Aggregations object summarizing all http2 transactions recorded for this connection, organized by request path
	Http2Aggregations []byte `protobuf:"bytes,50,opt,name=http2Aggregations,proto3" json:"http2Aggregations,omitempty"`
}

func (m *Connection) Reset()                    { *m = Connection{} }
func (m *Connection) String() string            { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()               {}
func (*Connection) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{2} }

func (m *Connection) GetLaddr() *Addr {
	if m != nil {
		return m.Laddr
	}
	return nil
}

func (m *Connection) GetRaddr() *Addr {
	if m != nil {
		return m.Raddr
	}
	return nil
}

func (m *Connection) GetProtocol() *ProtocolStack {
	if m != nil {
		return m.Protocol
	}
	return nil
}

func (m *Connection) GetIpTranslation() *IPTranslation {
	if m != nil {
		return m.IpTranslation
	}
	return nil
}

func (m *Connection) GetDnsCountByRcode() map[uint32]uint32 {
	if m != nil {
		return m.DnsCountByRcode
	}
	return nil
}

func (m *Connection) GetDnsStatsByDomain() map[int32]*DNSStats {
	if m != nil {
		return m.DnsStatsByDomain
	}
	return nil
}

func (m *Connection) GetDnsStatsByDomainByQueryType() map[int32]*DNSStatsByQueryType {
	if m != nil {
		return m.DnsStatsByDomainByQueryType
	}
	return nil
}

func (m *Connection) GetDnsStatsByDomainOffsetByQueryType() map[int32]*DNSStatsByQueryType {
	if m != nil {
		return m.DnsStatsByDomainOffsetByQueryType
	}
	return nil
}

// ResourceMetadata only holds enough information to identify a resource in connection data
type ResourceMetadata struct {
	Id           string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Key          uint32   `protobuf:"varint,2,opt,name=key,proto3" json:"key,omitempty"`
	ByteKey      []byte   `protobuf:"bytes,3,opt,name=byteKey,proto3" json:"byteKey,omitempty"`
	Tags         []string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
	TagIndex     int32    `protobuf:"varint,5,opt,name=tagIndex,proto3" json:"tagIndex,omitempty"`
	TagsModified int64    `protobuf:"varint,6,opt,name=tagsModified,proto3" json:"tagsModified,omitempty"`
}

func (m *ResourceMetadata) Reset()                    { *m = ResourceMetadata{} }
func (m *ResourceMetadata) String() string            { return proto.CompactTextString(m) }
func (*ResourceMetadata) ProtoMessage()               {}
func (*ResourceMetadata) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{3} }

// please update process/connections.go Aggregate() if you add a field
type ConnectionsTelemetry struct {
	MonotonicKprobesTriggered          int64 `protobuf:"varint,1,opt,name=monotonicKprobesTriggered,proto3" json:"monotonicKprobesTriggered,omitempty"`
	MonotonicKprobesMissed             int64 `protobuf:"varint,2,opt,name=monotonicKprobesMissed,proto3" json:"monotonicKprobesMissed,omitempty"`
	MonotonicConntrackRegisters        int64 `protobuf:"varint,3,opt,name=monotonicConntrackRegisters,proto3" json:"monotonicConntrackRegisters,omitempty"`
	MonotonicConntrackRegistersDropped int64 `protobuf:"varint,4,opt,name=monotonicConntrackRegistersDropped,proto3" json:"monotonicConntrackRegistersDropped,omitempty"`
	MonotonicDnsPacketsProcessed       int64 `protobuf:"varint,5,opt,name=monotonicDnsPacketsProcessed,proto3" json:"monotonicDnsPacketsProcessed,omitempty"`
	MonotonicConnsClosed               int64 `protobuf:"varint,6,opt,name=monotonicConnsClosed,proto3" json:"monotonicConnsClosed,omitempty"`
	ConnsBpfMapSize                    int64 `protobuf:"varint,7,opt,name=connsBpfMapSize,proto3" json:"connsBpfMapSize,omitempty"`
	MonotonicUdpSendsProcessed         int64 `protobuf:"varint,8,opt,name=monotonicUdpSendsProcessed,proto3" json:"monotonicUdpSendsProcessed,omitempty"`
	MonotonicUdpSendsMissed            int64 `protobuf:"varint,9,opt,name=monotonicUdpSendsMissed,proto3" json:"monotonicUdpSendsMissed,omitempty"`
	ConntrackSamplingPercent           int64 `protobuf:"varint,10,opt,name=conntrackSamplingPercent,proto3" json:"conntrackSamplingPercent,omitempty"`
	DnsStatsDropped                    int64 `protobuf:"varint,11,opt,name=dnsStatsDropped,proto3" json:"dnsStatsDropped,omitempty"`
}

func (m *ConnectionsTelemetry) Reset()                    { *m = ConnectionsTelemetry{} }
func (m *ConnectionsTelemetry) String() string            { return proto.CompactTextString(m) }
func (*ConnectionsTelemetry) ProtoMessage()               {}
func (*ConnectionsTelemetry) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{4} }

type CollectorConnectionsTelemetry struct {
	KprobesTriggered          int64 `protobuf:"varint,1,opt,name=kprobesTriggered,proto3" json:"kprobesTriggered,omitempty"`
	KprobesMissed             int64 `protobuf:"varint,2,opt,name=kprobesMissed,proto3" json:"kprobesMissed,omitempty"`
	ConntrackRegisters        int64 `protobuf:"varint,3,opt,name=conntrackRegisters,proto3" json:"conntrackRegisters,omitempty"`
	ConntrackRegistersDropped int64 `protobuf:"varint,4,opt,name=conntrackRegistersDropped,proto3" json:"conntrackRegistersDropped,omitempty"`
	DnsPacketsProcessed       int64 `protobuf:"varint,5,opt,name=dnsPacketsProcessed,proto3" json:"dnsPacketsProcessed,omitempty"`
	ConnsClosed               int64 `protobuf:"varint,6,opt,name=connsClosed,proto3" json:"connsClosed,omitempty"`
	ConnsBpfMapSize           int64 `protobuf:"varint,7,opt,name=connsBpfMapSize,proto3" json:"connsBpfMapSize,omitempty"`
	UdpSendsProcessed         int64 `protobuf:"varint,8,opt,name=udpSendsProcessed,proto3" json:"udpSendsProcessed,omitempty"`
	UdpSendsMissed            int64 `protobuf:"varint,9,opt,name=udpSendsMissed,proto3" json:"udpSendsMissed,omitempty"`
	ConntrackSamplingPercent  int64 `protobuf:"varint,10,opt,name=conntrackSamplingPercent,proto3" json:"conntrackSamplingPercent,omitempty"`
	DnsStatsDropped           int64 `protobuf:"varint,11,opt,name=dnsStatsDropped,proto3" json:"dnsStatsDropped,omitempty"`
}

func (m *CollectorConnectionsTelemetry) Reset()         { *m = CollectorConnectionsTelemetry{} }
func (m *CollectorConnectionsTelemetry) String() string { return proto.CompactTextString(m) }
func (*CollectorConnectionsTelemetry) ProtoMessage()    {}
func (*CollectorConnectionsTelemetry) Descriptor() ([]byte, []int) {
	return fileDescriptorConnections, []int{5}
}

type RuntimeCompilationTelemetry struct {
	RuntimeCompilationEnabled  bool                     `protobuf:"varint,1,opt,name=runtimeCompilationEnabled,proto3" json:"runtimeCompilationEnabled,omitempty"`
	RuntimeCompilationResult   RuntimeCompilationResult `protobuf:"varint,2,opt,name=runtimeCompilationResult,proto3,enum=datadog.process_agent.RuntimeCompilationResult" json:"runtimeCompilationResult,omitempty"`
	RuntimeCompilationDuration int64                    `protobuf:"varint,3,opt,name=runtimeCompilationDuration,proto3" json:"runtimeCompilationDuration,omitempty"`
	// Field below was deprecated in agent 7.41
	KernelHeaderFetchResult KernelHeaderFetchResult `protobuf:"varint,4,opt,name=kernelHeaderFetchResult,proto3,enum=datadog.process_agent.KernelHeaderFetchResult" json:"kernelHeaderFetchResult,omitempty"`
}

func (m *RuntimeCompilationTelemetry) Reset()         { *m = RuntimeCompilationTelemetry{} }
func (m *RuntimeCompilationTelemetry) String() string { return proto.CompactTextString(m) }
func (*RuntimeCompilationTelemetry) ProtoMessage()    {}
func (*RuntimeCompilationTelemetry) Descriptor() ([]byte, []int) {
	return fileDescriptorConnections, []int{6}
}

type AgentConfiguration struct {
	NpmEnabled bool `protobuf:"varint,1,opt,name=npmEnabled,proto3" json:"npmEnabled,omitempty"`
	UsmEnabled bool `protobuf:"varint,2,opt,name=usmEnabled,proto3" json:"usmEnabled,omitempty"`
	DsmEnabled bool `protobuf:"varint,3,opt,name=dsmEnabled,proto3" json:"dsmEnabled,omitempty"`
}

func (m *AgentConfiguration) Reset()                    { *m = AgentConfiguration{} }
func (m *AgentConfiguration) String() string            { return proto.CompactTextString(m) }
func (*AgentConfiguration) ProtoMessage()               {}
func (*AgentConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{7} }

type Route struct {
	Subnet *Subnet `protobuf:"bytes,1,opt,name=subnet" json:"subnet,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{8} }

func (m *Route) GetSubnet() *Subnet {
	if m != nil {
		return m.Subnet
	}
	return nil
}

type Subnet struct {
	Alias string `protobuf:"bytes,1,opt,name=alias,proto3" json:"alias,omitempty"`
}

func (m *Subnet) Reset()                    { *m = Subnet{} }
func (m *Subnet) String() string            { return proto.CompactTextString(m) }
func (*Subnet) ProtoMessage()               {}
func (*Subnet) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{9} }

type RouteMetadata struct {
	Alias        string   `protobuf:"bytes,1,opt,name=alias,proto3" json:"alias,omitempty"`
	TagIndex     int32    `protobuf:"varint,2,opt,name=tagIndex,proto3" json:"tagIndex,omitempty"`
	TagsModified int64    `protobuf:"varint,3,opt,name=tagsModified,proto3" json:"tagsModified,omitempty"`
	Tags         []string `protobuf:"bytes,4,rep,name=tags" json:"tags,omitempty"`
}

func (m *RouteMetadata) Reset()                    { *m = RouteMetadata{} }
func (m *RouteMetadata) String() string            { return proto.CompactTextString(m) }
func (*RouteMetadata) ProtoMessage()               {}
func (*RouteMetadata) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{10} }

type IPTranslation struct {
	ReplSrcIP   string `protobuf:"bytes,1,opt,name=replSrcIP,proto3" json:"replSrcIP,omitempty"`
	ReplDstIP   string `protobuf:"bytes,2,opt,name=replDstIP,proto3" json:"replDstIP,omitempty"`
	ReplSrcPort int32  `protobuf:"varint,3,opt,name=replSrcPort,proto3" json:"replSrcPort,omitempty"`
	ReplDstPort int32  `protobuf:"varint,4,opt,name=replDstPort,proto3" json:"replDstPort,omitempty"`
}

func (m *IPTranslation) Reset()                    { *m = IPTranslation{} }
func (m *IPTranslation) String() string            { return proto.CompactTextString(m) }
func (*IPTranslation) ProtoMessage()               {}
func (*IPTranslation) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{11} }

type Addr struct {
	Ip          string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Port        int32  `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	ContainerId string `protobuf:"bytes,5,opt,name=containerId,proto3" json:"containerId,omitempty"`
	HostName    string `protobuf:"bytes,7,opt,name=hostName,proto3" json:"hostName,omitempty"`
}

func (m *Addr) Reset()                    { *m = Addr{} }
func (m *Addr) String() string            { return proto.CompactTextString(m) }
func (*Addr) ProtoMessage()               {}
func (*Addr) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{12} }

type ProtocolStack struct {
	Stack []ProtocolType `protobuf:"varint,1,rep,name=stack,enum=datadog.process_agent.ProtocolType" json:"stack,omitempty"`
}

func (m *ProtocolStack) Reset()                    { *m = ProtocolStack{} }
func (m *ProtocolStack) String() string            { return proto.CompactTextString(m) }
func (*ProtocolStack) ProtoMessage()               {}
func (*ProtocolStack) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{13} }

type DNSEntry struct {
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *DNSEntry) Reset()                    { *m = DNSEntry{} }
func (m *DNSEntry) String() string            { return proto.CompactTextString(m) }
func (*DNSEntry) ProtoMessage()               {}
func (*DNSEntry) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{14} }

type DNSStats struct {
	DnsTimeouts          uint32            `protobuf:"varint,1,opt,name=dnsTimeouts,proto3" json:"dnsTimeouts,omitempty"`
	DnsSuccessLatencySum uint64            `protobuf:"varint,2,opt,name=dnsSuccessLatencySum,proto3" json:"dnsSuccessLatencySum,omitempty"`
	DnsFailureLatencySum uint64            `protobuf:"varint,3,opt,name=dnsFailureLatencySum,proto3" json:"dnsFailureLatencySum,omitempty"`
	DnsCountByRcode      map[uint32]uint32 `protobuf:"bytes,4,rep,name=dnsCountByRcode" json:"dnsCountByRcode,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *DNSStats) Reset()                    { *m = DNSStats{} }
func (m *DNSStats) String() string            { return proto.CompactTextString(m) }
func (*DNSStats) ProtoMessage()               {}
func (*DNSStats) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{15} }

func (m *DNSStats) GetDnsCountByRcode() map[uint32]uint32 {
	if m != nil {
		return m.DnsCountByRcode
	}
	return nil
}

type DNSStatsByQueryType struct {
	DnsStatsByQueryType map[int32]*DNSStats `protobuf:"bytes,1,rep,name=dnsStatsByQueryType" json:"dnsStatsByQueryType,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DNSStatsByQueryType) Reset()                    { *m = DNSStatsByQueryType{} }
func (m *DNSStatsByQueryType) String() string            { return proto.CompactTextString(m) }
func (*DNSStatsByQueryType) ProtoMessage()               {}
func (*DNSStatsByQueryType) Descriptor() ([]byte, []int) { return fileDescriptorConnections, []int{16} }

func (m *DNSStatsByQueryType) GetDnsStatsByQueryType() map[int32]*DNSStats {
	if m != nil {
		return m.DnsStatsByQueryType
	}
	return nil
}

func init() {
	proto.RegisterType((*CollectorConnections)(nil), "datadog.process_agent.CollectorConnections")
	proto.RegisterType((*Connections)(nil), "datadog.process_agent.Connections")
	proto.RegisterType((*Connection)(nil), "datadog.process_agent.Connection")
	proto.RegisterType((*ResourceMetadata)(nil), "datadog.process_agent.ResourceMetadata")
	proto.RegisterType((*ConnectionsTelemetry)(nil), "datadog.process_agent.ConnectionsTelemetry")
	proto.RegisterType((*CollectorConnectionsTelemetry)(nil), "datadog.process_agent.CollectorConnectionsTelemetry")
	proto.RegisterType((*RuntimeCompilationTelemetry)(nil), "datadog.process_agent.RuntimeCompilationTelemetry")
	proto.RegisterType((*AgentConfiguration)(nil), "datadog.process_agent.AgentConfiguration")
	proto.RegisterType((*Route)(nil), "datadog.process_agent.Route")
	proto.RegisterType((*Subnet)(nil), "datadog.process_agent.Subnet")
	proto.RegisterType((*RouteMetadata)(nil), "datadog.process_agent.RouteMetadata")
	proto.RegisterType((*IPTranslation)(nil), "datadog.process_agent.IPTranslation")
	proto.RegisterType((*Addr)(nil), "datadog.process_agent.Addr")
	proto.RegisterType((*ProtocolStack)(nil), "datadog.process_agent.ProtocolStack")
	proto.RegisterType((*DNSEntry)(nil), "datadog.process_agent.DNSEntry")
	proto.RegisterType((*DNSStats)(nil), "datadog.process_agent.DNSStats")
	proto.RegisterType((*DNSStatsByQueryType)(nil), "datadog.process_agent.DNSStatsByQueryType")
	proto.RegisterEnum("datadog.process_agent.RuntimeCompilationResult", RuntimeCompilationResult_name, RuntimeCompilationResult_value)
	proto.RegisterEnum("datadog.process_agent.KernelHeaderFetchResult", KernelHeaderFetchResult_name, KernelHeaderFetchResult_value)
	proto.RegisterEnum("datadog.process_agent.COREResult", COREResult_name, COREResult_value)
	proto.RegisterEnum("datadog.process_agent.ConnectionFamily", ConnectionFamily_name, ConnectionFamily_value)
	proto.RegisterEnum("datadog.process_agent.ConnectionDirection", ConnectionDirection_name, ConnectionDirection_value)
	proto.RegisterEnum("datadog.process_agent.EphemeralPortState", EphemeralPortState_name, EphemeralPortState_value)
	proto.RegisterEnum("datadog.process_agent.ProtocolType", ProtocolType_name, ProtocolType_value)
}
func (m *CollectorConnections) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorConnections) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HostName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	if len(m.Connections) > 0 {
		for _, msg := range m.Connections {
			data[i] = 0x1a
			i++
			i = encodeVarintConnections(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.GroupId != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintConnections(data, i, uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintConnections(data, i, uint64(m.GroupSize))
	}
	if len(m.ResolvedResources) > 0 {
		for k, _ := range m.ResolvedResources {
			data[i] = 0x42
			i++
			v := m.ResolvedResources[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n1, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if len(m.ContainerForPid) > 0 {
		for k, _ := range m.ContainerForPid {
			data[i] = 0x52
			i++
			v := m.ContainerForPid[k]
			mapSize := 1 + sovConnections(uint64(k)) + 1 + len(v) + sovConnections(uint64(len(v)))
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(k))
			data[i] = 0x12
			i++
			i = encodeVarintConnections(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.EncodedTags) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.EncodedTags)))
		i += copy(data[i:], m.EncodedTags)
	}
	if len(m.NetworkId) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.NetworkId)))
		i += copy(data[i:], m.NetworkId)
	}
	if len(m.EncodedDNS) > 0 {
		data[i] = 0x72
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.EncodedDNS)))
		i += copy(data[i:], m.EncodedDNS)
	}
	if m.ContainerHostType != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintConnections(data, i, uint64(m.ContainerHostType))
	}
	if m.ConnTelemetry != nil {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConnTelemetry.Size()))
		n2, err := m.ConnTelemetry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Architecture) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.Architecture)))
		i += copy(data[i:], m.Architecture)
	}
	if len(m.KernelVersion) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.KernelVersion)))
		i += copy(data[i:], m.KernelVersion)
	}
	if len(m.Platform) > 0 {
		data[i] = 0x9a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.Platform)))
		i += copy(data[i:], m.Platform)
	}
	if len(m.PlatformVersion) > 0 {
		data[i] = 0xa2
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.PlatformVersion)))
		i += copy(data[i:], m.PlatformVersion)
	}
	if len(m.CompilationTelemetryByAsset) > 0 {
		for k, _ := range m.CompilationTelemetryByAsset {
			data[i] = 0xaa
			i++
			data[i] = 0x1
			i++
			v := m.CompilationTelemetryByAsset[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n3, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			data[i] = 0xf2
			i++
			data[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			data[i] = 0xfa
			i++
			data[i] = 0x1
			i++
			i = encodeVarintConnections(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RouteMetadata) > 0 {
		for _, msg := range m.RouteMetadata {
			data[i] = 0x92
			i++
			data[i] = 0x2
			i++
			i = encodeVarintConnections(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AgentConfiguration != nil {
		data[i] = 0x9a
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.AgentConfiguration.Size()))
		n4, err := m.AgentConfiguration.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.EncodedDomainDatabase) > 0 {
		data[i] = 0xa2
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.EncodedDomainDatabase)))
		i += copy(data[i:], m.EncodedDomainDatabase)
	}
	if len(m.EncodedDnsLookups) > 0 {
		data[i] = 0xaa
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.EncodedDnsLookups)))
		i += copy(data[i:], m.EncodedDnsLookups)
	}
	if len(m.EncodedConnectionsTags) > 0 {
		data[i] = 0xb2
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.EncodedConnectionsTags)))
		i += copy(data[i:], m.EncodedConnectionsTags)
	}
	if len(m.ConnTelemetryMap) > 0 {
		for k, _ := range m.ConnTelemetryMap {
			data[i] = 0xba
			i++
			data[i] = 0x2
			i++
			v := m.ConnTelemetryMap[k]
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintConnections(data, i, uint64(v))
		}
	}
	if len(m.ResolvedHostsByName) > 0 {
		for k, _ := range m.ResolvedHostsByName {
			data[i] = 0xc2
			i++
			data[i] = 0x2
			i++
			v := m.ResolvedHostsByName[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n5, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if m.KernelHeaderFetchResult != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.KernelHeaderFetchResult))
	}
	if len(m.CORETelemetryByAsset) > 0 {
		for k, _ := range m.CORETelemetryByAsset {
			data[i] = 0xd2
			i++
			data[i] = 0x2
			i++
			v := m.CORETelemetryByAsset[k]
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintConnections(data, i, uint64(v))
		}
	}
	if len(m.PrebuiltEBPFAssets) > 0 {
		for _, s := range m.PrebuiltEBPFAssets {
			data[i] = 0xe2
			i++
			data[i] = 0x2
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Connections) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Connections) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Conns) > 0 {
		for _, msg := range m.Conns {
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Dns) > 0 {
		for k, _ := range m.Dns {
			data[i] = 0x12
			i++
			v := m.Dns[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n6, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n6
			}
		}
	}
	if m.ConnTelemetry != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConnTelemetry.Size()))
		n7, err := m.ConnTelemetry.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Routes) > 0 {
		for _, msg := range m.Routes {
			data[i] = 0x2a
			i++
			i = encodeVarintConnections(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CompilationTelemetryByAsset) > 0 {
		for k, _ := range m.CompilationTelemetryByAsset {
			data[i] = 0x32
			i++
			v := m.CompilationTelemetryByAsset[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n8, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if m.AgentConfiguration != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintConnections(data, i, uint64(m.AgentConfiguration.Size()))
		n9, err := m.AgentConfiguration.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.ConnTelemetryMap) > 0 {
		for k, _ := range m.ConnTelemetryMap {
			data[i] = 0x4a
			i++
			v := m.ConnTelemetryMap[k]
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintConnections(data, i, uint64(v))
		}
	}
	if m.KernelHeaderFetchResult != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintConnections(data, i, uint64(m.KernelHeaderFetchResult))
	}
	if len(m.CORETelemetryByAsset) > 0 {
		for k, _ := range m.CORETelemetryByAsset {
			data[i] = 0x5a
			i++
			v := m.CORETelemetryByAsset[k]
			mapSize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintConnections(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x10
			i++
			i = encodeVarintConnections(data, i, uint64(v))
		}
	}
	if len(m.PrebuiltEBPFAssets) > 0 {
		for _, s := range m.PrebuiltEBPFAssets {
			data[i] = 0x62
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *Connection) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Connection) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Pid != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintConnections(data, i, uint64(m.Pid))
	}
	if m.Laddr != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintConnections(data, i, uint64(m.Laddr.Size()))
		n10, err := m.Laddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Raddr != nil {
		data[i] = 0x32
		i++
		i = encodeVarintConnections(data, i, uint64(m.Raddr.Size()))
		n11, err := m.Raddr.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Family != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintConnections(data, i, uint64(m.Family))
	}
	if m.Type != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintConnections(data, i, uint64(m.Type))
	}
	if m.LastBytesSent != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.LastBytesSent))
	}
	if m.LastBytesReceived != 0 {
		data[i] = 0x88
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.LastBytesReceived))
	}
	if m.LastRetransmits != 0 {
		data[i] = 0x90
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.LastRetransmits))
	}
	if m.Direction != 0 {
		data[i] = 0x98
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.Direction))
	}
	if m.NetNS != 0 {
		data[i] = 0xa0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.NetNS))
	}
	if m.IpTranslation != nil {
		data[i] = 0xaa
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.IpTranslation.Size()))
		n12, err := m.IpTranslation.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Rtt != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.Rtt))
	}
	if m.RttVar != 0 {
		data[i] = 0xb8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.RttVar))
	}
	if m.IntraHost {
		data[i] = 0xc0
		i++
		data[i] = 0x1
		i++
		if m.IntraHost {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.DnsSuccessfulResponses != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsSuccessfulResponses))
	}
	if m.DnsFailedResponses != 0 {
		data[i] = 0xd0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsFailedResponses))
	}
	if m.DnsTimeouts != 0 {
		data[i] = 0xd8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsTimeouts))
	}
	if m.DnsSuccessLatencySum != 0 {
		data[i] = 0xe0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsSuccessLatencySum))
	}
	if m.DnsFailureLatencySum != 0 {
		data[i] = 0xe8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsFailureLatencySum))
	}
	if m.LastTcpEstablished != 0 {
		data[i] = 0xf0
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.LastTcpEstablished))
	}
	if m.LastTcpClosed != 0 {
		data[i] = 0xf8
		i++
		data[i] = 0x1
		i++
		i = encodeVarintConnections(data, i, uint64(m.LastTcpClosed))
	}
	if len(m.RemoteNetworkId) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.RemoteNetworkId)))
		i += copy(data[i:], m.RemoteNetworkId)
	}
	if len(m.DnsCountByRcode) > 0 {
		for k, _ := range m.DnsCountByRcode {
			data[i] = 0x8a
			i++
			data[i] = 0x2
			i++
			v := m.DnsCountByRcode[k]
			mapSize := 1 + sovConnections(uint64(k)) + 1 + sovConnections(uint64(v))
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(k))
			data[i] = 0x10
			i++
			i = encodeVarintConnections(data, i, uint64(v))
		}
	}
	if len(m.DnsStatsByDomain) > 0 {
		for k, _ := range m.DnsStatsByDomain {
			data[i] = 0x92
			i++
			data[i] = 0x2
			i++
			v := m.DnsStatsByDomain[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + sovConnections(uint64(k)) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n13, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	if m.RouteIdx != 0 {
		data[i] = 0xa0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.RouteIdx))
	}
	if len(m.HttpAggregations) > 0 {
		data[i] = 0xaa
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.HttpAggregations)))
		i += copy(data[i:], m.HttpAggregations)
	}
	if m.LastPacketsSent != 0 {
		data[i] = 0xb0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.LastPacketsSent))
	}
	if m.LastPacketsReceived != 0 {
		data[i] = 0xb8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.LastPacketsReceived))
	}
	if m.RouteTargetIdx != 0 {
		data[i] = 0xc0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.RouteTargetIdx))
	}
	if m.IsLocalPortEphemeral != 0 {
		data[i] = 0xc8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.IsLocalPortEphemeral))
	}
	if len(m.DnsStatsByDomainByQueryType) > 0 {
		for k, _ := range m.DnsStatsByDomainByQueryType {
			data[i] = 0xd2
			i++
			data[i] = 0x2
			i++
			v := m.DnsStatsByDomainByQueryType[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + sovConnections(uint64(k)) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n14, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n14
			}
		}
	}
	if len(m.DnsStatsByDomainOffsetByQueryType) > 0 {
		for k, _ := range m.DnsStatsByDomainOffsetByQueryType {
			data[i] = 0xda
			i++
			data[i] = 0x2
			i++
			v := m.DnsStatsByDomainOffsetByQueryType[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + sovConnections(uint64(k)) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n15, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n15
			}
		}
	}
	if len(m.Tags) > 0 {
		for _, num := range m.Tags {
			data[i] = 0xe0
			i++
			data[i] = 0x2
			i++
			i = encodeVarintConnections(data, i, uint64(num))
		}
	}
	if m.TagsIdx != 0 {
		data[i] = 0xe8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.TagsIdx))
	}
	if m.StateIndex != 0 {
		data[i] = 0xf0
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.StateIndex))
	}
	if m.TagsChecksum != 0 {
		data[i] = 0xf8
		i++
		data[i] = 0x2
		i++
		i = encodeVarintConnections(data, i, uint64(m.TagsChecksum))
	}
	if m.Protocol != nil {
		data[i] = 0x82
		i++
		data[i] = 0x3
		i++
		i = encodeVarintConnections(data, i, uint64(m.Protocol.Size()))
		n16, err := m.Protocol.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if len(m.DataStreamsAggregations) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x3
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.DataStreamsAggregations)))
		i += copy(data[i:], m.DataStreamsAggregations)
	}
	if len(m.Http2Aggregations) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x3
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.Http2Aggregations)))
		i += copy(data[i:], m.Http2Aggregations)
	}
	return i, nil
}

func (m *ResourceMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ResourceMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.Key != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintConnections(data, i, uint64(m.Key))
	}
	if len(m.ByteKey) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.ByteKey)))
		i += copy(data[i:], m.ByteKey)
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.TagIndex != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintConnections(data, i, uint64(m.TagIndex))
	}
	if m.TagsModified != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintConnections(data, i, uint64(m.TagsModified))
	}
	return i, nil
}

func (m *ConnectionsTelemetry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConnectionsTelemetry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MonotonicKprobesTriggered != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicKprobesTriggered))
	}
	if m.MonotonicKprobesMissed != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicKprobesMissed))
	}
	if m.MonotonicConntrackRegisters != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicConntrackRegisters))
	}
	if m.MonotonicConntrackRegistersDropped != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicConntrackRegistersDropped))
	}
	if m.MonotonicDnsPacketsProcessed != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicDnsPacketsProcessed))
	}
	if m.MonotonicConnsClosed != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicConnsClosed))
	}
	if m.ConnsBpfMapSize != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConnsBpfMapSize))
	}
	if m.MonotonicUdpSendsProcessed != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicUdpSendsProcessed))
	}
	if m.MonotonicUdpSendsMissed != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintConnections(data, i, uint64(m.MonotonicUdpSendsMissed))
	}
	if m.ConntrackSamplingPercent != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConntrackSamplingPercent))
	}
	if m.DnsStatsDropped != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsStatsDropped))
	}
	return i, nil
}

func (m *CollectorConnectionsTelemetry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CollectorConnectionsTelemetry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KprobesTriggered != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintConnections(data, i, uint64(m.KprobesTriggered))
	}
	if m.KprobesMissed != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintConnections(data, i, uint64(m.KprobesMissed))
	}
	if m.ConntrackRegisters != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConntrackRegisters))
	}
	if m.ConntrackRegistersDropped != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConntrackRegistersDropped))
	}
	if m.DnsPacketsProcessed != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsPacketsProcessed))
	}
	if m.ConnsClosed != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConnsClosed))
	}
	if m.ConnsBpfMapSize != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConnsBpfMapSize))
	}
	if m.UdpSendsProcessed != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintConnections(data, i, uint64(m.UdpSendsProcessed))
	}
	if m.UdpSendsMissed != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintConnections(data, i, uint64(m.UdpSendsMissed))
	}
	if m.ConntrackSamplingPercent != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintConnections(data, i, uint64(m.ConntrackSamplingPercent))
	}
	if m.DnsStatsDropped != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsStatsDropped))
	}
	return i, nil
}

func (m *RuntimeCompilationTelemetry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RuntimeCompilationTelemetry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RuntimeCompilationEnabled {
		data[i] = 0x8
		i++
		if m.RuntimeCompilationEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RuntimeCompilationResult != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintConnections(data, i, uint64(m.RuntimeCompilationResult))
	}
	if m.RuntimeCompilationDuration != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintConnections(data, i, uint64(m.RuntimeCompilationDuration))
	}
	if m.KernelHeaderFetchResult != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintConnections(data, i, uint64(m.KernelHeaderFetchResult))
	}
	return i, nil
}

func (m *AgentConfiguration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AgentConfiguration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NpmEnabled {
		data[i] = 0x8
		i++
		if m.NpmEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.UsmEnabled {
		data[i] = 0x10
		i++
		if m.UsmEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.DsmEnabled {
		data[i] = 0x18
		i++
		if m.DsmEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Route) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Route) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Subnet != nil {
		data[i] = 0xa
		i++
		i = encodeVarintConnections(data, i, uint64(m.Subnet.Size()))
		n17, err := m.Subnet.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *Subnet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Subnet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Alias) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.Alias)))
		i += copy(data[i:], m.Alias)
	}
	return i, nil
}

func (m *RouteMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RouteMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Alias) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.Alias)))
		i += copy(data[i:], m.Alias)
	}
	if m.TagIndex != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintConnections(data, i, uint64(m.TagIndex))
	}
	if m.TagsModified != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintConnections(data, i, uint64(m.TagsModified))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			data[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *IPTranslation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IPTranslation) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReplSrcIP) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.ReplSrcIP)))
		i += copy(data[i:], m.ReplSrcIP)
	}
	if len(m.ReplDstIP) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.ReplDstIP)))
		i += copy(data[i:], m.ReplDstIP)
	}
	if m.ReplSrcPort != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintConnections(data, i, uint64(m.ReplSrcPort))
	}
	if m.ReplDstPort != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintConnections(data, i, uint64(m.ReplDstPort))
	}
	return i, nil
}

func (m *Addr) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Addr) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ip) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.Ip)))
		i += copy(data[i:], m.Ip)
	}
	if m.Port != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintConnections(data, i, uint64(m.Port))
	}
	if len(m.ContainerId) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.ContainerId)))
		i += copy(data[i:], m.ContainerId)
	}
	if len(m.HostName) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintConnections(data, i, uint64(len(m.HostName)))
		i += copy(data[i:], m.HostName)
	}
	return i, nil
}

func (m *ProtocolStack) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ProtocolStack) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Stack) > 0 {
		for _, num := range m.Stack {
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *DNSEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DNSEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DNSStats) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DNSStats) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DnsTimeouts != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsTimeouts))
	}
	if m.DnsSuccessLatencySum != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsSuccessLatencySum))
	}
	if m.DnsFailureLatencySum != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintConnections(data, i, uint64(m.DnsFailureLatencySum))
	}
	if len(m.DnsCountByRcode) > 0 {
		for k, _ := range m.DnsCountByRcode {
			data[i] = 0x22
			i++
			v := m.DnsCountByRcode[k]
			mapSize := 1 + sovConnections(uint64(k)) + 1 + sovConnections(uint64(v))
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(k))
			data[i] = 0x10
			i++
			i = encodeVarintConnections(data, i, uint64(v))
		}
	}
	return i, nil
}

func (m *DNSStatsByQueryType) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DNSStatsByQueryType) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DnsStatsByQueryType) > 0 {
		for k, _ := range m.DnsStatsByQueryType {
			data[i] = 0xa
			i++
			v := m.DnsStatsByQueryType[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovConnections(uint64(msgSize))
			}
			mapSize := 1 + sovConnections(uint64(k)) + msgSize
			i = encodeVarintConnections(data, i, uint64(mapSize))
			data[i] = 0x8
			i++
			i = encodeVarintConnections(data, i, uint64(k))
			if v != nil {
				data[i] = 0x12
				i++
				i = encodeVarintConnections(data, i, uint64(v.Size()))
				n18, err := v.MarshalTo(data[i:])
				if err != nil {
					return 0, err
				}
				i += n18
			}
		}
	}
	return i, nil
}

func encodeFixed64Connections(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Connections(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintConnections(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *CollectorConnections) Size() (n int) {
	var l int
	_ = l
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	if len(m.Connections) > 0 {
		for _, e := range m.Connections {
			l = e.Size()
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	if m.GroupId != 0 {
		n += 1 + sovConnections(uint64(m.GroupId))
	}
	if m.GroupSize != 0 {
		n += 1 + sovConnections(uint64(m.GroupSize))
	}
	if len(m.ResolvedResources) > 0 {
		for k, v := range m.ResolvedResources {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.ContainerForPid) > 0 {
		for k, v := range m.ContainerForPid {
			_ = k
			_ = v
			mapEntrySize := 1 + sovConnections(uint64(k)) + 1 + len(v) + sovConnections(uint64(len(v)))
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	l = len(m.EncodedTags)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	l = len(m.EncodedDNS)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	if m.ContainerHostType != 0 {
		n += 1 + sovConnections(uint64(m.ContainerHostType))
	}
	if m.ConnTelemetry != nil {
		l = m.ConnTelemetry.Size()
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.Architecture)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.KernelVersion)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.PlatformVersion)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	if len(m.CompilationTelemetryByAsset) > 0 {
		for k, v := range m.CompilationTelemetryByAsset {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 2 + l + sovConnections(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 2 + l + sovConnections(uint64(l))
		}
	}
	if len(m.RouteMetadata) > 0 {
		for _, e := range m.RouteMetadata {
			l = e.Size()
			n += 2 + l + sovConnections(uint64(l))
		}
	}
	if m.AgentConfiguration != nil {
		l = m.AgentConfiguration.Size()
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.EncodedDomainDatabase)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.EncodedDnsLookups)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.EncodedConnectionsTags)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	if len(m.ConnTelemetryMap) > 0 {
		for k, v := range m.ConnTelemetryMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.ResolvedHostsByName) > 0 {
		for k, v := range m.ResolvedHostsByName {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + l
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if m.KernelHeaderFetchResult != 0 {
		n += 2 + sovConnections(uint64(m.KernelHeaderFetchResult))
	}
	if len(m.CORETelemetryByAsset) > 0 {
		for k, v := range m.CORETelemetryByAsset {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.PrebuiltEBPFAssets) > 0 {
		for _, s := range m.PrebuiltEBPFAssets {
			l = len(s)
			n += 2 + l + sovConnections(uint64(l))
		}
	}
	return n
}

func (m *Connections) Size() (n int) {
	var l int
	_ = l
	if len(m.Conns) > 0 {
		for _, e := range m.Conns {
			l = e.Size()
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	if len(m.Dns) > 0 {
		for k, v := range m.Dns {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	if m.ConnTelemetry != nil {
		l = m.ConnTelemetry.Size()
		n += 1 + l + sovConnections(uint64(l))
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	if len(m.Routes) > 0 {
		for _, e := range m.Routes {
			l = e.Size()
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	if len(m.CompilationTelemetryByAsset) > 0 {
		for k, v := range m.CompilationTelemetryByAsset {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	if m.AgentConfiguration != nil {
		l = m.AgentConfiguration.Size()
		n += 1 + l + sovConnections(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	if len(m.ConnTelemetryMap) > 0 {
		for k, v := range m.ConnTelemetryMap {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	if m.KernelHeaderFetchResult != 0 {
		n += 1 + sovConnections(uint64(m.KernelHeaderFetchResult))
	}
	if len(m.CORETelemetryByAsset) > 0 {
		for k, v := range m.CORETelemetryByAsset {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConnections(uint64(len(k))) + 1 + sovConnections(uint64(v))
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.PrebuiltEBPFAssets) > 0 {
		for _, s := range m.PrebuiltEBPFAssets {
			l = len(s)
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	return n
}

func (m *Connection) Size() (n int) {
	var l int
	_ = l
	if m.Pid != 0 {
		n += 1 + sovConnections(uint64(m.Pid))
	}
	if m.Laddr != nil {
		l = m.Laddr.Size()
		n += 1 + l + sovConnections(uint64(l))
	}
	if m.Raddr != nil {
		l = m.Raddr.Size()
		n += 1 + l + sovConnections(uint64(l))
	}
	if m.Family != 0 {
		n += 1 + sovConnections(uint64(m.Family))
	}
	if m.Type != 0 {
		n += 1 + sovConnections(uint64(m.Type))
	}
	if m.LastBytesSent != 0 {
		n += 2 + sovConnections(uint64(m.LastBytesSent))
	}
	if m.LastBytesReceived != 0 {
		n += 2 + sovConnections(uint64(m.LastBytesReceived))
	}
	if m.LastRetransmits != 0 {
		n += 2 + sovConnections(uint64(m.LastRetransmits))
	}
	if m.Direction != 0 {
		n += 2 + sovConnections(uint64(m.Direction))
	}
	if m.NetNS != 0 {
		n += 2 + sovConnections(uint64(m.NetNS))
	}
	if m.IpTranslation != nil {
		l = m.IpTranslation.Size()
		n += 2 + l + sovConnections(uint64(l))
	}
	if m.Rtt != 0 {
		n += 2 + sovConnections(uint64(m.Rtt))
	}
	if m.RttVar != 0 {
		n += 2 + sovConnections(uint64(m.RttVar))
	}
	if m.IntraHost {
		n += 3
	}
	if m.DnsSuccessfulResponses != 0 {
		n += 2 + sovConnections(uint64(m.DnsSuccessfulResponses))
	}
	if m.DnsFailedResponses != 0 {
		n += 2 + sovConnections(uint64(m.DnsFailedResponses))
	}
	if m.DnsTimeouts != 0 {
		n += 2 + sovConnections(uint64(m.DnsTimeouts))
	}
	if m.DnsSuccessLatencySum != 0 {
		n += 2 + sovConnections(uint64(m.DnsSuccessLatencySum))
	}
	if m.DnsFailureLatencySum != 0 {
		n += 2 + sovConnections(uint64(m.DnsFailureLatencySum))
	}
	if m.LastTcpEstablished != 0 {
		n += 2 + sovConnections(uint64(m.LastTcpEstablished))
	}
	if m.LastTcpClosed != 0 {
		n += 2 + sovConnections(uint64(m.LastTcpClosed))
	}
	l = len(m.RemoteNetworkId)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	if len(m.DnsCountByRcode) > 0 {
		for k, v := range m.DnsCountByRcode {
			_ = k
			_ = v
			mapEntrySize := 1 + sovConnections(uint64(k)) + 1 + sovConnections(uint64(v))
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.DnsStatsByDomain) > 0 {
		for k, v := range m.DnsStatsByDomain {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + sovConnections(uint64(k)) + l
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if m.RouteIdx != 0 {
		n += 2 + sovConnections(uint64(m.RouteIdx))
	}
	l = len(m.HttpAggregations)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	if m.LastPacketsSent != 0 {
		n += 2 + sovConnections(uint64(m.LastPacketsSent))
	}
	if m.LastPacketsReceived != 0 {
		n += 2 + sovConnections(uint64(m.LastPacketsReceived))
	}
	if m.RouteTargetIdx != 0 {
		n += 2 + sovConnections(uint64(m.RouteTargetIdx))
	}
	if m.IsLocalPortEphemeral != 0 {
		n += 2 + sovConnections(uint64(m.IsLocalPortEphemeral))
	}
	if len(m.DnsStatsByDomainByQueryType) > 0 {
		for k, v := range m.DnsStatsByDomainByQueryType {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + sovConnections(uint64(k)) + l
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.DnsStatsByDomainOffsetByQueryType) > 0 {
		for k, v := range m.DnsStatsByDomainOffsetByQueryType {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + sovConnections(uint64(k)) + l
			n += mapEntrySize + 2 + sovConnections(uint64(mapEntrySize))
		}
	}
	if len(m.Tags) > 0 {
		for _, e := range m.Tags {
			n += 2 + sovConnections(uint64(e))
		}
	}
	if m.TagsIdx != 0 {
		n += 2 + sovConnections(uint64(m.TagsIdx))
	}
	if m.StateIndex != 0 {
		n += 2 + sovConnections(uint64(m.StateIndex))
	}
	if m.TagsChecksum != 0 {
		n += 2 + sovConnections(uint64(m.TagsChecksum))
	}
	if m.Protocol != nil {
		l = m.Protocol.Size()
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.DataStreamsAggregations)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	l = len(m.Http2Aggregations)
	if l > 0 {
		n += 2 + l + sovConnections(uint64(l))
	}
	return n
}

func (m *ResourceMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	if m.Key != 0 {
		n += 1 + sovConnections(uint64(m.Key))
	}
	l = len(m.ByteKey)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	if m.TagIndex != 0 {
		n += 1 + sovConnections(uint64(m.TagIndex))
	}
	if m.TagsModified != 0 {
		n += 1 + sovConnections(uint64(m.TagsModified))
	}
	return n
}

func (m *ConnectionsTelemetry) Size() (n int) {
	var l int
	_ = l
	if m.MonotonicKprobesTriggered != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicKprobesTriggered))
	}
	if m.MonotonicKprobesMissed != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicKprobesMissed))
	}
	if m.MonotonicConntrackRegisters != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicConntrackRegisters))
	}
	if m.MonotonicConntrackRegistersDropped != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicConntrackRegistersDropped))
	}
	if m.MonotonicDnsPacketsProcessed != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicDnsPacketsProcessed))
	}
	if m.MonotonicConnsClosed != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicConnsClosed))
	}
	if m.ConnsBpfMapSize != 0 {
		n += 1 + sovConnections(uint64(m.ConnsBpfMapSize))
	}
	if m.MonotonicUdpSendsProcessed != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicUdpSendsProcessed))
	}
	if m.MonotonicUdpSendsMissed != 0 {
		n += 1 + sovConnections(uint64(m.MonotonicUdpSendsMissed))
	}
	if m.ConntrackSamplingPercent != 0 {
		n += 1 + sovConnections(uint64(m.ConntrackSamplingPercent))
	}
	if m.DnsStatsDropped != 0 {
		n += 1 + sovConnections(uint64(m.DnsStatsDropped))
	}
	return n
}

func (m *CollectorConnectionsTelemetry) Size() (n int) {
	var l int
	_ = l
	if m.KprobesTriggered != 0 {
		n += 1 + sovConnections(uint64(m.KprobesTriggered))
	}
	if m.KprobesMissed != 0 {
		n += 1 + sovConnections(uint64(m.KprobesMissed))
	}
	if m.ConntrackRegisters != 0 {
		n += 1 + sovConnections(uint64(m.ConntrackRegisters))
	}
	if m.ConntrackRegistersDropped != 0 {
		n += 1 + sovConnections(uint64(m.ConntrackRegistersDropped))
	}
	if m.DnsPacketsProcessed != 0 {
		n += 1 + sovConnections(uint64(m.DnsPacketsProcessed))
	}
	if m.ConnsClosed != 0 {
		n += 1 + sovConnections(uint64(m.ConnsClosed))
	}
	if m.ConnsBpfMapSize != 0 {
		n += 1 + sovConnections(uint64(m.ConnsBpfMapSize))
	}
	if m.UdpSendsProcessed != 0 {
		n += 1 + sovConnections(uint64(m.UdpSendsProcessed))
	}
	if m.UdpSendsMissed != 0 {
		n += 1 + sovConnections(uint64(m.UdpSendsMissed))
	}
	if m.ConntrackSamplingPercent != 0 {
		n += 1 + sovConnections(uint64(m.ConntrackSamplingPercent))
	}
	if m.DnsStatsDropped != 0 {
		n += 1 + sovConnections(uint64(m.DnsStatsDropped))
	}
	return n
}

func (m *RuntimeCompilationTelemetry) Size() (n int) {
	var l int
	_ = l
	if m.RuntimeCompilationEnabled {
		n += 2
	}
	if m.RuntimeCompilationResult != 0 {
		n += 1 + sovConnections(uint64(m.RuntimeCompilationResult))
	}
	if m.RuntimeCompilationDuration != 0 {
		n += 1 + sovConnections(uint64(m.RuntimeCompilationDuration))
	}
	if m.KernelHeaderFetchResult != 0 {
		n += 1 + sovConnections(uint64(m.KernelHeaderFetchResult))
	}
	return n
}

func (m *AgentConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.NpmEnabled {
		n += 2
	}
	if m.UsmEnabled {
		n += 2
	}
	if m.DsmEnabled {
		n += 2
	}
	return n
}

func (m *Route) Size() (n int) {
	var l int
	_ = l
	if m.Subnet != nil {
		l = m.Subnet.Size()
		n += 1 + l + sovConnections(uint64(l))
	}
	return n
}

func (m *Subnet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	return n
}

func (m *RouteMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Alias)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	if m.TagIndex != 0 {
		n += 1 + sovConnections(uint64(m.TagIndex))
	}
	if m.TagsModified != 0 {
		n += 1 + sovConnections(uint64(m.TagsModified))
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	return n
}

func (m *IPTranslation) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReplSrcIP)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	l = len(m.ReplDstIP)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	if m.ReplSrcPort != 0 {
		n += 1 + sovConnections(uint64(m.ReplSrcPort))
	}
	if m.ReplDstPort != 0 {
		n += 1 + sovConnections(uint64(m.ReplDstPort))
	}
	return n
}

func (m *Addr) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovConnections(uint64(m.Port))
	}
	l = len(m.ContainerId)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	l = len(m.HostName)
	if l > 0 {
		n += 1 + l + sovConnections(uint64(l))
	}
	return n
}

func (m *ProtocolStack) Size() (n int) {
	var l int
	_ = l
	if len(m.Stack) > 0 {
		for _, e := range m.Stack {
			n += 1 + sovConnections(uint64(e))
		}
	}
	return n
}

func (m *DNSEntry) Size() (n int) {
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovConnections(uint64(l))
		}
	}
	return n
}

func (m *DNSStats) Size() (n int) {
	var l int
	_ = l
	if m.DnsTimeouts != 0 {
		n += 1 + sovConnections(uint64(m.DnsTimeouts))
	}
	if m.DnsSuccessLatencySum != 0 {
		n += 1 + sovConnections(uint64(m.DnsSuccessLatencySum))
	}
	if m.DnsFailureLatencySum != 0 {
		n += 1 + sovConnections(uint64(m.DnsFailureLatencySum))
	}
	if len(m.DnsCountByRcode) > 0 {
		for k, v := range m.DnsCountByRcode {
			_ = k
			_ = v
			mapEntrySize := 1 + sovConnections(uint64(k)) + 1 + sovConnections(uint64(v))
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DNSStatsByQueryType) Size() (n int) {
	var l int
	_ = l
	if len(m.DnsStatsByQueryType) > 0 {
		for k, v := range m.DnsStatsByQueryType {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConnections(uint64(l))
			}
			mapEntrySize := 1 + sovConnections(uint64(k)) + l
			n += mapEntrySize + 1 + sovConnections(uint64(mapEntrySize))
		}
	}
	return n
}

func sovConnections(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozConnections(x uint64) (n int) {
	return sovConnections(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CollectorConnections) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorConnections: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorConnections: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connections", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Connections = append(m.Connections, &Connection{})
			if err := m.Connections[len(m.Connections)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupSize", wireType)
			}
			m.GroupSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.GroupSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ResolvedResources == nil {
				m.ResolvedResources = make(map[string]*ResourceMetadata)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &ResourceMetadata{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.ResolvedResources[mapkey] = mapvalue
			} else {
				var mapvalue *ResourceMetadata
				m.ResolvedResources[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerForPid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.ContainerForPid == nil {
				m.ContainerForPid = make(map[int32]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthConnections
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(data[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.ContainerForPid[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.ContainerForPid[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedTags", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedTags = append(m.EncodedTags[:0], data[iNdEx:postIndex]...)
			if m.EncodedTags == nil {
				m.EncodedTags = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedDNS", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedDNS = append(m.EncodedDNS[:0], data[iNdEx:postIndex]...)
			if m.EncodedDNS == nil {
				m.EncodedDNS = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHostType", wireType)
			}
			m.ContainerHostType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ContainerHostType |= (ContainerHostType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTelemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnTelemetry == nil {
				m.ConnTelemetry = &CollectorConnectionsTelemetry{}
			}
			if err := m.ConnTelemetry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Architecture", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Architecture = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KernelVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompilationTelemetryByAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.CompilationTelemetryByAsset == nil {
				m.CompilationTelemetryByAsset = make(map[string]*RuntimeCompilationTelemetry)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &RuntimeCompilationTelemetry{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.CompilationTelemetryByAsset[mapkey] = mapvalue
			} else {
				var mapvalue *RuntimeCompilationTelemetry
				m.CompilationTelemetryByAsset[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RouteMetadata = append(m.RouteMetadata, &RouteMetadata{})
			if err := m.RouteMetadata[len(m.RouteMetadata)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AgentConfiguration == nil {
				m.AgentConfiguration = &AgentConfiguration{}
			}
			if err := m.AgentConfiguration.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedDomainDatabase", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedDomainDatabase = append(m.EncodedDomainDatabase[:0], data[iNdEx:postIndex]...)
			if m.EncodedDomainDatabase == nil {
				m.EncodedDomainDatabase = []byte{}
			}
			iNdEx = postIndex
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedDnsLookups", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedDnsLookups = append(m.EncodedDnsLookups[:0], data[iNdEx:postIndex]...)
			if m.EncodedDnsLookups == nil {
				m.EncodedDnsLookups = []byte{}
			}
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodedConnectionsTags", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncodedConnectionsTags = append(m.EncodedConnectionsTags[:0], data[iNdEx:postIndex]...)
			if m.EncodedConnectionsTags == nil {
				m.EncodedConnectionsTags = []byte{}
			}
			iNdEx = postIndex
		case 39:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTelemetryMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ConnTelemetryMap == nil {
				m.ConnTelemetryMap = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ConnTelemetryMap[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.ConnTelemetryMap[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedHostsByName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ResolvedHostsByName == nil {
				m.ResolvedHostsByName = make(map[string]*Host)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &Host{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.ResolvedHostsByName[mapkey] = mapvalue
			} else {
				var mapvalue *Host
				m.ResolvedHostsByName[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelHeaderFetchResult", wireType)
			}
			m.KernelHeaderFetchResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KernelHeaderFetchResult |= (KernelHeaderFetchResult(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CORETelemetryByAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.CORETelemetryByAsset == nil {
				m.CORETelemetryByAsset = make(map[string]COREResult)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue COREResult
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (COREResult(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CORETelemetryByAsset[mapkey] = mapvalue
			} else {
				var mapvalue COREResult
				m.CORETelemetryByAsset[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrebuiltEBPFAssets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrebuiltEBPFAssets = append(m.PrebuiltEBPFAssets, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connections) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connections: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connections: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conns = append(m.Conns, &Connection{})
			if err := m.Conns[len(m.Conns)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Dns == nil {
				m.Dns = make(map[string]*DNSEntry)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &DNSEntry{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.Dns[mapkey] = mapvalue
			} else {
				var mapvalue *DNSEntry
				m.Dns[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTelemetry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConnTelemetry == nil {
				m.ConnTelemetry = &ConnectionsTelemetry{}
			}
			if err := m.ConnTelemetry.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Routes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Routes = append(m.Routes, &Route{})
			if err := m.Routes[len(m.Routes)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompilationTelemetryByAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.CompilationTelemetryByAsset == nil {
				m.CompilationTelemetryByAsset = make(map[string]*RuntimeCompilationTelemetry)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &RuntimeCompilationTelemetry{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.CompilationTelemetryByAsset[mapkey] = mapvalue
			} else {
				var mapvalue *RuntimeCompilationTelemetry
				m.CompilationTelemetryByAsset[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentConfiguration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AgentConfiguration == nil {
				m.AgentConfiguration = &AgentConfiguration{}
			}
			if err := m.AgentConfiguration.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnTelemetryMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.ConnTelemetryMap == nil {
				m.ConnTelemetryMap = make(map[string]int64)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ConnTelemetryMap[mapkey] = mapvalue
			} else {
				var mapvalue int64
				m.ConnTelemetryMap[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelHeaderFetchResult", wireType)
			}
			m.KernelHeaderFetchResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KernelHeaderFetchResult |= (KernelHeaderFetchResult(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CORETelemetryByAsset", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthConnections
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.CORETelemetryByAsset == nil {
				m.CORETelemetryByAsset = make(map[string]COREResult)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue COREResult
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (COREResult(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CORETelemetryByAsset[mapkey] = mapvalue
			} else {
				var mapvalue COREResult
				m.CORETelemetryByAsset[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrebuiltEBPFAssets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrebuiltEBPFAssets = append(m.PrebuiltEBPFAssets, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pid", wireType)
			}
			m.Pid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Pid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Laddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Laddr == nil {
				m.Laddr = &Addr{}
			}
			if err := m.Laddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Raddr == nil {
				m.Raddr = &Addr{}
			}
			if err := m.Raddr.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Family", wireType)
			}
			m.Family = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Family |= (ConnectionFamily(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (ConnectionType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBytesSent", wireType)
			}
			m.LastBytesSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastBytesSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBytesReceived", wireType)
			}
			m.LastBytesReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastBytesReceived |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRetransmits", wireType)
			}
			m.LastRetransmits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastRetransmits |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Direction |= (ConnectionDirection(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetNS", wireType)
			}
			m.NetNS = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NetNS |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpTranslation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IpTranslation == nil {
				m.IpTranslation = &IPTranslation{}
			}
			if err := m.IpTranslation.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Rtt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RttVar", wireType)
			}
			m.RttVar = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RttVar |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntraHost", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntraHost = bool(v != 0)
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSuccessfulResponses", wireType)
			}
			m.DnsSuccessfulResponses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsSuccessfulResponses |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsFailedResponses", wireType)
			}
			m.DnsFailedResponses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsFailedResponses |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsTimeouts", wireType)
			}
			m.DnsTimeouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsTimeouts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSuccessLatencySum", wireType)
			}
			m.DnsSuccessLatencySum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsSuccessLatencySum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsFailureLatencySum", wireType)
			}
			m.DnsFailureLatencySum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsFailureLatencySum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTcpEstablished", wireType)
			}
			m.LastTcpEstablished = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTcpEstablished |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTcpClosed", wireType)
			}
			m.LastTcpClosed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastTcpClosed |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteNetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteNetworkId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsCountByRcode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DnsCountByRcode == nil {
				m.DnsCountByRcode = make(map[uint32]uint32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DnsCountByRcode[mapkey] = mapvalue
			} else {
				var mapvalue uint32
				m.DnsCountByRcode[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsStatsByDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DnsStatsByDomain == nil {
				m.DnsStatsByDomain = make(map[int32]*DNSStats)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &DNSStats{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.DnsStatsByDomain[mapkey] = mapvalue
			} else {
				var mapvalue *DNSStats
				m.DnsStatsByDomain[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteIdx", wireType)
			}
			m.RouteIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RouteIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpAggregations", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpAggregations = append(m.HttpAggregations[:0], data[iNdEx:postIndex]...)
			if m.HttpAggregations == nil {
				m.HttpAggregations = []byte{}
			}
			iNdEx = postIndex
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPacketsSent", wireType)
			}
			m.LastPacketsSent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastPacketsSent |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPacketsReceived", wireType)
			}
			m.LastPacketsReceived = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastPacketsReceived |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RouteTargetIdx", wireType)
			}
			m.RouteTargetIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RouteTargetIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLocalPortEphemeral", wireType)
			}
			m.IsLocalPortEphemeral = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.IsLocalPortEphemeral |= (EphemeralPortState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsStatsByDomainByQueryType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DnsStatsByDomainByQueryType == nil {
				m.DnsStatsByDomainByQueryType = make(map[int32]*DNSStatsByQueryType)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &DNSStatsByQueryType{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.DnsStatsByDomainByQueryType[mapkey] = mapvalue
			} else {
				var mapvalue *DNSStatsByQueryType
				m.DnsStatsByDomainByQueryType[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsStatsByDomainOffsetByQueryType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DnsStatsByDomainOffsetByQueryType == nil {
				m.DnsStatsByDomainOffsetByQueryType = make(map[int32]*DNSStatsByQueryType)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &DNSStatsByQueryType{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.DnsStatsByDomainOffsetByQueryType[mapkey] = mapvalue
			} else {
				var mapvalue *DNSStatsByQueryType
				m.DnsStatsByDomainOffsetByQueryType[mapkey] = mapvalue
			}
			iNdEx = postIndex
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tags = append(m.Tags, v)
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsIdx", wireType)
			}
			m.TagsIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagsIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateIndex", wireType)
			}
			m.StateIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StateIndex |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsChecksum", wireType)
			}
			m.TagsChecksum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagsChecksum |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Protocol == nil {
				m.Protocol = &ProtocolStack{}
			}
			if err := m.Protocol.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStreamsAggregations", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataStreamsAggregations = append(m.DataStreamsAggregations[:0], data[iNdEx:postIndex]...)
			if m.DataStreamsAggregations == nil {
				m.DataStreamsAggregations = []byte{}
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Http2Aggregations", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Http2Aggregations = append(m.Http2Aggregations[:0], data[iNdEx:postIndex]...)
			if m.Http2Aggregations == nil {
				m.Http2Aggregations = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Key |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByteKey = append(m.ByteKey[:0], data[iNdEx:postIndex]...)
			if m.ByteKey == nil {
				m.ByteKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagIndex", wireType)
			}
			m.TagIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsModified", wireType)
			}
			m.TagsModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagsModified |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConnectionsTelemetry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConnectionsTelemetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConnectionsTelemetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicKprobesTriggered", wireType)
			}
			m.MonotonicKprobesTriggered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicKprobesTriggered |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicKprobesMissed", wireType)
			}
			m.MonotonicKprobesMissed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicKprobesMissed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicConntrackRegisters", wireType)
			}
			m.MonotonicConntrackRegisters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicConntrackRegisters |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicConntrackRegistersDropped", wireType)
			}
			m.MonotonicConntrackRegistersDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicConntrackRegistersDropped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicDnsPacketsProcessed", wireType)
			}
			m.MonotonicDnsPacketsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicDnsPacketsProcessed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicConnsClosed", wireType)
			}
			m.MonotonicConnsClosed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicConnsClosed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnsBpfMapSize", wireType)
			}
			m.ConnsBpfMapSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConnsBpfMapSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicUdpSendsProcessed", wireType)
			}
			m.MonotonicUdpSendsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicUdpSendsProcessed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MonotonicUdpSendsMissed", wireType)
			}
			m.MonotonicUdpSendsMissed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MonotonicUdpSendsMissed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConntrackSamplingPercent", wireType)
			}
			m.ConntrackSamplingPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConntrackSamplingPercent |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsStatsDropped", wireType)
			}
			m.DnsStatsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsStatsDropped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CollectorConnectionsTelemetry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CollectorConnectionsTelemetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CollectorConnectionsTelemetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KprobesTriggered", wireType)
			}
			m.KprobesTriggered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KprobesTriggered |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KprobesMissed", wireType)
			}
			m.KprobesMissed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KprobesMissed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConntrackRegisters", wireType)
			}
			m.ConntrackRegisters = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConntrackRegisters |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConntrackRegistersDropped", wireType)
			}
			m.ConntrackRegistersDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConntrackRegistersDropped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsPacketsProcessed", wireType)
			}
			m.DnsPacketsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsPacketsProcessed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnsClosed", wireType)
			}
			m.ConnsClosed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConnsClosed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnsBpfMapSize", wireType)
			}
			m.ConnsBpfMapSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConnsBpfMapSize |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSendsProcessed", wireType)
			}
			m.UdpSendsProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UdpSendsProcessed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UdpSendsMissed", wireType)
			}
			m.UdpSendsMissed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UdpSendsMissed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConntrackSamplingPercent", wireType)
			}
			m.ConntrackSamplingPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ConntrackSamplingPercent |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsStatsDropped", wireType)
			}
			m.DnsStatsDropped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsStatsDropped |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RuntimeCompilationTelemetry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RuntimeCompilationTelemetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RuntimeCompilationTelemetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCompilationEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RuntimeCompilationEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCompilationResult", wireType)
			}
			m.RuntimeCompilationResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RuntimeCompilationResult |= (RuntimeCompilationResult(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeCompilationDuration", wireType)
			}
			m.RuntimeCompilationDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RuntimeCompilationDuration |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KernelHeaderFetchResult", wireType)
			}
			m.KernelHeaderFetchResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.KernelHeaderFetchResult |= (KernelHeaderFetchResult(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AgentConfiguration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AgentConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AgentConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NpmEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NpmEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsmEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UsmEnabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DsmEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DsmEnabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Route) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Route: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Route: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subnet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Subnet == nil {
				m.Subnet = &Subnet{}
			}
			if err := m.Subnet.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subnet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subnet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subnet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RouteMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RouteMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RouteMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alias", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Alias = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagIndex", wireType)
			}
			m.TagIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagsModified", wireType)
			}
			m.TagsModified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TagsModified |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IPTranslation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IPTranslation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IPTranslation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplSrcIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplSrcIP = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplDstIP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplDstIP = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplSrcPort", wireType)
			}
			m.ReplSrcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReplSrcPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplDstPort", wireType)
			}
			m.ReplDstPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReplDstPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addr) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HostName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProtocolStack) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProtocolStack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProtocolStack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stack", wireType)
			}
			var v ProtocolType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (ProtocolType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stack = append(m.Stack, v)
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSStats) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsTimeouts", wireType)
			}
			m.DnsTimeouts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsTimeouts |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSuccessLatencySum", wireType)
			}
			m.DnsSuccessLatencySum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsSuccessLatencySum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsFailureLatencySum", wireType)
			}
			m.DnsFailureLatencySum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DnsFailureLatencySum |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsCountByRcode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DnsCountByRcode == nil {
				m.DnsCountByRcode = make(map[uint32]uint32)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapvalue uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapvalue |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DnsCountByRcode[mapkey] = mapvalue
			} else {
				var mapvalue uint32
				m.DnsCountByRcode[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSStatsByQueryType) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSStatsByQueryType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSStatsByQueryType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsStatsByQueryType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConnections
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapkey int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapkey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if m.DnsStatsByQueryType == nil {
				m.DnsStatsByQueryType = make(map[int32]*DNSStats)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var mapmsglen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					mapmsglen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				postmsgIndex := iNdEx + mapmsglen
				if mapmsglen < 0 {
					return ErrInvalidLengthConnections
				}
				if postmsgIndex > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := &DNSStats{}
				if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
					return err
				}
				iNdEx = postmsgIndex
				m.DnsStatsByQueryType[mapkey] = mapvalue
			} else {
				var mapvalue *DNSStats
				m.DnsStatsByQueryType[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConnections(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConnections
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConnections(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConnections
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConnections
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthConnections
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowConnections
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipConnections(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthConnections = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConnections   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/process/connections.proto", fileDescriptorConnections) }

var fileDescriptorConnections = []byte{
	// 3146 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xcd, 0x73, 0xdb, 0xc6,
	0xd9, 0x37, 0x48, 0x4a, 0x22, 0x1f, 0x8a, 0x12, 0xb4, 0x92, 0x6c, 0x58, 0x76, 0x64, 0x9a, 0x76,
	0x6c, 0x45, 0x49, 0xe4, 0x44, 0xaf, 0xf3, 0x39, 0x49, 0x5e, 0x4b, 0xa2, 0x34, 0x92, 0x6c, 0xcb,
	0x32, 0x28, 0x3b, 0xf3, 0x66, 0xe6, 0x6d, 0x0b, 0x01, 0x2b, 0x0a, 0x11, 0x88, 0xc5, 0xec, 0x2e,
	0xec, 0x30, 0xa7, 0x4e, 0xa7, 0xbd, 0xb6, 0x9d, 0x1e, 0x3a, 0xd3, 0x9e, 0x32, 0xbd, 0xf5, 0x3f,
	0xe8, 0x9f, 0xd0, 0xde, 0xfa, 0x27, 0x74, 0xd2, 0x43, 0xef, 0x9d, 0xe9, 0xb1, 0x33, 0x9d, 0xdd,
	0x05, 0x48, 0x80, 0x04, 0x44, 0x2a, 0x75, 0x33, 0x3d, 0x11, 0xf8, 0x3d, 0x5f, 0xfb, 0xf1, 0xec,
	0x3e, 0x1f, 0x20, 0xdc, 0x08, 0x28, 0xe1, 0xe4, 0x5e, 0x40, 0x89, 0x8d, 0x19, 0xbb, 0x67, 0x13,
	0xdf, 0xc7, 0x36, 0x77, 0x89, 0xcf, 0xd6, 0x24, 0x05, 0x2d, 0x3a, 0x16, 0xb7, 0x1c, 0xd2, 0x5e,
	0x8b, 0x58, 0x7e, 0x68, 0xb5, 0xb1, 0xcf, 0x97, 0xae, 0xa6, 0xe5, 0x24, 0xa8, 0x24, 0x1a, 0x7f,
	0x9a, 0x87, 0x85, 0x2d, 0xe2, 0x79, 0xd8, 0xe6, 0x84, 0x6e, 0xf5, 0x15, 0xa2, 0x25, 0x28, 0x9f,
	0x12, 0xc6, 0x0f, 0xac, 0x0e, 0x36, 0x0a, 0x75, 0x6d, 0xa5, 0x62, 0xf6, 0xde, 0xd1, 0x16, 0x54,
	0x13, 0xb6, 0x8d, 0x62, 0xbd, 0xb8, 0x52, 0x5d, 0xbf, 0xb9, 0x96, 0x69, 0x7c, 0xad, 0xaf, 0xd4,
	0x4c, 0x4a, 0x21, 0x03, 0xa6, 0xda, 0x94, 0x84, 0xc1, 0x9e, 0x63, 0x4c, 0xd4, 0xb5, 0x95, 0x09,
	0x33, 0x7e, 0x45, 0xd7, 0xa1, 0x22, 0x1f, 0x5b, 0xee, 0xd7, 0xd8, 0x98, 0x94, 0xb4, 0x3e, 0x80,
	0x02, 0x98, 0xa3, 0x98, 0x11, 0xef, 0x05, 0x76, 0x4c, 0xcc, 0x48, 0x48, 0x6d, 0xcc, 0x8c, 0xb2,
	0x1c, 0xc2, 0x66, 0xee, 0x10, 0x86, 0x27, 0xb8, 0x66, 0x0e, 0x2a, 0xd9, 0xf6, 0x39, 0xed, 0x9a,
	0xc3, 0xca, 0xd1, 0x97, 0x30, 0x6b, 0x13, 0x9f, 0x5b, 0xae, 0x8f, 0xe9, 0x0e, 0xa1, 0x87, 0xae,
	0x63, 0x80, 0xb4, 0xf7, 0xe0, 0x22, 0xf6, 0xb6, 0xd2, 0x2a, 0x94, 0xb5, 0x41, 0xc5, 0xa8, 0x0e,
	0x55, 0xec, 0xdb, 0xc4, 0xc1, 0xce, 0x91, 0xd5, 0x66, 0x46, 0xb5, 0xae, 0xad, 0x4c, 0x9b, 0x49,
	0x48, 0xac, 0x8e, 0x8f, 0xf9, 0x4b, 0x42, 0xcf, 0xf6, 0x1c, 0x63, 0x5a, 0xee, 0x4c, 0x1f, 0x40,
	0xcb, 0x00, 0x11, 0x73, 0xf3, 0xa0, 0x65, 0xcc, 0x48, 0xf1, 0x04, 0x82, 0x9e, 0xc3, 0x5c, 0xcf,
	0xe4, 0x2e, 0x61, 0xfc, 0xa8, 0x1b, 0x60, 0x63, 0xb6, 0xae, 0xad, 0xcc, 0xac, 0xaf, 0xe4, 0x6f,
	0x60, 0x9a, 0xdf, 0x1c, 0x56, 0x81, 0xbe, 0x80, 0x9a, 0xd8, 0xdc, 0x23, 0xec, 0xe1, 0x0e, 0xe6,
	0xb4, 0x6b, 0xe8, 0x75, 0x6d, 0xa5, 0xba, 0x7e, 0xff, 0x02, 0x2b, 0xd4, 0x93, 0x35, 0xd3, 0xaa,
	0x50, 0x03, 0xa6, 0x2d, 0x6a, 0x9f, 0xba, 0x1c, 0xdb, 0x3c, 0xa4, 0xd8, 0x98, 0x93, 0x93, 0x4e,
	0x61, 0xe8, 0x36, 0xd4, 0xce, 0x30, 0xf5, 0xb1, 0xf7, 0x1c, 0x53, 0xe6, 0x12, 0xdf, 0x40, 0x92,
	0x29, 0x0d, 0x0a, 0xa7, 0x0e, 0x3c, 0x8b, 0x9f, 0x10, 0xda, 0x31, 0xe6, 0x95, 0x53, 0xc7, 0xef,
	0x68, 0x05, 0x66, 0xe3, 0xe7, 0x58, 0xc7, 0x82, 0x64, 0x19, 0x84, 0xd1, 0xcf, 0x35, 0xb8, 0x66,
	0x93, 0x4e, 0xe0, 0x7a, 0x96, 0x18, 0x78, 0x6f, 0xa0, 0x9b, 0xdd, 0x0d, 0xc6, 0x30, 0x37, 0x16,
	0xa5, 0x73, 0x3c, 0xba, 0x98, 0x73, 0xe4, 0xaa, 0x53, 0x8e, 0x72, 0x9e, 0x41, 0x71, 0x94, 0x1c,
	0xd2, 0xb1, 0x5c, 0x9f, 0x19, 0xcb, 0xf5, 0xe2, 0x4a, 0xc5, 0x8c, 0x5f, 0xd1, 0x7d, 0x98, 0xa4,
	0x24, 0xe4, 0x98, 0x19, 0x37, 0xe4, 0xa0, 0xae, 0xe7, 0x0c, 0xca, 0x14, 0x4c, 0x66, 0xc4, 0x8b,
	0xf6, 0xa1, 0x26, 0x9f, 0x1e, 0x63, 0x6e, 0x09, 0x7e, 0xa3, 0x21, 0x85, 0x6f, 0x9f, 0x27, 0x1c,
	0xf3, 0x9a, 0x69, 0x51, 0xf4, 0x7f, 0x80, 0x24, 0xd7, 0x16, 0xf1, 0x4f, 0xdc, 0x76, 0x48, 0xe5,
	0x0c, 0x8c, 0x5b, 0xd2, 0x3b, 0xde, 0xc8, 0x51, 0xb8, 0x31, 0x24, 0x60, 0x66, 0x28, 0x41, 0xf7,
	0x61, 0x31, 0xf6, 0x6c, 0x39, 0xdd, 0xa6, 0xc5, 0xad, 0x63, 0x8b, 0x61, 0xe3, 0xb6, 0x74, 0xfb,
	0x6c, 0x22, 0x7a, 0x0b, 0xe6, 0x62, 0x82, 0xcf, 0x1e, 0x11, 0x72, 0x16, 0x06, 0xcc, 0x78, 0x5d,
	0x4a, 0x0c, 0x13, 0xd0, 0xfb, 0x70, 0x39, 0x02, 0x93, 0x9e, 0x2a, 0x8e, 0xe6, 0x1d, 0x29, 0x92,
	0x43, 0x45, 0x1d, 0xd0, 0x53, 0x4e, 0xfc, 0xd8, 0x0a, 0x8c, 0xbb, 0x72, 0x15, 0x37, 0x2e, 0x78,
	0x69, 0xa4, 0x74, 0x28, 0x67, 0x18, 0x52, 0x8d, 0x5e, 0xc0, 0x7c, 0x7c, 0x6f, 0x89, 0x23, 0xc9,
	0x36, 0xbb, 0xf2, 0xe2, 0x5e, 0x91, 0x16, 0x9b, 0xdf, 0xe5, 0x5a, 0x4c, 0xa8, 0x51, 0x46, 0xb3,
	0x0c, 0xa0, 0x53, 0xb8, 0xa2, 0x4e, 0xd8, 0x2e, 0xb6, 0x1c, 0x4c, 0x77, 0x30, 0xb7, 0x4f, 0x4d,
	0xcc, 0x42, 0x8f, 0x1b, 0x6f, 0xc8, 0x4b, 0x65, 0x2d, 0xc7, 0xf6, 0xc3, 0x6c, 0x29, 0x33, 0x4f,
	0x1d, 0xea, 0xc2, 0xc2, 0xd6, 0x13, 0x73, 0x7b, 0xe8, 0xb0, 0xad, 0xca, 0x29, 0x6e, 0x5f, 0x68,
	0x51, 0x33, 0xf4, 0xa8, 0x39, 0x66, 0x9a, 0x40, 0x6b, 0x80, 0x0e, 0x29, 0x3e, 0x0e, 0x5d, 0x8f,
	0x6f, 0x6f, 0x1e, 0xee, 0x48, 0x90, 0x19, 0x6f, 0xc9, 0x93, 0x96, 0x41, 0x59, 0xea, 0xc0, 0xe5,
	0xec, 0xe0, 0x82, 0x74, 0x28, 0x9e, 0xe1, 0xae, 0xa1, 0xc9, 0x7b, 0x45, 0x3c, 0xa2, 0x4f, 0x61,
	0xe2, 0x85, 0xe5, 0x85, 0x2a, 0xc6, 0x56, 0xd7, 0xef, 0xe6, 0x1d, 0xb1, 0x48, 0x4f, 0xef, 0x94,
	0x29, 0xa9, 0x8f, 0x0b, 0x1f, 0x6a, 0x4b, 0x9b, 0x22, 0x82, 0x0f, 0xc7, 0x96, 0xa4, 0xb1, 0x09,
	0x65, 0x6c, 0x21, 0x69, 0xac, 0x92, 0xd4, 0xb1, 0x05, 0x8b, 0x99, 0xae, 0x96, 0x31, 0xe2, 0x94,
	0x92, 0x62, 0x52, 0xc9, 0x4f, 0x34, 0xa8, 0x8f, 0xba, 0xc8, 0x32, 0x14, 0xee, 0xa6, 0x97, 0x60,
	0x3d, 0x6f, 0x09, 0x42, 0x9f, 0xbb, 0x1d, 0x9c, 0x65, 0x20, 0x39, 0x88, 0x2f, 0xe1, 0x6a, 0xee,
	0xfe, 0x66, 0x18, 0xff, 0x20, 0x69, 0x7c, 0x26, 0x3f, 0x89, 0x79, 0x62, 0x6e, 0x47, 0x1e, 0x9a,
	0xb0, 0x65, 0x83, 0x91, 0x77, 0x5c, 0x32, 0x4c, 0xbd, 0x9b, 0x9e, 0xe7, 0xb5, 0x1c, 0x53, 0x42,
	0x53, 0xc2, 0xc8, 0x7e, 0xa9, 0xac, 0xe9, 0x85, 0xfd, 0x52, 0xb9, 0xa4, 0x4f, 0xec, 0x97, 0xca,
	0x53, 0x7a, 0x79, 0xbf, 0x54, 0xae, 0xe8, 0xb0, 0x5f, 0x2a, 0xd7, 0xf4, 0x99, 0xfd, 0x52, 0xb9,
	0xae, 0xdf, 0xdc, 0x2f, 0x95, 0x6f, 0xea, 0x8d, 0xc6, 0x37, 0x00, 0xd5, 0x64, 0x0a, 0xf7, 0x01,
	0x4c, 0x88, 0x8b, 0x82, 0x19, 0xda, 0xb8, 0x09, 0x9a, 0xe2, 0x47, 0x9f, 0x42, 0xd1, 0xf1, 0x99,
	0x51, 0x90, 0x62, 0x6f, 0x8e, 0x14, 0x63, 0x6b, 0x4d, 0x3f, 0xca, 0x9e, 0x84, 0x1c, 0x7a, 0x3a,
	0x98, 0x0b, 0x14, 0xe5, 0x84, 0xc7, 0x50, 0x94, 0x9b, 0x02, 0x24, 0x22, 0x5c, 0x29, 0x2f, 0xc2,
	0x4d, 0x5c, 0x20, 0xc2, 0xfd, 0x6c, 0x44, 0x08, 0x9f, 0x94, 0xba, 0xb6, 0xc6, 0x98, 0xfa, 0xbf,
	0x17, 0xb9, 0xb3, 0xa3, 0xe3, 0xd4, 0xab, 0x88, 0x8e, 0x08, 0x4a, 0x5c, 0xc4, 0xa9, 0xb2, 0x5c,
	0x2f, 0xf9, 0x8c, 0x9c, 0x8c, 0xa8, 0x54, 0x91, 0x53, 0xfd, 0x70, 0xac, 0xa9, 0x8e, 0x17, 0x8c,
	0xce, 0x09, 0x0a, 0xf0, 0x6a, 0x83, 0x42, 0x90, 0x13, 0x14, 0xaa, 0x72, 0x4e, 0x9f, 0x8c, 0x33,
	0xa7, 0x57, 0x12, 0x0b, 0xa6, 0x73, 0x63, 0xc1, 0xe7, 0x50, 0x8e, 0x0f, 0x47, 0xc6, 0x95, 0xf0,
	0x5e, 0xfa, 0x4a, 0xb8, 0x91, 0x33, 0xe0, 0xe6, 0x41, 0x4b, 0x8d, 0xe9, 0xbf, 0xed, 0xb2, 0x7d,
	0x25, 0x61, 0xe3, 0x7b, 0xbc, 0xb1, 0x1b, 0xff, 0x9c, 0x07, 0xe8, 0x6f, 0xbf, 0xd0, 0x1e, 0xb8,
	0x4e, 0x1c, 0x22, 0x03, 0xd7, 0x11, 0x97, 0xb4, 0x67, 0x39, 0x0e, 0x95, 0x35, 0x69, 0xfe, 0x25,
	0xbd, 0xe1, 0x38, 0xd4, 0x54, 0x9c, 0x42, 0x84, 0x4a, 0x91, 0xc9, 0x31, 0x44, 0x24, 0x27, 0xfa,
	0x5f, 0x98, 0x3c, 0xb1, 0x3a, 0xae, 0xd7, 0x8d, 0x0e, 0xc4, 0xdd, 0x91, 0x9e, 0xba, 0x23, 0xd9,
	0xcd, 0x48, 0x0c, 0x7d, 0x04, 0x25, 0x2e, 0x2a, 0xb7, 0xaa, 0x14, 0x7f, 0x7d, 0xa4, 0xb8, 0x2c,
	0xdb, 0xa4, 0x88, 0xa8, 0x94, 0x3c, 0x8b, 0xf1, 0xcd, 0x2e, 0xc7, 0xac, 0x85, 0x7d, 0x2e, 0x2b,
	0xb5, 0x92, 0x99, 0x06, 0x45, 0x96, 0xdc, 0x03, 0x4c, 0x6c, 0x63, 0xf7, 0x05, 0x76, 0x64, 0xe1,
	0x55, 0x32, 0x87, 0x09, 0xa2, 0x76, 0x12, 0xa0, 0x89, 0x39, 0xb5, 0x7c, 0xd6, 0x71, 0x39, 0x93,
	0xf5, 0x57, 0xcd, 0x1c, 0x84, 0xd1, 0x2e, 0x54, 0x1c, 0x97, 0xaa, 0x41, 0xc9, 0x12, 0x6c, 0x66,
	0x7d, 0x75, 0xe4, 0xe8, 0x9b, 0xb1, 0x84, 0xd9, 0x17, 0x16, 0x0e, 0xe5, 0x63, 0x7e, 0xd0, 0x92,
	0x55, 0x5a, 0xcd, 0x54, 0x2f, 0xa2, 0x74, 0x71, 0x83, 0x23, 0x61, 0x4e, 0xb9, 0xad, 0xb1, 0x28,
	0x37, 0x25, 0xaf, 0x74, 0xd9, 0x3b, 0x4c, 0xf0, 0x9a, 0x69, 0x51, 0xe1, 0x1d, 0x94, 0x73, 0xe3,
	0xb2, 0xd4, 0x2f, 0x1e, 0xd1, 0x65, 0x98, 0xa4, 0x9c, 0x3f, 0xb7, 0xa8, 0x71, 0x45, 0x82, 0xd1,
	0x9b, 0xa8, 0xc9, 0x5d, 0x9f, 0x53, 0x4b, 0xc4, 0x6e, 0xc3, 0xa8, 0x6b, 0x2b, 0x65, 0xb3, 0x0f,
	0x88, 0x1a, 0xc2, 0xf1, 0x59, 0x2b, 0xb4, 0x85, 0xe1, 0x93, 0xd0, 0x33, 0x31, 0x0b, 0x88, 0xcf,
	0x30, 0x33, 0xae, 0x4a, 0x2d, 0x39, 0x54, 0x71, 0xd7, 0x38, 0x3e, 0xdb, 0xb1, 0x5c, 0x4f, 0x26,
	0x92, 0x91, 0xcc, 0x92, 0x94, 0xc9, 0xa0, 0xa0, 0x3a, 0x54, 0x1d, 0x9f, 0x1d, 0xb9, 0x1d, 0x4c,
	0x42, 0xce, 0x8c, 0x6b, 0x92, 0x31, 0x09, 0xa1, 0x75, 0x58, 0xe8, 0xdb, 0x7a, 0x64, 0x71, 0xec,
	0xdb, 0xdd, 0x56, 0xd8, 0x31, 0xae, 0xcb, 0x8d, 0xcd, 0xa4, 0x45, 0x32, 0xc2, 0x56, 0x48, 0x71,
	0x42, 0xe6, 0xb5, 0x9e, 0xcc, 0x10, 0x4d, 0x8c, 0x5c, 0x6c, 0xfc, 0x91, 0x1d, 0x6c, 0x33, 0x6e,
	0x1d, 0x7b, 0x2e, 0x3b, 0xc5, 0x8e, 0xb1, 0xac, 0x46, 0x3e, 0x4c, 0x89, 0x7d, 0xf2, 0xc8, 0x0e,
	0xb6, 0x3c, 0xc2, 0xb0, 0x63, 0xdc, 0x90, 0xac, 0x69, 0x50, 0x78, 0x19, 0xc5, 0x1d, 0xc2, 0xf1,
	0x41, 0xaf, 0xff, 0x51, 0x57, 0x15, 0xfa, 0x00, 0x8c, 0x7e, 0x04, 0xb3, 0x8e, 0xcf, 0xb6, 0x48,
	0xe8, 0xf3, 0xcd, 0xae, 0x29, 0x0a, 0x34, 0xe3, 0xa6, 0x0c, 0x09, 0xef, 0x8f, 0xf4, 0x35, 0x91,
	0xcb, 0x24, 0x05, 0xa3, 0x3e, 0xcd, 0x80, 0x3a, 0x64, 0x83, 0x2e, 0x56, 0x8b, 0x5b, 0x22, 0xeb,
	0x53, 0x15, 0x66, 0x54, 0x25, 0x7f, 0x30, 0x96, 0x89, 0x94, 0x64, 0x14, 0x48, 0x07, 0x15, 0xa2,
	0x25, 0x28, 0xcb, 0x7c, 0x65, 0xcf, 0xf9, 0x4a, 0xd6, 0xb4, 0x13, 0x66, 0xef, 0x1d, 0xad, 0x82,
	0x7e, 0xca, 0x79, 0xb0, 0xd1, 0x6e, 0x53, 0xdc, 0xb6, 0x54, 0x23, 0x4e, 0x55, 0xb1, 0x43, 0x78,
	0x7c, 0x3c, 0x0f, 0x2d, 0xfb, 0x0c, 0x73, 0x75, 0xe8, 0xef, 0xc8, 0xdd, 0x1b, 0x84, 0xd1, 0x3b,
	0x30, 0x9f, 0x80, 0x7a, 0x07, 0xff, 0xae, 0xe4, 0xce, 0x22, 0xa1, 0x3b, 0x30, 0x23, 0xc7, 0x74,
	0x64, 0xd1, 0x36, 0xe6, 0x62, 0xa4, 0x2b, 0x72, 0xa4, 0x03, 0x28, 0xfa, 0x7f, 0x58, 0x70, 0xd9,
	0x23, 0x62, 0x5b, 0xde, 0x21, 0xa1, 0x7c, 0x3b, 0x38, 0xc5, 0x1d, 0x4c, 0x2d, 0x2f, 0x2a, 0x13,
	0xf3, 0x72, 0x9d, 0x1e, 0x9f, 0x10, 0x12, 0x8b, 0x83, 0xcd, 0x4c, 0x35, 0xe8, 0xa7, 0x1a, 0x5c,
	0x1b, 0x5c, 0xbf, 0xcd, 0xee, 0xd3, 0x10, 0xd3, 0xae, 0x6c, 0x71, 0xad, 0x8e, 0x68, 0x10, 0xe6,
	0xee, 0x4d, 0x42, 0x49, 0x94, 0xcf, 0x9d, 0x63, 0x06, 0xfd, 0x5a, 0x83, 0x9b, 0x83, 0xf4, 0x27,
	0x27, 0x27, 0x0c, 0xf3, 0xe4, 0x60, 0xde, 0x94, 0x83, 0xd9, 0xbd, 0xf8, 0x60, 0x86, 0x54, 0xa9,
	0x21, 0x8d, 0x36, 0xd9, 0xcb, 0x06, 0x45, 0xd5, 0x5a, 0x8b, 0xb2, 0x41, 0x03, 0xa6, 0xc4, 0xaf,
	0xd8, 0xb3, 0xb7, 0x55, 0x07, 0x36, 0x7a, 0x45, 0xcb, 0x00, 0x4c, 0x2c, 0xf6, 0x9e, 0xef, 0xe0,
	0xaf, 0x8c, 0x35, 0x79, 0x18, 0x13, 0x08, 0x6a, 0xc0, 0xb4, 0x60, 0xdd, 0x3a, 0xc5, 0xf6, 0x19,
	0x0b, 0x3b, 0xc6, 0x3d, 0xc9, 0x91, 0xc2, 0xd0, 0x03, 0x28, 0xcb, 0x16, 0xb3, 0x4d, 0x3c, 0xe3,
	0x9d, 0x73, 0x2f, 0xe1, 0xc3, 0x88, 0xad, 0xc5, 0x2d, 0xfb, 0xcc, 0xec, 0x49, 0xa1, 0x0f, 0xe1,
	0x8a, 0x10, 0x68, 0x71, 0x8a, 0xad, 0x0e, 0x4b, 0x79, 0xfa, 0xbb, 0xd2, 0xd3, 0xf3, 0xc8, 0x22,
	0x7a, 0x89, 0x43, 0xb0, 0x9e, 0x92, 0x59, 0x57, 0x3d, 0x9e, 0x21, 0x82, 0x28, 0xa0, 0xb3, 0x0e,
	0x7d, 0x32, 0xf7, 0xa8, 0x65, 0x24, 0x31, 0xb5, 0x64, 0x12, 0xe3, 0xc0, 0x62, 0xe6, 0xa9, 0xce,
	0xa8, 0xc2, 0xc7, 0x4f, 0xfa, 0xa4, 0xba, 0xa4, 0x95, 0xaf, 0xa1, 0x3e, 0xca, 0x3f, 0x33, 0x0c,
	0x3e, 0x48, 0x1b, 0x5c, 0x1d, 0x61, 0x30, 0xa1, 0x31, 0x69, 0xfb, 0xc7, 0x1a, 0xdc, 0x19, 0xcf,
	0x1f, 0xff, 0x53, 0x43, 0xd8, 0x2f, 0x95, 0x0b, 0x7a, 0x71, 0xbf, 0x54, 0x2e, 0xea, 0xa5, 0x81,
	0x82, 0xb8, 0xac, 0x57, 0x7a, 0x65, 0xf1, 0xb4, 0x5e, 0xeb, 0x15, 0xc7, 0x33, 0xfa, 0xec, 0x7e,
	0xa9, 0x3c, 0xab, 0xeb, 0xfb, 0xa5, 0xf2, 0x2d, 0xfd, 0x76, 0xe3, 0x77, 0x1a, 0xe8, 0x83, 0xbd,
	0x14, 0x34, 0x03, 0x85, 0x28, 0x09, 0xac, 0x98, 0x05, 0xd7, 0x89, 0x87, 0x5f, 0xe8, 0xef, 0xbb,
	0x01, 0x53, 0xc7, 0x5d, 0x8e, 0x1f, 0x62, 0x55, 0xcb, 0x4e, 0x9b, 0xf1, 0x6b, 0xef, 0x5c, 0x95,
	0x12, 0x55, 0xd6, 0x12, 0x94, 0xb9, 0xd5, 0x56, 0x67, 0x47, 0x7d, 0xda, 0xe8, 0xbd, 0xc7, 0x27,
	0xe7, 0x31, 0x71, 0xdc, 0x13, 0x17, 0x3b, 0x32, 0x67, 0x2c, 0x9a, 0x29, 0xac, 0xf1, 0xcd, 0x84,
	0xec, 0xe8, 0x0c, 0x15, 0xc5, 0xe8, 0x13, 0xb8, 0xda, 0x21, 0x3e, 0xe1, 0xc4, 0x77, 0xed, 0x87,
	0x01, 0x25, 0xc7, 0x98, 0x1d, 0x51, 0xb7, 0xdd, 0xc6, 0x14, 0xab, 0xf1, 0x17, 0xcd, 0x7c, 0x06,
	0x91, 0x86, 0x0c, 0x12, 0x1f, 0xbb, 0x4c, 0x44, 0x5b, 0x95, 0x92, 0xe7, 0x50, 0xd1, 0x03, 0xb8,
	0xd6, 0xa3, 0x88, 0x61, 0x71, 0x2a, 0x8e, 0x29, 0x6e, 0xbb, 0x8c, 0x63, 0xca, 0xe4, 0x82, 0x14,
	0xcd, 0xf3, 0x58, 0xd0, 0x01, 0x34, 0xce, 0x21, 0x37, 0x29, 0x09, 0x02, 0xec, 0x18, 0x25, 0xa9,
	0x68, 0x0c, 0x4e, 0xb4, 0x09, 0xd7, 0x7b, 0x5c, 0x4d, 0x9f, 0x45, 0x21, 0xe9, 0x50, 0xb9, 0x12,
	0x56, 0xdf, 0x93, 0x8a, 0xe6, 0xb9, 0x3c, 0x22, 0xad, 0x49, 0x59, 0x62, 0x51, 0xe6, 0xa1, 0x36,
	0x24, 0x93, 0x26, 0xe2, 0xa8, 0x6c, 0x90, 0x6c, 0x06, 0x27, 0x8f, 0x2d, 0xf5, 0x79, 0x6a, 0x4a,
	0xb2, 0x0f, 0xc2, 0xe8, 0x33, 0x58, 0xea, 0x69, 0x78, 0xe6, 0x04, 0x2d, 0xec, 0x3b, 0x89, 0xf1,
	0x95, 0xa5, 0xd0, 0x39, 0x1c, 0xe2, 0xea, 0x1b, 0xa2, 0x46, 0x9b, 0x55, 0x91, 0xc2, 0x79, 0x64,
	0xf4, 0x31, 0x18, 0x76, 0xbc, 0x70, 0x2d, 0xab, 0x13, 0x78, 0xae, 0xdf, 0x3e, 0xc4, 0xd4, 0x16,
	0x41, 0x1f, 0xa4, 0x68, 0x2e, 0x5d, 0xcc, 0x2f, 0x8e, 0x24, 0xf1, 0xa6, 0x54, 0xd5, 0xfc, 0x06,
	0xe0, 0xc6, 0x6f, 0x4a, 0xf0, 0xda, 0xb9, 0xdf, 0x70, 0x44, 0x7e, 0x72, 0x96, 0xed, 0xa2, 0x43,
	0xb8, 0xfc, 0x78, 0x93, 0xe1, 0x90, 0x69, 0x50, 0x24, 0x95, 0x76, 0x9e, 0xfb, 0x65, 0x50, 0xc4,
	0x69, 0xb1, 0x47, 0x38, 0x5b, 0x3e, 0x83, 0xc8, 0x84, 0x9c, 0x5c, 0xd7, 0xca, 0x22, 0x89, 0xf4,
	0xdb, 0x1e, 0x72, 0xa4, 0x24, 0x74, 0x01, 0xff, 0x79, 0x0b, 0xe6, 0xc2, 0x1c, 0xb7, 0x19, 0x26,
	0x88, 0x1c, 0x2c, 0xcc, 0x72, 0x92, 0x01, 0xf4, 0x7b, 0xf2, 0x8d, 0xbf, 0x17, 0xe0, 0xda, 0x39,
	0xfd, 0x03, 0xb1, 0x2f, 0x74, 0x88, 0xbc, 0xed, 0x5b, 0xc7, 0x5e, 0xe4, 0x22, 0x65, 0x33, 0x9f,
	0x01, 0x9d, 0x81, 0x31, 0x4c, 0x8c, 0xba, 0x4b, 0xaa, 0x23, 0x70, 0x6f, 0xec, 0x9e, 0x46, 0xd4,
	0x1f, 0xc8, 0x55, 0x28, 0x8e, 0xf1, 0x30, 0xad, 0x19, 0xb7, 0xe9, 0x94, 0xeb, 0x9d, 0xc3, 0x71,
	0x5e, 0x27, 0xac, 0xf4, 0x4a, 0x3b, 0x61, 0x0d, 0x0e, 0x68, 0xb8, 0x2f, 0x28, 0xf2, 0x38, 0x3f,
	0xe8, 0xa4, 0xd7, 0x36, 0x81, 0x08, 0x7a, 0xc8, 0x7a, 0xf4, 0x82, 0xa2, 0xf7, 0x11, 0x41, 0x77,
	0xfa, 0xf4, 0xa2, 0xa2, 0xf7, 0x91, 0xc6, 0x67, 0x30, 0x21, 0xfb, 0xaa, 0xe8, 0x3d, 0x98, 0x64,
	0xe1, 0xb1, 0x8f, 0xb9, 0x34, 0x52, 0x5d, 0x7f, 0x2d, 0x67, 0x5e, 0x2d, 0xc9, 0x64, 0x46, 0xcc,
	0x8d, 0x65, 0x98, 0x54, 0x88, 0xc8, 0xac, 0x2c, 0xcf, 0xb5, 0x58, 0x14, 0x86, 0xd5, 0x4b, 0xa3,
	0x0b, 0xb5, 0xd4, 0xc7, 0xc5, 0x6c, 0xb6, 0x54, 0xc0, 0x2d, 0x8c, 0x08, 0xb8, 0xc5, 0xe1, 0x80,
	0x9b, 0x15, 0xc4, 0x1b, 0xbf, 0xd0, 0xa0, 0x96, 0xea, 0x0e, 0x88, 0x22, 0x9f, 0xe2, 0xc0, 0x6b,
	0x51, 0x7b, 0xef, 0x30, 0xb2, 0xdf, 0x07, 0x62, 0x6a, 0x93, 0xf1, 0xbd, 0xc3, 0xe8, 0xfb, 0x4a,
	0x1f, 0x10, 0x77, 0x43, 0xc4, 0x2a, 0xca, 0x16, 0x39, 0x88, 0x09, 0x33, 0x09, 0xc5, 0x1c, 0x4d,
	0xc6, 0x25, 0x47, 0xa9, 0xcf, 0x11, 0x41, 0x8d, 0xaf, 0xa1, 0xb4, 0xe1, 0x38, 0x54, 0xa6, 0x2b,
	0x41, 0x64, 0xa2, 0xe0, 0x06, 0x62, 0xf4, 0x41, 0x5f, 0xa9, 0x7c, 0x8e, 0xee, 0x22, 0xf5, 0x4d,
	0x28, 0xfa, 0x83, 0x45, 0xc5, 0x4c, 0x42, 0xa9, 0xff, 0x77, 0x4c, 0xa5, 0xff, 0xdf, 0x31, 0xf0,
	0xc9, 0x61, 0x52, 0x9f, 0x6a, 0xec, 0x43, 0x2d, 0x95, 0xa5, 0xa3, 0x8f, 0x60, 0x82, 0x89, 0x07,
	0xf9, 0x6d, 0x61, 0x66, 0xfd, 0xd6, 0x88, 0xd4, 0x5e, 0x65, 0x72, 0x52, 0xa2, 0x51, 0x87, 0x72,
	0xdc, 0xd0, 0x94, 0x4d, 0x1c, 0xab, 0x83, 0xd5, 0x27, 0x8a, 0x8a, 0xa9, 0x5e, 0x1a, 0x7f, 0x28,
	0x48, 0x16, 0x79, 0xab, 0x0c, 0x76, 0x35, 0xb4, 0xf1, 0xbb, 0x1a, 0x85, 0xef, 0xd0, 0xd5, 0x28,
	0x9e, 0xd3, 0xd5, 0xf8, 0xc1, 0x70, 0x57, 0xa1, 0x24, 0x2b, 0xb9, 0xfb, 0x23, 0xd2, 0xd9, 0xf1,
	0x7a, 0x0a, 0xaf, 0xa2, 0x0e, 0x69, 0xfc, 0x43, 0x83, 0xf9, 0x8c, 0x2c, 0x1a, 0x85, 0x32, 0x9c,
	0x0d, 0xc2, 0xd1, 0x97, 0xa1, 0xad, 0xf1, 0xd3, 0xf1, 0x44, 0x49, 0x3a, 0x50, 0x84, 0x66, 0xe9,
	0x5f, 0x6a, 0x83, 0x91, 0x27, 0xf0, 0x4a, 0x2b, 0xa3, 0xd5, 0x5f, 0x15, 0xc0, 0xc8, 0xbb, 0xe0,
	0x91, 0x0e, 0xd3, 0x07, 0x84, 0x6f, 0x70, 0x8e, 0x3b, 0x01, 0xc7, 0x8e, 0x7e, 0x09, 0x5d, 0x06,
	0x94, 0x60, 0x8b, 0xdc, 0x43, 0xd7, 0xd0, 0x02, 0xe8, 0x0f, 0x93, 0xff, 0x18, 0xd9, 0xa6, 0x54,
	0x2f, 0xa0, 0x45, 0x98, 0x7b, 0x8e, 0xa9, 0x7b, 0xe2, 0xda, 0x2a, 0x14, 0x51, 0x4a, 0xa8, 0x5e,
	0x14, 0x6a, 0x9f, 0x84, 0x3c, 0x08, 0x79, 0xd3, 0xa5, 0x82, 0xb1, 0x84, 0xe6, 0xa0, 0xa6, 0x90,
	0x1d, 0xd7, 0xc3, 0x02, 0x9a, 0x40, 0x08, 0x66, 0x0e, 0xf0, 0x4b, 0x65, 0x0c, 0x4b, 0xb6, 0x49,
	0x81, 0x25, 0x23, 0x1b, 0xa5, 0xfa, 0x94, 0x10, 0x8d, 0xee, 0x78, 0x6c, 0x39, 0x02, 0x2a, 0x0b,
	0xb6, 0xc4, 0x45, 0x2f, 0xb0, 0x0a, 0xba, 0x02, 0xf3, 0x91, 0x2e, 0x27, 0xb2, 0x44, 0x42, 0xdf,
	0xd1, 0x41, 0x30, 0xef, 0xf9, 0x41, 0xc8, 0x77, 0x2d, 0x76, 0xaa, 0x06, 0x58, 0x5d, 0xfd, 0x7d,
	0x01, 0xae, 0xe4, 0x44, 0x12, 0x31, 0x27, 0xf9, 0x9a, 0xb1, 0x30, 0x21, 0xe3, 0xa4, 0xa3, 0x24,
	0x98, 0x52, 0xaf, 0x09, 0xbb, 0x4d, 0x7c, 0x62, 0x85, 0x1e, 0x4f, 0x11, 0xe4, 0xda, 0xb4, 0xba,
	0xec, 0x84, 0xa5, 0xe0, 0x22, 0x5a, 0x82, 0xcb, 0x4d, 0xf2, 0xd2, 0xf7, 0x88, 0xe5, 0x60, 0x27,
	0x45, 0x2b, 0xa1, 0x79, 0x98, 0x8d, 0x69, 0xf1, 0xca, 0xcb, 0x75, 0xda, 0x25, 0x8c, 0x27, 0xd6,
	0x7d, 0x32, 0xc9, 0x18, 0x9d, 0x46, 0x7d, 0x4a, 0x6e, 0x86, 0xe5, 0xb9, 0x8e, 0xa5, 0xda, 0xe2,
	0x0a, 0x2e, 0xa3, 0xab, 0xb0, 0x68, 0xe2, 0x80, 0xb0, 0xa6, 0x4b, 0x37, 0xa4, 0xce, 0x98, 0x54,
	0x41, 0xb7, 0xe0, 0x46, 0x34, 0x82, 0x03, 0xa2, 0xd6, 0x2b, 0xd6, 0xda, 0x74, 0x99, 0x0c, 0x64,
	0x3a, 0xac, 0xfe, 0x56, 0x03, 0xe8, 0x7f, 0x33, 0x10, 0x8e, 0x10, 0x8d, 0x4d, 0x2d, 0xc7, 0xe6,
	0xd1, 0x8e, 0x5a, 0x9d, 0x08, 0xdd, 0xee, 0x1c, 0x63, 0xc7, 0xc1, 0x8e, 0xc0, 0x35, 0xb9, 0x08,
	0x0a, 0x8f, 0x16, 0x49, 0xc0, 0x05, 0x34, 0x0b, 0xd5, 0x4d, 0x7e, 0x12, 0x1b, 0xd5, 0x8b, 0x62,
	0x92, 0xf2, 0xdb, 0x46, 0xb4, 0xc7, 0x24, 0xf2, 0x19, 0xe5, 0x5c, 0xd2, 0x3b, 0x88, 0xf0, 0x99,
	0x59, 0xa8, 0x3e, 0x12, 0x0b, 0x17, 0x01, 0x93, 0xab, 0x0d, 0xd0, 0x07, 0x3f, 0x05, 0xa0, 0x49,
	0x28, 0xbc, 0xb8, 0xaf, 0x5f, 0x92, 0xbf, 0xef, 0xeb, 0xda, 0xea, 0xe7, 0xc2, 0x33, 0x86, 0x3a,
	0xe6, 0x42, 0x57, 0xe8, 0xb3, 0x00, 0xdb, 0x32, 0xd4, 0xe9, 0x97, 0xd0, 0x34, 0x94, 0x5d, 0xdf,
	0x26, 0x1d, 0xd7, 0x6f, 0xeb, 0x9a, 0x78, 0x23, 0x21, 0x6f, 0x13, 0xf1, 0x56, 0x40, 0x15, 0x98,
	0xf0, 0x88, 0x6d, 0x79, 0x7a, 0x11, 0x95, 0xa1, 0xe4, 0x13, 0x1f, 0xeb, 0xa5, 0xd5, 0x67, 0x80,
	0x86, 0xdb, 0x70, 0xc8, 0x80, 0x05, 0x1c, 0xa3, 0xcf, 0x52, 0x06, 0xe6, 0xa0, 0xd6, 0xa3, 0x1c,
	0xd1, 0x10, 0xeb, 0x9a, 0x98, 0x77, 0x0f, 0xda, 0xb1, 0x3c, 0x86, 0xf5, 0xc2, 0xea, 0xdf, 0x34,
	0x98, 0x4e, 0x86, 0x07, 0xa1, 0x31, 0x6e, 0xfd, 0x3c, 0xf3, 0x6d, 0xcf, 0x62, 0x2c, 0xd6, 0x38,
	0x0f, 0xb3, 0x7d, 0xca, 0x99, 0x4f, 0x5e, 0xfa, 0xba, 0x26, 0x4e, 0x5f, 0x0c, 0xee, 0x1e, 0x1d,
	0x1d, 0xea, 0x05, 0x61, 0x38, 0x89, 0xac, 0xeb, 0x45, 0x31, 0xfb, 0x18, 0x3a, 0x7a, 0xd4, 0x52,
	0xab, 0x1d, 0x03, 0x0f, 0xad, 0x93, 0x33, 0x4b, 0x9f, 0x48, 0x42, 0x8f, 0x89, 0xdf, 0x26, 0xfa,
	0xa4, 0xd8, 0xfd, 0x18, 0x3a, 0x24, 0x8c, 0xb7, 0x29, 0x66, 0xfa, 0x54, 0xd2, 0xe2, 0xc6, 0xe3,
	0xa7, 0x87, 0x7a, 0x39, 0x29, 0x6a, 0x62, 0xc7, 0x65, 0x7a, 0x25, 0xa5, 0xad, 0xdb, 0x7a, 0xfa,
	0x48, 0x87, 0xcd, 0x4f, 0xff, 0xf8, 0xed, 0xb2, 0xf6, 0xe7, 0x6f, 0x97, 0xb5, 0xbf, 0x7c, 0xbb,
	0xac, 0xfd, 0xf2, 0xaf, 0xcb, 0x97, 0xbe, 0x78, 0xb3, 0xed, 0xf2, 0xd3, 0xf0, 0x78, 0xcd, 0x26,
	0x9d, 0x7b, 0x4d, 0x8b, 0x5b, 0x4d, 0xd2, 0x56, 0xff, 0xca, 0x7c, 0x3b, 0xb0, 0xba, 0xc2, 0x31,
	0xef, 0xbd, 0x78, 0x2f, 0xfe, 0xbb, 0xe6, 0xf1, 0xa4, 0xd4, 0xf7, 0x3f, 0xff, 0x0a, 0x00, 0x00,
	0xff, 0xff, 0x3a, 0x62, 0xd8, 0xcf, 0xfe, 0x29, 0x00, 0x00,
}
